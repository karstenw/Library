<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="karstenw.20230319195648.2" a="E"><vh>graph</vh>
<v t="karstenw.20230319195720.1"><vh>@clean __init__.py</vh>
<v t="karstenw.20230319195736.1"><vh>Declarations</vh></v>
<v t="karstenw.20230319202717.1"><vh>py3</vh>
<v t="karstenw.20230319202717.2"><vh>py3 stuff</vh></v>
<v t="karstenw.20230319202717.3"><vh>cmp_to_key</vh></v>
<v t="karstenw.20230319202717.4"><vh>sortlist</vh></v>
<v t="karstenw.20230320154844.1"><vh>FlowerWord</vh>
<v t="karstenw.20230320154844.2"><vh>__init__</vh></v>
<v t="karstenw.20230320154844.3"><vh>hyponyms</vh></v>
<v t="karstenw.20230320154844.4"><vh>hypernyms</vh></v>
<v t="karstenw.20230320154844.5"><vh>senses</vh></v>
<v t="karstenw.20230321100722.1"><vh>holonyms</vh></v>
<v t="karstenw.20230321101136.1"><vh>meronyms</vh></v>
</v>
<v t="karstenw.20230319203345.1"><vh>newHeadline</vh></v>
</v>
<v t="karstenw.20230319195736.2"><vh>class node</vh>
<v t="karstenw.20230319195736.3"><vh>__init__</vh></v>
<v t="karstenw.20230319195736.4"><vh>_edges</vh></v>
<v t="karstenw.20230319195736.5"><vh>_is_leaf</vh></v>
<v t="karstenw.20230319195736.6"><vh>can_reach</vh></v>
<v t="karstenw.20230319195736.7"><vh>_get_betweenness</vh></v>
<v t="karstenw.20230319195736.8"><vh>_get_eigenvalue</vh></v>
<v t="karstenw.20230319195736.9"><vh>_x</vh></v>
<v t="karstenw.20230319195736.10"><vh>_y</vh></v>
<v t="karstenw.20230319195736.11"><vh>__contains__</vh></v>
<v t="karstenw.20230319195736.12"><vh>flatten</vh></v>
<v t="karstenw.20230319195736.13"><vh>__and__</vh></v>
<v t="karstenw.20230319195736.14"><vh>__or__</vh></v>
<v t="karstenw.20230319195736.15"><vh>__sub__</vh></v>
<v t="karstenw.20230319195736.16"><vh>__repr__</vh></v>
<v t="karstenw.20230319195736.17"><vh>__str__</vh></v>
<v t="karstenw.20230319195736.18"><vh>__eq__</vh></v>
<v t="karstenw.20230319195736.19"><vh>__le__</vh></v>
</v>
<v t="karstenw.20230319195736.20"><vh>class links</vh>
<v t="karstenw.20230319195736.21"><vh>__init__</vh></v>
<v t="karstenw.20230319195736.22"><vh>append</vh></v>
<v t="karstenw.20230319195736.23"><vh>remove</vh></v>
<v t="karstenw.20230319195736.24"><vh>edge</vh></v>
</v>
<v t="karstenw.20230319195736.25"><vh>class edge</vh>
<v t="karstenw.20230319195736.26"><vh>__init__</vh></v>
<v t="karstenw.20230319195736.27"><vh>_get_length</vh></v>
<v t="karstenw.20230319195736.28"><vh>_set_length</vh></v>
</v>
<v t="karstenw.20230319195736.29"><vh>class graph</vh>
<v t="karstenw.20230319195736.30"><vh>__init__</vh></v>
<v t="karstenw.20230319195736.31"><vh>_get_distance</vh></v>
<v t="karstenw.20230319195736.32"><vh>_set_distance</vh></v>
<v t="karstenw.20230319195736.33"><vh>copy</vh></v>
<v t="karstenw.20230319195736.34"><vh>clear</vh></v>
<v t="karstenw.20230319195736.35"><vh>new_node</vh></v>
<v t="karstenw.20230319195736.36"><vh>new_edge</vh></v>
<v t="karstenw.20230319195736.37"><vh>add_node</vh></v>
<v t="karstenw.20230319195736.38"><vh>add_nodes</vh></v>
<v t="karstenw.20230319195736.39"><vh>add_edge</vh></v>
<v t="karstenw.20230319195736.40"><vh>remove_node</vh></v>
<v t="karstenw.20230319195736.41"><vh>remove_edge</vh></v>
<v t="karstenw.20230319195736.42"><vh>node</vh></v>
<v t="karstenw.20230319195736.43"><vh>edge</vh></v>
<v t="karstenw.20230319195736.44"><vh>__getattr__</vh></v>
<v t="karstenw.20230319195736.45"><vh>update</vh></v>
<v t="karstenw.20230319195736.46"><vh>solve</vh></v>
<v t="karstenw.20230319195736.47"><vh>_done</vh></v>
<v t="karstenw.20230319195736.48"><vh>offset</vh></v>
<v t="karstenw.20230319195736.49"><vh>draw</vh></v>
<v t="karstenw.20230319195736.50"><vh>prune</vh></v>
<v t="karstenw.20230319195736.51"><vh>shortest_path</vh></v>
<v t="karstenw.20230319195736.52"><vh>betweenness_centrality</vh></v>
<v t="karstenw.20230319195736.53"><vh>eigenvector_centrality</vh></v>
<v t="karstenw.20230319195736.54"><vh>nodes_by_betweenness</vh></v>
<v t="karstenw.20230319195736.55"><vh>nodes_by_eigenvalue</vh></v>
<v t="karstenw.20230319195736.56"><vh>nodes_by_category</vh></v>
<v t="karstenw.20230319195736.57"><vh>_leaves</vh></v>
<v t="karstenw.20230319195736.58"><vh>crown</vh></v>
<v t="karstenw.20230319195736.59"><vh>_density</vh></v>
<v t="karstenw.20230319195736.60"><vh>_is_complete, _is_dense, _is_sparse</vh></v>
<v t="karstenw.20230319195736.63"><vh>sub</vh></v>
<v t="karstenw.20230319195736.64"><vh>__and__</vh></v>
<v t="karstenw.20230319195736.65"><vh>__or__</vh></v>
<v t="karstenw.20230319195736.66"><vh>__sub__</vh></v>
<v t="karstenw.20230319195736.67"><vh>_is_clique</vh></v>
<v t="karstenw.20230319195736.68"><vh>clique</vh></v>
<v t="karstenw.20230319195736.69"><vh>cliques</vh></v>
<v t="karstenw.20230319195736.70"><vh>split</vh></v>
</v>
<v t="karstenw.20230319195736.71"><vh>class xgraph</vh>
<v t="karstenw.20230319195736.72"><vh>__init__</vh></v>
<v t="karstenw.20230319195736.73"><vh>has_node</vh></v>
<v t="karstenw.20230319195736.74"><vh>get_links</vh></v>
<v t="karstenw.20230319195736.75"><vh>get_cluster</vh></v>
<v t="karstenw.20230319195736.76"><vh>load</vh></v>
<v t="karstenw.20230319195736.77"><vh>click</vh></v>
<v t="karstenw.20230319195736.78"><vh>draw</vh></v>
</v>
<v t="karstenw.20230319195736.79"><vh>create</vh></v>
</v>
<v t="karstenw.20230329160917.1" a="E"><vh>@clean cluster.py</vh>
<v t="karstenw.20230329160929.1"><vh>Declarations</vh></v>
<v t="karstenw.20230518183122.1" a="E"><vh>py3</vh>
<v t="karstenw.20230518183122.2"><vh>py3 stuff</vh></v>
<v t="karstenw.20230518183122.3"><vh>cmp_to_key</vh></v>
<v t="karstenw.20230518183122.4"><vh>sortlist</vh></v>
<v t="karstenw.20230518183122.5"><vh>FlowerWord</vh>
<v t="karstenw.20230518183122.6"><vh>__init__</vh></v>
<v t="karstenw.20230518183122.7"><vh>hyponyms</vh></v>
<v t="karstenw.20230518183122.8"><vh>hypernyms</vh></v>
<v t="karstenw.20230518183122.9"><vh>senses</vh></v>
<v t="karstenw.20230518183122.10"><vh>holonyms</vh></v>
<v t="karstenw.20230518183122.11"><vh>meronyms</vh></v>
</v>
<v t="karstenw.20230518183122.12"><vh>newHeadline</vh></v>
</v>
<v t="karstenw.20230329160948.1"><vh>+ LIST OPERATIONS +</vh>
<v t="karstenw.20230329160929.2"><vh>sorted</vh></v>
<v t="karstenw.20230329160929.3"><vh>unique</vh></v>
</v>
<v t="karstenw.20230329161013.1"><vh>+ SET THEORY +</vh>
<v t="karstenw.20230329160929.4"><vh>flatten</vh></v>
<v t="karstenw.20230329160929.5"><vh>intersection</vh></v>
<v t="karstenw.20230329160929.6"><vh>union</vh></v>
<v t="karstenw.20230329160929.7"><vh>difference</vh></v>
</v>
<v t="karstenw.20230329160929.8"><vh>subgraph</vh></v>
<v t="karstenw.20230329161057.1"><vh>+ CLIQUE +</vh>
<v t="karstenw.20230329160929.9"><vh>is_clique</vh></v>
<v t="karstenw.20230329160929.10"><vh>clique</vh></v>
<v t="karstenw.20230329160929.11"><vh>cliques</vh></v>
</v>
<v t="karstenw.20230329160929.12"><vh>partition</vh></v>
</v>
<v t="karstenw.20230329161629.1"><vh>@clean event.py</vh>
<v t="karstenw.20230329161638.1"><vh>Declarations</vh></v>
<v t="karstenw.20230329161638.2"><vh>class Point</vh>
<v t="karstenw.20230329161638.3"><vh>__init__</vh></v>
</v>
<v t="karstenw.20230329161815.1" a="E"><vh>+ GRAPH HOVER/CLICK/DRAG EVENTS +</vh>
<v t="karstenw.20230329161638.4"><vh>class events</vh>
<v t="karstenw.20230329161638.5"><vh>__init__</vh></v>
<v t="karstenw.20230329161638.6"><vh>copy</vh></v>
<v t="karstenw.20230329161638.7"><vh>_mouse</vh></v>
<v t="karstenw.20230329161638.8"><vh>_mousedown</vh></v>
<v t="karstenw.20230329161638.9"><vh>update</vh></v>
<v t="karstenw.20230329161638.10"><vh>drag</vh></v>
<v t="karstenw.20230329161638.11"><vh>hover</vh></v>
<v t="karstenw.20230329161638.12"><vh>click</vh></v>
</v>
</v>
<v t="karstenw.20230329161904.1" a="E"><vh>+ POPUP +</vh>
<v t="karstenw.20230329161638.13"><vh>class popup</vh>
<v t="karstenw.20230329161638.14"><vh>__init__</vh></v>
<v t="karstenw.20230329161638.15"><vh>textpath</vh></v>
<v t="karstenw.20230329161638.16"><vh>update</vh></v>
<v t="karstenw.20230329161638.17"><vh>draw</vh></v>
</v>
</v>
</v>
<v t="karstenw.20230329162253.1"><vh>@clean layout.py</vh>
<v t="karstenw.20230329162306.1"><vh>Declarations</vh></v>
<v t="karstenw.20230329162306.2"><vh>class Point</vh>
<v t="karstenw.20230329162306.3"><vh>__init__</vh></v>
</v>
<v t="karstenw.20230329162353.1" a="E"><vh>+ GRAPH LAYOUT +</vh>
<v t="karstenw.20230329162306.4"><vh>class layout</vh>
<v t="karstenw.20230329162306.5"><vh>__init__</vh></v>
<v t="karstenw.20230329162306.6"><vh>copy</vh></v>
<v t="karstenw.20230329162306.7"><vh>prepare</vh></v>
<v t="karstenw.20230329162306.8"><vh>_bounds</vh></v>
<v t="karstenw.20230329162306.9"><vh>_get_done</vh></v>
<v t="karstenw.20230329162306.10"><vh>iterate</vh></v>
<v t="karstenw.20230329162306.11"><vh>solve</vh></v>
<v t="karstenw.20230329162306.12"><vh>reset</vh></v>
<v t="karstenw.20230329162306.13"><vh>refresh</vh></v>
</v>
</v>
<v t="karstenw.20230329162416.1" a="E"><vh>+ GRAPH CIRCLE LAYOUT +</vh>
<v t="karstenw.20230329162306.14"><vh>class circle_layout</vh>
<v t="karstenw.20230329162306.15"><vh>__init__</vh></v>
<v t="karstenw.20230329162306.16"><vh>_get_orbits</vh></v>
<v t="karstenw.20230329162306.17"><vh>_set_orbits</vh></v>
<v t="karstenw.20230329162306.18"><vh>copy</vh></v>
<v t="karstenw.20230329162306.19"><vh>iterate</vh></v>
<v t="karstenw.20230329162306.20"><vh>solve</vh></v>
</v>
</v>
<v t="karstenw.20230329162442.1" a="E"><vh>+ GRAPH SPRING LAYOUT +</vh>
<v t="karstenw.20230329162306.21"><vh>class spring_layout</vh>
<v t="karstenw.20230329162306.22"><vh>__init__</vh></v>
<v t="karstenw.20230329162306.23"><vh>tweak</vh></v>
<v t="karstenw.20230329162306.24"><vh>_get_force</vh></v>
<v t="karstenw.20230329162306.25"><vh>_set_force</vh></v>
<v t="karstenw.20230329162306.26"><vh>_get_repulsion</vh></v>
<v t="karstenw.20230329162306.27"><vh>_set_repulsion</vh></v>
<v t="karstenw.20230329162306.28"><vh>copy</vh></v>
<v t="karstenw.20230329162306.29"><vh>iterate</vh></v>
<v t="karstenw.20230329162306.30"><vh>_distance</vh></v>
<v t="karstenw.20230329162306.31"><vh>_repulse</vh></v>
<v t="karstenw.20230329162306.32"><vh>_attract</vh></v>
</v>
</v>
</v>
<v t="karstenw.20230329163013.1"><vh>@clean proximity.py</vh>
<v t="karstenw.20230329163023.1"><vh>Declarations</vh></v>
<v t="karstenw.20230329163023.2"><vh>class priorityqueue</vh>
<v t="karstenw.20230329163023.3"><vh>push</vh></v>
<v t="karstenw.20230329163023.4"><vh>pop</vh></v>
</v>
<v t="karstenw.20230329163023.5"><vh>depth_first_search</vh></v>
<v t="karstenw.20230329163023.6"><vh>adjacency</vh></v>
<v t="karstenw.20230329163024.1"><vh>dijkstra_shortest_path</vh></v>
<v t="karstenw.20230329163024.2"><vh>brandes_betweenness_centrality</vh></v>
<v t="karstenw.20230329163024.3"><vh>class NoConvergenceError</vh></v>
<v t="karstenw.20230329163024.4"><vh>eigenvector_centrality</vh></v>
</v>
<v t="karstenw.20230329163234.1"><vh>@clean style.py</vh>
<v t="karstenw.20230329163243.1"><vh>Declarations</vh></v>
<v t="karstenw.20230507112117.1"><vh>newHeadline</vh></v>
<v t="karstenw.20230329163243.2"><vh>class styles</vh>
<v t="karstenw.20230329163243.3"><vh>__init__</vh></v>
<v t="karstenw.20230329163243.4"><vh>apply</vh></v>
<v t="karstenw.20230329163243.5"><vh>create</vh></v>
<v t="karstenw.20230329163243.6"><vh>append</vh></v>
<v t="karstenw.20230329163243.7"><vh>__getattr__</vh></v>
<v t="karstenw.20230329163243.8"><vh>__setattr__</vh></v>
<v t="karstenw.20230329163243.9"><vh>copy</vh></v>
</v>
<v t="karstenw.20230329163243.10"><vh>class styleguide</vh>
<v t="karstenw.20230329163243.11"><vh>__init__</vh></v>
<v t="karstenw.20230329163243.12"><vh>append</vh></v>
<v t="karstenw.20230329163243.13"><vh>clear</vh></v>
<v t="karstenw.20230329163243.14"><vh>apply</vh></v>
<v t="karstenw.20230329163243.15"><vh>copy</vh></v>
</v>
<v t="karstenw.20230329163243.16"><vh>class style</vh>
<v t="karstenw.20230329163243.17"><vh>__init__</vh></v>
<v t="karstenw.20230329163243.18"><vh>copy</vh></v>
</v>
<v t="karstenw.20230329163243.19"><vh>graph_background</vh></v>
<v t="karstenw.20230329163243.20"><vh>graph_traffic</vh></v>
<v t="karstenw.20230329163243.21"><vh>node</vh></v>
<v t="karstenw.20230329163243.22"><vh>node_label</vh></v>
<v t="karstenw.20230329163243.23"><vh>edges</vh></v>
<v t="karstenw.20230329163243.24"><vh>edge</vh></v>
<v t="karstenw.20230329163243.25"><vh>edge_arrow</vh></v>
<v t="karstenw.20230329163243.26"><vh>edge_label</vh></v>
<v t="karstenw.20230329163243.27"><vh>path</vh></v>
</v>
</v>
<v t="karstenw.20230507120719.1"><vh>examples</vh>
<v t="karstenw.20230507120724.1"><vh>@clean graph_example1.py</vh>
<v t="karstenw.20230507120759.1"><vh>Declarations</vh></v>
</v>
<v t="karstenw.20230507120741.1"><vh>@clean graph_example2.py</vh>
<v t="karstenw.20230507120757.1"><vh>Declarations</vh></v>
</v>
<v t="karstenw.20230507120743.1"><vh>@clean graph_example3.py</vh>
<v t="karstenw.20230507120755.1"><vh>Declarations</vh></v>
<v t="karstenw.20230507120755.2"><vh>draw</vh></v>
</v>
<v t="karstenw.20230507120747.1"><vh>@clean graph_example4.py</vh>
<v t="karstenw.20230507120753.1"><vh>Declarations</vh></v>
<v t="karstenw.20230518121333.1" a="E"><vh>+ REPLACEMENTS</vh>
<v t="karstenw.20230507120753.2"><vh>holonym</vh></v>
<v t="karstenw.20230507120753.3"><vh>meronym</vh></v>
<v t="karstenw.20230507120753.4"><vh>antonym</vh></v>
<v t="karstenw.20230507120753.5"><vh>hypernym</vh></v>
<v t="karstenw.20230507120753.6"><vh>senses</vh></v>
<v t="karstenw.20230507120753.7"><vh>hyponym</vh></v>
</v>
<v t="karstenw.20230507120753.8"><vh>class wordnetgraph</vh>
<v t="karstenw.20230507120753.9"><vh>__init__</vh></v>
<v t="karstenw.20230507120753.10"><vh>is_expandable</vh></v>
<v t="karstenw.20230507120753.11"><vh>is_clickable</vh></v>
<v t="karstenw.20230507120753.12"><vh>get_senses</vh></v>
<v t="karstenw.20230507120753.13"><vh>get_relations</vh></v>
<v t="karstenw.20230507120753.14"><vh>expand</vh></v>
<v t="karstenw.20230507120753.15"><vh>click</vh></v>
<v t="karstenw.20230507120753.16"><vh>load</vh></v>
<v t="karstenw.20230507120753.17"><vh>draw</vh></v>
</v>
<v t="karstenw.20230507120753.18"><vh>class senses</vh>
<v t="karstenw.20230507120753.19"><vh>__init__</vh></v>
<v t="karstenw.20230507120753.20"><vh>count</vh></v>
<v t="karstenw.20230507120753.21"><vh>draw</vh></v>
<v t="karstenw.20230507120753.22"><vh>log_pressed</vh></v>
<v t="karstenw.20230507120753.23"><vh>log_clicked</vh></v>
</v>
<v t="karstenw.20230518121412.1"><vh>newHeadline</vh></v>
<v t="karstenw.20230507120753.24"><vh>draw</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="karstenw.20230319195648.2"></t>
<t tx="karstenw.20230319195720.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20230319195736.1">### GRAPH ############################################################################################

# The NodeBox Graph library includes algorithms from NetworkX for 
# betweenness centrality and eigenvector centrality, Connelly Barnes' implementation of 
# Dijksta shortest paths (here) and the spring layout for JavaScript by Aslak Hellesoy 
# and Dave Hoover (here). The goal of this library is visualization of small graphs (&lt;200 elements), 
# if you need something more robust we recommend using NetworkX.

### CREDITS ##########################################################################################

# Copyright (c) 2008 Tom De Smedt.
# See LICENSE.txt for details.

__author__    = "Tom De Smedt"
__version__   = "1.9.5.6"
__copyright__ = "Copyright (c) 2008 Tom De Smedt"
__license__   = "GPL"

######################################################################################################

import pdb

import linguistics
import pattern
import pattern.text
import pattern.text.en
en = pattern.text.en
wordnet = en.wordnet

from . import cluster
from . import event
from . import layout
from . import proximity
from . import style

</t>
<t tx="karstenw.20230319195736.10">def _y(self): return self.vy * self.graph.d
x = property(_x)
y = property(_y)

</t>
<t tx="karstenw.20230319195736.11">def __contains__(self, pt):
    
    """ True if pt.x, pt.y is inside the node's absolute position.
    """
    
    if abs(self.graph.x+self.x-pt.x) &lt; self.r*2 and \
       abs(self.graph.y+self.y-pt.y) &lt; self.r*2:
        return True
    else:
        return False
    
</t>
<t tx="karstenw.20230319195736.12">def flatten(self, distance=1):
    return cluster.flatten(self, distance)

</t>
<t tx="karstenw.20230319195736.13">def __and__(self, node, distance=1):
    return cluster.intersection(
        self.flatten(distance), node.flatten(distance))

</t>
<t tx="karstenw.20230319195736.14">def __or__(self, node, distance=1):
    return cluster.union(
        self.flatten(distance), node.flatten(distance))

</t>
<t tx="karstenw.20230319195736.15">def __sub__(self, node, distance=1):
    return cluster.difference(
        self.flatten(distance), node.flatten(distance))

</t>
<t tx="karstenw.20230319195736.16">def __repr__(self): 
    try: return "&lt;"+str(self.id)+" node&gt;"
    except:
        return "&lt;"+self.id.encode("utf-8")+" node&gt;"

</t>
<t tx="karstenw.20230319195736.17">def __str__(self): 
    try: return str(self.id)
    except:
        return self.id.encode("utf-8")
        
</t>
<t tx="karstenw.20230319195736.18">def __eq__(self, node):
    if not isinstance(node, self.__class__): return False
    return self.id == node.id

</t>
<t tx="karstenw.20230319195736.19">def __le__(self, node):
    if not isinstance(node, self.__class__): return False
    return self.id &lt; node.id

</t>
<t tx="karstenw.20230319195736.2">#### GRAPH NODE ######################################################################################

class node:
    
    @others
</t>
<t tx="karstenw.20230319195736.20">#### GRAPH NODE LINKS ################################################################################

class links(list):
    
    """ A list in which each node has an associated edge.
    The edge() method returns the edge for a given node id.
    """
    
    @others
</t>
<t tx="karstenw.20230319195736.21">def __init__(self): 
    self._edges = dict()

</t>
<t tx="karstenw.20230319195736.22">def append(self, node, edge=None): 
    if edge:
        self._edges[node.id] = edge
    list.append(self, node)

</t>
<t tx="karstenw.20230319195736.23">def remove(self, node):
    if node.id in self._edges:
        del self._edges[node.id]
    list.remove(self, node)

</t>
<t tx="karstenw.20230319195736.24">def edge(self, id): 
    if isinstance(id, node):
        id = id.id
    return self._edges[id]

</t>
<t tx="karstenw.20230319195736.25">##### GRAPH EDGE #####################################################################################

class edge(object):
    
    @others
</t>
<t tx="karstenw.20230319195736.26">def __init__(self, node1, node2, weight=0.0, length=1.0, label="", properties={}):

    self.node1  = node1
    self.node2  = node2
    self.weight = weight
    self.length = length
    self.label  = label
    
    for k, v in properties.items():
        if not k in self.__dict__:
            self.__dict__[k] = v

</t>
<t tx="karstenw.20230319195736.27">def _get_length(self): 
    return self._length
</t>
<t tx="karstenw.20230319195736.28">def _set_length(self, v): 
    self._length = max(0.1, v)
length = property(_get_length, _set_length)

</t>
<t tx="karstenw.20230319195736.29">#### GRAPH ###########################################################################################

LAYOUT_CIRCLE = "circle"
LAYOUT_SPRING = "spring"
layout_ = layout # there's also a "layout" parameter in graph.__init__()

class graph(dict):
    
    @others
</t>
<t tx="karstenw.20230319195736.3">def __init__(self, graph, id="", radius=8, style=style.DEFAULT, category="", label=None,
             properties={}):
    
    """ A node with a unique id in the graph.
    Its position is calculated by graph.layout.
    The node's radius and style define how it looks onscreen.
    """

    self.graph = graph
    self.id = id
    self.category = category
    self.label = label or self.id
    self.links = links()
    self.vx = 0
    self.vy = 0
    self.force = layout.Point(0, 0)
    self.r = radius
    self.style = style
    
    self._visited = False
    
    self._betweenness = None
    self._eigenvalue = None
    
    for k, v in properties.items():
        if not k in self.__dict__:
            self.__dict__[k] = v

</t>
<t tx="karstenw.20230319195736.30">def __init__(self, iterations=1000, distance=1.0, layout=LAYOUT_SPRING):
    
    self.nodes = []
    self.edges = []
    self.root  = None
    
    # Calculates positions for nodes.
    self.layout = layout_.__dict__[layout+"_layout"](self, iterations)
    self.d = node(None).r * 2.5 * distance
    
    # Hover, click and drag event handler.
    self.events = event.events(self, _ctx)
    
    # Enhanced dictionary of all styles.
    self.styles = style.styles(self)
    self.styles.append(style.style(style.DEFAULT, _ctx))
    self.alpha = 0

</t>
<t tx="karstenw.20230319195736.31">def _get_distance(self):
    return self.d / (node(None).r * 2.5)

</t>
<t tx="karstenw.20230319195736.32">def _set_distance(self, value):
    self.d = node(None).r * 2.5 * value

distance = property(_get_distance, _set_distance)


</t>
<t tx="karstenw.20230319195736.33">def copy(self, empty=False):
    
    """ Create a copy of the graph (by default with nodes and edges).
    """
    
    g = graph(self.layout.n, self.distance, self.layout.type)
    g.layout = self.layout.copy(g)
    g.styles = self.styles.copy(g)
    g.events = self.events.copy(g)

    if not empty:
        for n in self.nodes:
            g.add_node(n.id, n.r, n.style, n.category, n.label, (n == self.root), n.__dict__)
        for e in self.edges:
            g.add_edge(e.node1.id, e.node2.id, e.weight, e.length, e.label, e.__dict__)
    
    return g

</t>
<t tx="karstenw.20230319195736.34">def clear(self):
    
    """ Remove nodes and edges and reset the layout.
    """
    
    dict.clear(self)
    self.nodes = []
    self.edges = []
    self.root  = None
    
    self.layout.i = 0
    self.alpha = 0

</t>
<t tx="karstenw.20230319195736.35">def new_node(self, *args, **kwargs):
    """ Returns a node object; can be overloaded when the node class is subclassed.
    """
    return node(*args, **kwargs)

</t>
<t tx="karstenw.20230319195736.36">def new_edge(self, *args, **kwargs):
    """ Returns an edge object; can be overloaded when the edge class is subclassed.
    """
    return edge(*args, **kwargs)

</t>
<t tx="karstenw.20230319195736.37">def add_node(self, id, radius=8, style=style.DEFAULT, category="", label=None, root=False,
             properties={}):
    
    """ Add node from id and return the node object.
    """
    
    if id in self: 
        return self[id]
        
    if not isinstance(style, str) and "name" in style.__dict__:
        style = style.name
    
    n = self.new_node(self, id, radius, style, category, label, properties)
    self[n.id] = n
    self.nodes.append(n)
    if root:
        self.root = n
        
    return n

</t>
<t tx="karstenw.20230319195736.38">def add_nodes(self, nodes):
    """ Add nodes from a list of id's.
    """
    try:
        [self.add_node(n) for n in nodes]
    except:
        pass

</t>
<t tx="karstenw.20230319195736.39">def add_edge(self, id1, id2, weight=0.0, length=1.0, label="", properties={}):
    
    """ Add weighted (0.0-1.0) edge between nodes, creating them if necessary.
    The weight represents the importance of the connection (not the cost).
    """
    
    if id1 == id2: return None
    
    if not id1 in self:
        self.add_node(id1)
    if not id2 in self:
        self.add_node(id2)
    n1 = self[id1]
    n2 = self[id2]
    
    # If a-&gt;b already exists, don't re-create it.
    # However, b-&gt;a may still pass.
    if n1 in n2.links:
        if n2.links.edge(n1).node1 == n1:
            return self.edge(id1, id2)

    weight = max(0.0, min(weight, 1.0))

    e = self.new_edge(n1, n2, weight, length, label, properties)
    self.edges.append(e)    
    n1.links.append(n2, e)
    n2.links.append(n1, e)

    return e
    
</t>
<t tx="karstenw.20230319195736.4">def _edges(self):
    return self.links._edges.values()

edges = property(_edges)

</t>
<t tx="karstenw.20230319195736.40">def remove_node(self, id):
    
    """ Remove node with given id.
    """
 
    if id in self:
        n = self[id]
        self.nodes.remove(n)
        del self[id]
        
        # Remove all edges involving id and all links to it.
        for e in list(self.edges):
            if n in (e.node1, e.node2):
                if n in e.node1.links: 
                    e.node1.links.remove(n)
                if n in e.node2.links: 
                    e.node2.links.remove(n)
                self.edges.remove(e)

</t>
<t tx="karstenw.20230319195736.41">def remove_edge(self, id1, id2):
    
    """ Remove edges between nodes with given id's.
    """
    
    for e in list(self.edges):
        if id1 in (e.node1.id, e.node2.id) and \
           id2 in (e.node1.id, e.node2.id):
            e.node1.links.remove(e.node2)
            e.node2.links.remove(e.node1)
            self.edges.remove(e)            

</t>
<t tx="karstenw.20230319195736.42">def node(self, id):
    """ Returns the node in the graph associated with the given id.
    """
    if id in self:
        return self[id]
    return None

</t>
<t tx="karstenw.20230319195736.43">def edge(self, id1, id2):
    """ Returns the edge between the nodes with given id1 and id2.
    """
    if (        id1 in self
            and id2 in self
            and self[id2] in self[id1].links):
        return self[id1].links.edge(id2)
    return None

</t>
<t tx="karstenw.20230319195736.44">def __getattr__(self, a):
    
    """ Returns the node in the graph associated with the given id.
    """
    if a in self:
        return self[a]
    raise AttributeError( "graph object has no attribute '"+str(a)+"'" )

</t>
<t tx="karstenw.20230319195736.45">def update(self, iterations=10):
    
    """ Iterates the graph layout and updates node positions.
    """    

    # The graph fades in when initially constructed.
    self.alpha += 0.05
    self.alpha = min(self.alpha, 1.0)

    # Iterates over the graph's layout.
    # Each step the graph's bounds are recalculated
    # and a number of iterations are processed,
    # more and more as the layout progresses.
    if self.layout.i == 0:
        self.layout.prepare()
        self.layout.i += 1
    elif self.layout.i == 1:
        self.layout.iterate()
    elif self.layout.i &lt; self.layout.n:
        n = min(iterations, self.layout.i // 10 + 1)
        for i in range(n): 
            self.layout.iterate()
    
    # Calculate the absolute center of the graph.
    min_, max = self.layout.bounds
    self.x = _ctx.WIDTH - max.x*self.d - min_.x*self.d
    self.y = _ctx.HEIGHT - max.y*self.d - min_.y*self.d
    self.x = self.x // 2
    self.y = self.y // 2

    return not self.layout.done
    
</t>
<t tx="karstenw.20230319195736.46">def solve(self):
    """ Iterates the graph layout until done.
    """
    self.layout.solve()
    self.alpha = 1.0
    
</t>
<t tx="karstenw.20230319195736.47">def _done(self):
    return self.layout.done
    
done = property(_done)

</t>
<t tx="karstenw.20230319195736.48">def offset(self, node):
    """ Returns the distance from the center to the given node.
    """
    x = self.x + node.x - _ctx.WIDTH // 2
    y = self.y + node.y - _ctx.HEIGHT // 2
    return x, y

</t>
<t tx="karstenw.20230319195736.49">def draw(self, dx=0, dy=0, weighted=False, directed=False, highlight=[], traffic=None):
    
    """ Layout the graph incrementally.
    
    The graph is drawn at the center of the canvas.
    The weighted and directed parameters visualize edge weight and direction.
    The highlight specifies list of connected nodes. 
    The path will be colored according to the "highlight" style.
    Clicking and dragging events are monitored.
    
    """
    
    self.update()

    # Draw the graph background.
    s = self.styles.default
    s.graph_background(s)

    # Center the graph on the canvas.
    _ctx.push()
    _ctx.translate(self.x+dx, self.y+dy)
 
    # Indicate betweenness centrality.
    if traffic:
        if isinstance(traffic, bool): 
            traffic = 5
        for n in self.nodes_by_betweenness()[:traffic]:
            try:
                s = self.styles[n.style]
            except:
                s = self.styles.default
            if s.graph_traffic:
                s.graph_traffic(s, n, self.alpha)        

    # Draw the edges and their labels.
    s = self.styles.default
    if s.edges:
        s.edges(s, self.edges, self.alpha, weighted, directed)
    
    # Draw each node in the graph.
    # Apply individual style to each node (or default).        
    for n in self.nodes:
        try:
            s = self.styles[n.style]
        except:
            s = self.styles.default
        if s.node:
            s.node(s, n, self.alpha)
    
    # Highlight the given shortest path.
    try:
        s = self.styles.highlight
    except:
        s = self.styles.default
    if s.path:
        s.path(s, self, highlight)

    # Draw node id's as labels on each node.
    for n in self.nodes:
        try:
            s = self.styles[n.style]
        except:
            s = self.styles.default
        if s.node_label:
            s.node_label(s, n, self.alpha)
    
    # Events for clicked and dragged nodes.
    # Nodes will resist being dragged by attraction and repulsion,
    # put the event listener on top to get more direct feedback.
    self.events.update()
    
    _ctx.pop()

</t>
<t tx="karstenw.20230319195736.5">def _is_leaf(self):
    return len(self.links) == 1

is_leaf = property(_is_leaf)

</t>
<t tx="karstenw.20230319195736.50">def prune(self, depth=0):
    """ Removes all nodes with less or equal links than depth.
    """
    for n in list(self.nodes):
        if len(n.links) &lt;= depth:
            self.remove_node(n.id)
            
trim = prune

</t>
<t tx="karstenw.20230319195736.51">def shortest_path(self, id1, id2, heuristic=None, directed=False):
    """ Returns a list of node id's connecting the two nodes.
    """
    try:
        return proximity.dijkstra_shortest_path(self, id1, id2, heuristic, directed)
    except:
        return None
        
</t>
<t tx="karstenw.20230319195736.52">def betweenness_centrality(self, normalized=True, directed=False):
    """ Calculates betweenness centrality and returns an node id -&gt; weight dictionary.
    Node betweenness weights are updated in the process.
    """
    bc = proximity.brandes_betweenness_centrality(self, normalized, directed)
    for id, w in bc.items():
        self[id]._betweenness = w
    return bc
    
</t>
<t tx="karstenw.20230319195736.53">def eigenvector_centrality(self, normalized=True, reversed=True, rating={},
                           start=None, iterations=100, tolerance=0.0001):
    """ Calculates eigenvector centrality and returns an node id -&gt; weight dictionary.
    Node eigenvalue weights are updated in the process.
    """
    ec = proximity.eigenvector_centrality(
        self, normalized, reversed, rating, start, iterations, tolerance
    )
    for id, w in ec.items():
        self[id]._eigenvalue = w
    return ec

</t>
<t tx="karstenw.20230319195736.54">def nodes_by_betweenness(self, treshold=0.0):
    """ Returns nodes sorted by betweenness centrality.
    Nodes with a lot of passing traffic will be at the front of the list.
    """
    nodes = [(n.betweenness, n) for n in self.nodes if n.betweenness &gt; treshold]
    # nodes.sort()
    sortlist(nodes, sortnodes_zero)
    nodes.reverse()
    return [n for w, n in nodes]
    
nodes_by_traffic = nodes_by_betweenness

</t>
<t tx="karstenw.20230319195736.55">def nodes_by_eigenvalue(self, treshold=0.0):
    """ Returns nodes sorted by eigenvector centrality.
    Nodes with a lot of incoming traffic will be at the front of the list
    """
    nodes = [(n.eigenvalue, n) for n in self.nodes if n.eigenvalue &gt; treshold]
    # nodes.sort()
    sortlist(nodes, sortnodes_zero)
    nodes.reverse()
    return [n for w, n in nodes]
    
nodes_by_weight = nodes_by_eigenvalue

</t>
<t tx="karstenw.20230319195736.56">def nodes_by_category(self, category):
    """ Returns nodes with the given category attribute.
    """
    return [n for n in self.nodes if n.category == category]

</t>
<t tx="karstenw.20230319195736.57">def _leaves(self):
    """ Returns a list of nodes that have only one connection.
    """
    return [node for node in self.nodes if node.is_leaf]
    
leaves = property(_leaves)

</t>
<t tx="karstenw.20230319195736.58">def crown(self, depth=2):
    """ Returns a list of leaves, nodes connected to leaves, etc.
    """
    nodes = []
    for node in self.leaves:
        nodes += node.flatten(depth-1)
    return cluster.unique(nodes)
    
fringe = crown

</t>
<t tx="karstenw.20230319195736.59">def _density(self):
    """ The number of edges in relation to the total number of possible edges.
    """
    return 2.0 * len(self.edges) / (len(self.nodes) * (len(self.nodes)-1))

density = property(_density)

</t>
<t tx="karstenw.20230319195736.6">def can_reach(self, node, traversable=lambda node, edge: True):
    
    """ Returns True if given node can be reached over traversable edges.
    To enforce edge direction, use a node==edge.node1 traversable.
    """
    
    if isinstance(node, str):
        node = self.graph[node]
    for n in self.graph.nodes:
        n._visited = False
    return proximity.depth_first_search(self,
        visit=lambda n: node == n,
        traversable=traversable
        )

</t>
<t tx="karstenw.20230319195736.60">def _is_complete(self) : return self.density == 1.0    
def _is_dense(self)    : return self.density &gt; 0.65
def _is_sparse(self)   : return self.density &lt; 0.35

is_complete = property(_is_complete)
is_dense    = property(_is_dense)
is_sparse   = property(_is_sparse)

</t>
<t tx="karstenw.20230319195736.63">def sub(self, id, distance=1):
    return cluster.subgraph(self, id, distance)
    
subgraph = sub
    
</t>
<t tx="karstenw.20230319195736.64">def __and__(self, graph):
    nodes = cluster.intersection(cluster.flatten(self), cluster.flatten(graph))
    all = self | graph
    return cluster.subgraph(all, nodes, 0)

intersect = __and__

</t>
<t tx="karstenw.20230319195736.65">def __or__(self, graph):
    g = self.copy()
    for n in graph.nodes:
        root = (g.root==None and graph.root==n)
        g.add_node(n.id, n.r, n.style, n.category, n.label, root, n.__dict__)
    for e in graph.edges:
        g.add_edge(e.node1.id, e.node2.id, e.weight, e.length, e.label, e.__dict__)
    return g

join = __or__

</t>
<t tx="karstenw.20230319195736.66">def __sub__(self, graph):
    nodes = cluster.difference(cluster.flatten(self), cluster.flatten(graph))
    all = self | graph
    return cluster.subgraph(all, nodes, 0)

subtract = __sub__

</t>
<t tx="karstenw.20230319195736.67">def _is_clique(self):
    return cluster.is_clique(self)
is_clique = property(_is_clique)

</t>
<t tx="karstenw.20230319195736.68">def clique(self, id, distance=0):
    return cluster.subgraph(self, cluster.clique(self, id), distance)

</t>
<t tx="karstenw.20230319195736.69">def cliques(self, threshold=3, distance=0):
    g = []
    c = cluster.cliques(self, threshold)
    for nodes in c: g.append(cluster.subgraph(self, nodes, distance))
    return g
    
</t>
<t tx="karstenw.20230319195736.7">def _get_betweenness(self):
    if self._betweenness == None:
        self.graph.betweenness_centrality()
    return self._betweenness
    
betweenness = property(_get_betweenness)
traffic = betweenness

</t>
<t tx="karstenw.20230319195736.70">def split(self):
    return cluster.partition(self)

</t>
<t tx="karstenw.20230319195736.71">### DYNAMIC GRAPH ####################################################################################

class xgraph(graph):
    
    """ A dynamic graph where a clicked node loads new data.
    
    Nodes are clickable and will load a new graph based on
    the following methods (that need to be subclassed or monkey patched):
    1) has_node(id): returns True when the id is a node in the dataset.
    2) get_links(id): a list of (weight, id) tuples directly connected to the node
    3) get_cluster(id): a list of (weight, id, [links]) tuples of node id's that are
       connected to the given node via the node id's in the links list (distance 2).   

    The idea is that you have a dataset stored in files or a database,
    and use the dynamic graph's method to describe how the data is read
    and interlinked. The graph is then automatically kept up to date
    as you browse through the connected nodes.
    
    """
    
    @others
</t>
<t tx="karstenw.20230319195736.72">def __init__(self, iterations=500, distance=1.0, layout=LAYOUT_SPRING):
    
    graph.__init__(self, iterations, distance, layout)
    self.styles = create().styles
    self.events.click = self.click
    self.max = 20
    
    self._dx = 0
    self._dy = 0

</t>
<t tx="karstenw.20230319195736.73">def has_node(self, id):
    return True

</t>
<t tx="karstenw.20230319195736.74">def get_links(self, id):    
    return []
    
</t>
<t tx="karstenw.20230319195736.75">def get_cluster(self, id):
    return []

</t>
<t tx="karstenw.20230319195736.76">def load(self, id):
    
    """ Rebuilds the graph around the given node id.
    """
    
    self.clear()

    # Root node.
    self.add_node(id, root=True)

    # Directly connected nodes have priority.
    for w, id2 in self.get_links(id):
        self.add_edge(id, id2, weight=w)
        if len(self) &gt; self.max: 
            break

    # Now get all the other nodes in the cluster.
    for w, id2, links in self.get_cluster(id):
        for id3 in links:
            self.add_edge(id3, id2, weight=w)
            self.add_edge(id, id3, weight=w)
        #if len(links) == 0:
        #    self.add_edge(id, id2)
        if len(self) &gt; self.max: 
            break    

    # Provide a backlink to the previous root.
    if self.event.clicked: 
        g.add_node(self.event.clicked)
    
</t>
<t tx="karstenw.20230319195736.77">def click(self, node):
    
    """ Callback from graph.events when a node is clicked.
    """
    
    if not self.has_node(node.id): return
    if node == self.root: return
    
    self._dx, self._dy = self.offset(node)
    self.previous = self.root.id
    self.load(node.id)  
        
</t>
<t tx="karstenw.20230319195736.78">def draw(self, weighted=False, directed=False, highlight=[], traffic=None):
    
    # A new graph unfolds from the position of the clicked node.
    graph.draw(self, self._dx, self._dy, 
        weighted, directed, highlight, traffic
    )
    self._dx *= 0.9
    self._dy *= 0.9

</t>
<t tx="karstenw.20230319195736.79">#### COMMANDS ########################################################################################

def create(iterations=1000, distance=1.0, layout=LAYOUT_SPRING, depth=True):
    
    """ Returns a new graph with predefined styling.
    """

    global _ctx
    try:
        from nodebox.graphics import RGB
        _ctx.colormode(RGB)
        g = graph(iterations, distance, layout)
    except:
        _ctx = None
        g = graph(iterations, distance, layout)
        return g
    
    # Styles for different types of nodes.
    s = style.style
    g.styles.append(s(style.LIGHT    , _ctx, fill   = _ctx.color(0.0, 0.0, 0.0, 0.20)))
    g.styles.append(s(style.DARK     , _ctx, fill   = _ctx.color(0.3, 0.5, 0.7, 0.75)))
    g.styles.append(s(style.BACK     , _ctx, fill   = _ctx.color(0.5, 0.8, 0.0, 0.50)))
    g.styles.append(s(style.IMPORTANT, _ctx, fill   = _ctx.color(0.3, 0.6, 0.8, 0.75)))
    g.styles.append(s(style.HIGHLIGHT, _ctx, stroke = _ctx.color(1.0, 0.0, 0.5), strokewidth=1.5))
    g.styles.append(s(style.MARKED   , _ctx))
    g.styles.append(s(style.ROOT     , _ctx, text   = _ctx.color(1.0, 0.0, 0.4, 1.00), 
                                             stroke = _ctx.color(0.8, 0.8, 0.8, 0.60),
                                             strokewidth = 1.5, 
                                             fontsize    = 16, 
                                             textwidth   = 150))

    # Important nodes get a double stroke.
    def important_node(s, node, alpha=1.0):
        style.style(None, _ctx).node(s, node, alpha)
        r = node.r * 1.4
        _ctx.nofill()
        _ctx.oval(node.x-r, node.y-r, r*2, r*2)  

    # Marked nodes have an inner dot.
    def marked_node(s, node, alpha=1.0):
        style.style(None, _ctx).node(s, node, alpha)
        r = node.r * 0.3
        _ctx.fill(s.stroke)
        _ctx.oval(node.x-r, node.y-r, r*2, r*2)
    
    g.styles.important.node = important_node
    g.styles.marked.node = marked_node 
    
    g.styles.depth = depth

    # Styling guidelines. All nodes have the default style, except:
    # 1) a node directly connected to the root gets the LIGHT style.
    # 2) a node with more than 4 edges gets the DARK style.
    # 3) a node with a weight of 0.75-1.0 gets the IMPORTANT style.
    # 4) the graph.root node gets the ROOT style.
    # 5) the node last clicked gets the BACK style.    
    g.styles.guide.append(style.LIGHT     , lambda graph, node: graph.root in node.links)
    g.styles.guide.append(style.DARK      , lambda graph, node: len(node.links) &gt; 4)
    g.styles.guide.append(style.IMPORTANT , lambda graph, node: node.weight &gt; 0.75)
    g.styles.guide.append(style.ROOT      , lambda graph, node: node == graph.root)
    g.styles.guide.append(style.BACK      , lambda graph, node: node == graph.events.clicked)
    
    # An additional rule applies every node's weight to its radius.
    def balance(graph, node): 
        node.r = node.r*0.75 + node.r*node.weight*0.75
    g.styles.guide.append("balance", balance)
    
    # An additional rule that keeps leaf nodes closely clustered.
    def cluster(graph, node):
        if len(node.links) == 1: 
            node.links.edge(node.links[0]).length *= 0.5
    g.styles.guide.append("cluster", cluster)
    
    g.styles.guide.order = [
        style.LIGHT, style.DARK, style.IMPORTANT, style.ROOT, style.BACK, "balance", "nurse"
    ]

    return g

# 1.9.5.6
# Fixed circle_layout copy (number of orbits and starting angle weren't copied).

# 1.9.5.5
# graph.add_node and graph.add_edge call graph.new_node and graph.new_edge respectively.
# This should make subclassing nodes and edges a little easier.

# 1.9.5.4
# Fixex bug in spring_layout.tweak().
# Added directed=False parameter to dijkstra_shortest_path() and brandes_betweenness_centrality().

# 1.9.5.3
# Copies of nodes and edges correctly copy arbitrary attributes,
# e.g. edge.context, edge.relation and edge.author in a Perception graph.

# 1.9.5.2
# Reverted to old cluster.unique() (less fast but retains sort order).

# 1.9.5.1
# graph.draw() in push/pop.
# graph.node_id works like graph.node(id).
# Added graph.leaves property.
# Added graph.fringe() method.
# Added node.is_leaf property.
# Added node.can_reach().
# Added proximity.depth_first_search().
# graph.style.align supports RIGHT and CENTER.
# graph.layout.refresh() False rekindles the animation.
# import graph works outside NodeBox.

# 1.9.5
# Changed property names in spring_layout class.
# Added orbit property to circle_layout.
# Added force and repulsion properties to spring_layout.
# Increased default repulsion radius from 7 to 15.
# Added nurse behavior to the styleguide (edge length for leaves is 0.5).

# 1.9.4
# Edges now have a length property that controls individual attraction.

# 1.9.2.1
# proximity.eigenvector_centrality() yields warning 
# instead of exception if it does not converge.
# Added heuristic parameter to proximity.dijkstra_shortest_path().
# Added layout.spring_layout.tweak()
# Added cluster.partition()
</t>
<t tx="karstenw.20230319195736.8">def _get_eigenvalue(self):
    if self._eigenvalue == None:
        self.graph.eigenvector_centrality()
    return self._eigenvalue
    
eigenvalue = property(_get_eigenvalue)
weight = eigenvalue

</t>
<t tx="karstenw.20230319195736.9">def _x(self): return self.vx * self.graph.d
</t>
<t tx="karstenw.20230319202717.1"></t>
<t tx="karstenw.20230319202717.2"># py3 stuff
py3 = False
try:
    unicode('')
    punicode = unicode
    pstr = str
    punichr = unichr
except NameError:
    punicode = str
    pstr = bytes
    py3 = True
    punichr = chr
    long = int


</t>
<t tx="karstenw.20230319202717.3">def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K:
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) &lt; 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) &gt; 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) &lt;= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) &gt;= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return K


</t>
<t tx="karstenw.20230319202717.4">def sortlist(thelist, thecompare):
    if py3:
        sortkeyfunction = cmp_to_key( thecompare )
        thelist.sort( key=sortkeyfunction )
    else:
        thelist.sort( thecompare )


</t>
<t tx="karstenw.20230319203345.1">def sortnodes_zero( a, b ):
    if a[0] &gt; b[0]:
        return 1
    elif a[0] &lt; b[0]:
        return -1
    return 0

</t>
<t tx="karstenw.20230320154844.1">class FlowerWord:
    @others


</t>
<t tx="karstenw.20230320154844.2">def __init__(self, word):
    # pdb.set_trace()
    self.word = word
    self.synsets = wordnet.synsets( word )
    self.idx = 0
    self.antonym = ""
    self.gloss = ""
    self.synset = None
    self.synonyms = []
    self.antonym = ""
    self.gloss = ""
    self.lexname = ""

    if len(self.synsets) &gt; 0:
        synonyms = self.synsets[0].synonyms
        try:
            self.idx = synonyms.index(word)
            w = self.synset = self.synsets[self.idx]
            #print("Found synset:", w)
        except:
            w = self.synsets[0]
            #print("Use synset:", w)

        self.antonym = w.antonym
        self.gloss = w.gloss
        self.lexname = w.lexname

</t>
<t tx="karstenw.20230320154844.3">def hyponyms(self):
    result = []
    for synset in self.synsets:
        hyponyms = synset.hyponyms()
        for hyponym in hyponyms:
            synonyms = hyponym.synonyms
            for synonym in synonyms:
                synonym = synonym.replace("_", " ")
                result.append( synonym )
    result = list(set(result))
    return result

</t>
<t tx="karstenw.20230320154844.4">def hypernyms(self):
    result = []
    for synset in self.synsets:
        hypernyms = synset.hypernyms()
        for hypernym in hypernyms:
            synonyms = hypernym.synonyms
            for synonym in synonyms:
                synonym = synonym.replace("_", " ")
                result.append( synonym )
    result = list(set(result))
    return result


</t>
<t tx="karstenw.20230320154844.5">def senses(self):
    result = []
    for synset in self.synsets:
        senses = synset.senses
        result.append( senses )
    return result


</t>
<t tx="karstenw.20230321100722.1">def holonyms(self):
    result = []
    for synset in self.synsets:
        holonyms = synset.holonyms()
        for holonym in holonyms:
            synonyms = hyponym.synonyms
            for synonym in synonyms:
                synonym = synonym.replace("_", " ")
                result.append( synonym )
    result = list(set(result))
    return result

</t>
<t tx="karstenw.20230321101136.1">def meronyms(self):
    result = []
    for synset in self.synsets:
        meronyms = synset.meronyms()
        for meronym in meronyms:
            synonyms = hyponym.synonyms
            for synonym in synonyms:
                synonym = synonym.replace("_", " ")
                result.append( synonym )
    result = list(set(result))
    return result

</t>
<t tx="karstenw.20230329160917.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20230329160929.1"># Copyright (c) 2007 Tom De Smedt.
# See LICENSE.txt for details.

from types import FunctionType, LambdaType

</t>
<t tx="karstenw.20230329160929.10">def clique(graph, id):
    
    """ Returns the largest possible clique for the node with given id.
    """
    
    clique = [id]
    for n in graph.nodes:
        friend = True
        for id in clique:
            if n.id == id or graph.edge(n.id, id) == None:
                friend = False
                break
        if friend:
            clique.append(n.id)
    
    return clique
    
</t>
<t tx="karstenw.20230329160929.11">def cliques(graph, threshold=3):
    
    """ Returns all the cliques in the graph of at least the given size.
    """
    
    cliques = []
    for n in graph.nodes:
        c = clique(graph, n.id)
        if len(c) &gt;= threshold: 
            c.sort()
            if c not in cliques:
                cliques.append(c)
    
    return cliques

</t>
<t tx="karstenw.20230329160929.12">#--- UNCONNECTED SUBGRAPHS -------------------------------------------------------------------------

def partition(graph):
    
    """ Splits unconnected subgraphs.
    
    For each node in the graph, make a list of its id and all directly connected id's.
    If one of the nodes in this list intersects with a subgraph,
    they are all part of that subgraph.
    Otherwise, this list is part of a new subgraph.
    Return a list of subgraphs sorted by size (biggest-first).
    
    """
    
    g = []
    for n in graph.nodes:
        c = [n.id for n in flatten(n)]
        f = False
        for i in range(len(g)):
            if len(intersection(g[i], c)) &gt; 0:
                g[i] = union(g[i], c)
                f = True
                break
        if not f:
            g.append(c)
    
    # If 1 is directly connected to 2 and 3,
    # and 4 is directly connected to 5 and 6, these are separate subgraphs.
    # If we later find that 7 is directly connected to 3 and 6,
    # it will be attached to [1, 2, 3] yielding
    # [1, 2, 3, 6, 7] and [4, 5, 6].
    # These two subgraphs are connected and need to be merged.
    merged = []
    for i in range(len(g)):
        merged.append(g[i])
        for j in range(i+1, len(g)):
            if len(intersection(g[i], g[j])) &gt; 0:
                merged[-1].extend(g[j])
                g[j] = []
    
    g = merged
    g = [graph.sub(g, distance=0) for g in g]
    g.sort(lambda a, b: len(b) - len(a))
    
    return g

</t>
<t tx="karstenw.20230329160929.2">def sorted(thelist, cmp=None, reversed=False):
    """ Returns a sorted copy of the list.
    """
    thelist = [x for x in thelist]
    # thelist.sort(cmp)
    sortlist(thelist, cmp)
    if reversed:
        thelist.reverse()
    return thelist


</t>
<t tx="karstenw.20230329160929.3">def unique( thelist ):
    """ Returns a copy of the list without duplicates.
    """
    unique = []
    [unique.append(x) for x in thelist if x not in unique]
    return unique


</t>
<t tx="karstenw.20230329160929.4">def flatten(node, distance=1):
    
    """ Recursively lists the node and its links.
    
    Distance of 0 will return the given [node].
    Distance of 1 will return a list of the node and all its links.
    Distance of 2 will also include the linked nodes' links, etc.
    
    """
    
    # When you pass a graph it returns all the node id's in it.
    if hasattr(node, "nodes") and hasattr(node, "edges"):
        return [n.id for n in node.nodes]
    
    all = [node]
    if distance &gt;= 1:
        for n in node.links: 
            all += n.flatten(distance-1)
    
    return unique(all)
    
</t>
<t tx="karstenw.20230329160929.5">def intersection(a, b):
    """ Returns the intersection of lists.
    a &amp; b -&gt; elements that appear in a as well as in b.
    """
    return filter(lambda x: x in a, b)
    
    
</t>
<t tx="karstenw.20230329160929.6">def union(a, b):
    """ Returns the union of lists.
    a | b -&gt; all elements from a and all the elements from b.
    """     
    return a + filter(lambda x: x not in a, b)

</t>
<t tx="karstenw.20230329160929.7">def difference(a, b):
    """ Returns the difference of lists.
    a - b -&gt; elements that appear in a but not in b.
    """
    return filter(lambda x: x not in b, a)
    
</t>
<t tx="karstenw.20230329160929.8">#--- SUBGRAPH ----------------------------------------------------------------------------------------

def subgraph(graph, id, distance=1):
    
    """ Creates the subgraph of the flattened node with given id (or list of id's).
    Finds all the edges between the nodes that make up the subgraph.
    """
    
    g = graph.copy(empty=True)
    
    if isinstance(id, (FunctionType, LambdaType)):
        # id can also be a lambda or function that returns True or False
        # for each node in the graph. We take the id's of nodes that pass.
        id = [node.id for node in filter(id, graph.nodes)]
    if not isinstance(id, (list, tuple)):
        id = [id]
    for id in id:
        for n in flatten(graph[id], distance):
            g.add_node(n.id, n.r, n.style, n.category, n.label, (n==graph.root), n.__dict__)
        
    for e in graph.edges:
        if (    e.node1.id in g
            and e.node2.id in g ):
            g.add_edge(e.node1.id, e.node2.id, e.weight,
                       e.length, e.label, e.__dict__)
    
    # Should we look for shortest paths between nodes here?
    
    return g
 
</t>
<t tx="karstenw.20230329160929.9">def is_clique(graph):
    
    """ A clique is a set of nodes in which each node is connected to all other nodes.
    """
    
    #for n1 in graph.nodes:
    #    for n2 in graph.nodes:
    #        if n1 != n2 and graph.edge(n1.id, n2.id) == None:
    #            return False

    if graph.density &lt; 1.0: 
        return False
    
    return True
    
</t>
<t tx="karstenw.20230329160948.1">#--- LIST OPERATIONS ---------------------------------------------------------------------------------

</t>
<t tx="karstenw.20230329161013.1">#--- SET THEORY --------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20230329161057.1">#--- CLIQUE ----------------------------------------------------------------------------------------
 
</t>
<t tx="karstenw.20230329161629.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20230329161638.1"># Copyright (c) 2007 Tom De Smedt.
# See LICENSE.txt for details.

try:
    from en import wordnet
except:
    try:
        import wordnet
    except:
        pass

import linguistics
import pattern
import pattern.text
# import pattern.web
import pattern.text.en
en = pattern.text.en
wordnet = en.wordnet
# web = pattern.web

</t>
<t tx="karstenw.20230329161638.10">def drag(self, node):

    """ Drags given node to mouse location.
    """

    dx = self.mouse.x - self.graph.x
    dy = self.mouse.y - self.graph.y

    # A dashed line indicates the drag vector.
    s = self.graph.styles.default
    self._ctx.nofill()
    self._ctx.nostroke()
    if s.stroke: 
        self._ctx.strokewidth(s.strokewidth)
        self._ctx.stroke(
            s.stroke.r, 
            s.stroke.g, 
            s.stroke.g, 
            0.75
        )
    p = self._ctx.line(node.x, node.y, dx, dy, draw=False)
    try:
        p._nsBezierPath.setLineDash_count_phase_([2,4], 2, 50)
    except:
        pass
    self._ctx.drawpath(p)
    r = node.__class__(None).r * 0.75
    self._ctx.oval(dx-r/2, dy-r/2, r, r)

    node.vx = dx / self.graph.d
    node.vy = dy / self.graph.d
    
</t>
<t tx="karstenw.20230329161638.11">def hover(self, node):
    
    """ Displays a popup when hovering over a node.
    """
    
    if self.popup == False:
        return
    if self.popup == True or self.popup.node != node:
        if node.id in self.popup_text:
            texts = self.popup_text[node.id]
        else:
            texts = None
        self.popup = popup(self._ctx, node, texts)
    self.popup.draw()

</t>
<t tx="karstenw.20230329161638.12">def click(self, node):
    
    pass

</t>
<t tx="karstenw.20230329161638.13">class popup:
    
    """ An information box used when hovering over a node.
    It takes a list of alternating texts to display.
    """
    
    @others
</t>
<t tx="karstenw.20230329161638.14">def __init__(self, _ctx, node, texts=None, width=200, speed=2.0):
    
    if texts != None and not isinstance(texts, (tuple, list)):
        texts = [texts]
    
    self._ctx = _ctx
    self.node = node
    
    self.i = 0 
    self.q = texts

    # When no texts were supplied, fall back to WordNet.
    # If WordNet is loaded, gather gloss descriptions for the node's id.
    if self.q == None:
        self.q = []
        try:
            id = str(self.node.id)
            for i in range(wordnet.count_senses(id)):
                txt  = id + " | " + wordnet.gloss(id, sense=i)
                self.q.append(txt)
        except:
            pass

    # Defaults for colors and typography.
    self.background = self._ctx.color(0.00, 0.10, 0.15, 0.60)
    self.text       = self._ctx.color(1.00, 1.00, 1.00, 0.80)
    self.font       = "Verdana"
    self.fontsize   = 9.5

    # Cached outlined versions of the text.
    self._textpaths = []
    self._w = width
    
    self.speed = speed
    self.delay = 20 / self.speed

    self.fi = 0  # current frame
    self.fn = 0  # frame count
    self.mf = 50 # minimum frame count

</t>
<t tx="karstenw.20230329161638.15">def textpath(self, i):
    
    """ Returns a cached textpath of the given text in queue.
    """
    
    if len(self._textpaths) == i:
        self._ctx.font(self.font, self.fontsize)
        txt = self.q[i]
        if len(self.q) &gt; 1:
            # Indicate current text (e.g. 5/13).
            txt += " ("+str(i+1)+"/" + str(len(self.q))+")"
        p = self._ctx.textpath(txt, 0, 0, width=self._w)
        h = self._ctx.textheight(txt, width=self._w)
        self._textpaths.append((p, h))

    return self._textpaths[i]
    
</t>
<t tx="karstenw.20230329161638.16">def update(self):
    
    """ Rotates the queued texts and determines display time.
    """
    
    if self.delay &gt; 0:
        # It takes a while for the popup to appear.
        self.delay -= 1; return
        
    if self.fi == 0:
        # Only one text in queue, displayed infinitely.
        if len(self.q) == 1: 
            self.fn = float(INFINITY)
        # Else, display time depends on text length.
        else:
            self.fn = len(self.q[self.i]) / self.speed
            self.fn = max(self.fn, self.mf)            
        
    self.fi += 1
    if self.fi &gt; self.fn:
        # Rotate to the next text in queue.
        self.fi = 0
        self.i = (self.i+1) % len(self.q)
    
</t>
<t tx="karstenw.20230329161638.17">def draw(self):
    
    """ Draws a popup rectangle with a rotating text queue.        
    """ 
    
    if len(self.q) &gt; 0:
        self.update()
        
        if self.delay == 0:
            
            # Rounded rectangle in the given background color.
            p, h = self.textpath(self.i)
            f = self.fontsize
            self._ctx.fill(self.background)
            self._ctx.rect(
                self.node.x + f*1.0, 
                self.node.y + f*0.5, 
                self._w + f, 
                h + f*1.5, 
                roundness=0.2
            )
            
            # Fade in/out the current text.
            alpha = 1.0
            if self.fi &lt; 5: 
                alpha = 0.2 * self.fi
            if self.fn-self.fi &lt; 5: 
                alpha = 0.2 * (self.fn-self.fi)
            self._ctx.fill(
                self.text.r,
                self.text.g,
                self.text.b,
                self.text.a * alpha
            )
            
            self._ctx.translate(self.node.x + f*2.0, self.node.y + f*2.5)
            self._ctx.drawpath(p)
</t>
<t tx="karstenw.20230329161638.2">class Point:
    @others
INFINITY = 1e20

</t>
<t tx="karstenw.20230329161638.3">def __init__(self, x, y):
    self.x = x
    self.y = y
    
</t>
<t tx="karstenw.20230329161638.4">class events:
    
    @others
</t>
<t tx="karstenw.20230329161638.5">def __init__(self, graph, _ctx):
    
    self.graph = graph
    self._ctx = _ctx
    
    # Can contain a node:
    self.hovered = None
    self.pressed = None
    self.dragged = None
    self.clicked = None
    
    # Displays when hovering over a node.
    self.popup = False
    self.popup_text = {}

</t>
<t tx="karstenw.20230329161638.6">def copy(self, graph):

    """ Returns a copy of the event handler, remembering the last node clicked.
    """

    e = events(graph, self._ctx)
    e.clicked = self.clicked
    return e

</t>
<t tx="karstenw.20230329161638.7">def _mouse(self):
    
    return Point(
        self._ctx._ns["MOUSEX"], 
        self._ctx._ns["MOUSEY"]
    )
    
mouse = property(_mouse)
 
</t>
<t tx="karstenw.20230329161638.8">def _mousedown(self):
    
    if self._ctx._ns["mousedown"]:
        return True
    else:
        return False

mousedown = property(_mousedown)

</t>
<t tx="karstenw.20230329161638.9">def update(self):

    """ Interacts with the graph by clicking or dragging nodes.
    Hovering a node fires the callback function events.hover().
    Clicking a node fires the callback function events.click().
    """

    if self.mousedown:
    
        # When not pressing or dragging, check each node.
        if not self.pressed and not self.dragged:
            for n in self.graph.nodes:
                if self.mouse in n:
                    self.pressed = n
                    break
                
        # If a node is pressed, check if a drag is started.
        elif self.pressed and not self.mouse in self.pressed:
            self.dragged = self.pressed
            self.pressed = None
        
        # Drag the node (right now only for springgraphs).
        elif self.dragged and self.graph.layout.type == "spring":
            self.drag(self.dragged)
            self.graph.layout.i = min(100, max(2, self.graph.layout.n-100))

    # Mouse is clicked on a node, fire callback.
    elif self.pressed and self.mouse in self.pressed:
        self.clicked = self.pressed
        self.pressed = None
        self.graph.layout.i = 2
        self.click(self.clicked)

    # Mouse up.
    else:
        self.hovered = None
        self.pressed = None
        self.dragged = None
    
        # Hovering over a node?
        for n in self.graph.nodes:
            if self.mouse in n:
                self.hovered = n
                self.hover(n)
                break

</t>
<t tx="karstenw.20230329161815.1">#### GRAPH HOVER/CLICK/DRAG EVENTS ###################################################################

</t>
<t tx="karstenw.20230329161904.1">### POPUP ############################################################################################   

</t>
<t tx="karstenw.20230329162253.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20230329162306.1">from random import random
from math import pi, sin, cos, sqrt

</t>
<t tx="karstenw.20230329162306.10">def iterate(self):
    
    self.i += 1
    return self.done
    
</t>
<t tx="karstenw.20230329162306.11">def solve(self):
    
    while not self.done: 
        self.iterate()
        
</t>
<t tx="karstenw.20230329162306.12">def reset(self):
    
    self.i = 0
    
</t>
<t tx="karstenw.20230329162306.13">def refresh(self):
    
    self.i = self.n / 2

</t>
<t tx="karstenw.20230329162306.14">class circle_layout(layout):
    
    """ Simple layout with nodes arranged on one or more circles.
    """
    
    @others
</t>
<t tx="karstenw.20230329162306.15">def __init__(self, graph, iterations=100):

    layout.__init__(self, graph, iterations)
    self.type = "circle"    
    
    self.r = 8    # outer circle radius
    self.c = 2    # number of circles
    self.a = pi/2 # starting angle

</t>
<t tx="karstenw.20230329162306.16">def _get_orbits(self): return self.c
</t>
<t tx="karstenw.20230329162306.17">def _set_orbits(self, v): self.c = v
orbits = property(_get_orbits, _set_orbits)

</t>
<t tx="karstenw.20230329162306.18">def copy(self, graph):
    
    l = layout.copy(self, graph)
    l.r, l.c, l.a = self.r, self.c, self.a
    return l

</t>
<t tx="karstenw.20230329162306.19">def iterate(self):
    
    if len(self.graph.nodes) == 1: return
    
    # Nodes are sorted by betweenness centrality.
    # Node with a high centrality are on the inner circles.
    # There are logarithmically more nodes on the outer shells.
    circles = []
    nodes = self.graph.nodes_by_traffic(treshold=-1)
    for i in range(self.c):
        t = 1.0 / (self.c-i)**2
        slice = int(t * len(self.graph.nodes))
        slice = max(1, slice)
        circles.append(nodes[:slice])
        nodes = nodes[slice:]

    node_radius = self.graph.nodes[0].__class__(None).r

    i = 0
    for circle in circles:
        i += 1

        # Circle radii expand each iteration.
        # Inner circles have a smaller radius.
        r = self.r * sin(pi/2 * float(self.i) / self.n)
        r *= float(i)/len(circles)
        
        # Calculate circle circumference. 
        # Node diameter / circumference determine how many nodes fit on the shell.
        C = self.r*self.graph.d * 2*pi * float(i)/len(circles)
        s = node_radius*2 / C * 2
        
        a = self.a
        t = min(2*pi*s, 2*pi/len(circle))
        for n in circle:
            n.vx = r * cos(a)
            n.vy = r * sin(a)
            a += t

    #r = self.r * sin(float(self.i) / self.n * pi/2)
    #a = 0
    #i = pi*2 / len(self.graph.nodes)
    #for n in self.graph.nodes:
    #    n.vx = r * cos(a)
    #    n.vy = r * sin(a)
    #    a += i 
        
    layout.iterate(self)
    
</t>
<t tx="karstenw.20230329162306.2">class Point:
    @others
INFINITY = 1e20

</t>
<t tx="karstenw.20230329162306.20">def solve(self):
    
    self.i = self.n
    self.iterate()

</t>
<t tx="karstenw.20230329162306.21">class spring_layout(layout):
    
    """ A force-based layout in which edges are regarded as springs.
    http://snipplr.com/view/1950/graph-javascript-framework-version-001/
    """
    
    @others
</t>
<t tx="karstenw.20230329162306.22">def __init__(self, graph, iterations=1000):
    
    layout.__init__(self, graph, iterations)    
    self.type = "spring"

    self.k = 2    # force strength
    self.m = 0.01 # force multiplier
    self.w = 15   # edge weight multiplier
    self.d = 0.5  # maximum vertex movement
    self.r = 15   # maximum repulsive force radius

</t>
<t tx="karstenw.20230329162306.23">def tweak(self, k=2, m=0.01, w=15, d=0.5, r=15):
    self.k = k
    self.m = m
    self.w = w
    self.d = d
    self.r = r

</t>
<t tx="karstenw.20230329162306.24">def _get_force(self): return self.m
</t>
<t tx="karstenw.20230329162306.25">def _set_force(self, v): self.m = v
force = property(_get_force, _set_force)

</t>
<t tx="karstenw.20230329162306.26">def _get_repulsion(self): return self.r
</t>
<t tx="karstenw.20230329162306.27">def _set_repulsion(self, v): self.r = v
repulsion = property(_get_repulsion, _set_repulsion)

</t>
<t tx="karstenw.20230329162306.28">def copy(self, graph):
    
    l = layout.copy(self, graph)
    l.k, l.m, l.d, l.r = self.k, self.m, self.d, self.r
    return l

</t>
<t tx="karstenw.20230329162306.29">def iterate(self):
    
    # Forces on all nodes due to node-node repulsions.
    for i in range(len(self.graph.nodes)):
        n1 = self.graph.nodes[i]
        for j in range(i+1, len(self.graph.nodes)):
            n2 = self.graph.nodes[j]             
            self._repulse(n1, n2)

    # Forces on nodes due to edge attractions.
    for e in self.graph.edges:
        self._attract(e.node1, e.node2, self.w*e.weight, 1.0/e.length)
        
    # Move by given force.
    for n in self.graph.nodes:
        vx = max(-self.d, min(self.m * n.force.x, self.d))
        vy = max(-self.d, min(self.m * n.force.y, self.d))
        n.vx += vx
        n.vy += vy
        n.force.x = 0
        n.force.y = 0
    
    return layout.iterate(self)

</t>
<t tx="karstenw.20230329162306.3">def __init__(self, x, y):
    self.x = x
    self.y = y
    
</t>
<t tx="karstenw.20230329162306.30">def _distance(self, n1, n2):
    
    dx = n2.vx - n1.vx
    dy = n2.vy - n1.vy
    d2 = dx**2 + dy**2       

    if d2 &lt; 0.01:
        dx = random()*0.1 + 0.1
        dy = random()*0.1 + 0.1
        d2 = dx**2 + dy**2
        
    d = sqrt(d2)
    
    return dx, dy, d

</t>
<t tx="karstenw.20230329162306.31">def _repulse(self, n1, n2):
    
    dx, dy, d = self._distance(n1, n2)
    
    if d &lt; self.r:
        f = self.k**2 / d**2
        n2.force.x += f * dx
        n2.force.y += f * dy
        n1.force.x -= f * dx
        n1.force.y -= f * dy
    
</t>
<t tx="karstenw.20230329162306.32">def _attract(self, n1, n2, k=0, length=1.0):
    
    dx, dy, d = self._distance(n1, n2)
    d = min(d, self.r)
    
    # Take the edge's weight (k) into account.
    f = (d**2 - self.k**2) / self.k * length
    f *= k * 0.5 + 1
    f /= d
    
    n2.force.x -= f * dx
    n2.force.y -= f * dy
    n1.force.x += f * dx
    n1.force.y += f * dy
</t>
<t tx="karstenw.20230329162306.4">class layout(object):
    
    """ Graph visualizer that calculates relative node positions.
    """
    
    @others
</t>
<t tx="karstenw.20230329162306.5">def __init__(self, graph, iterations=1000):
    
    self.type = None
    self.graph = graph
    self.i = 0
    self.n = iterations
    
    self.__bounds = None

</t>
<t tx="karstenw.20230329162306.6">def copy(self, graph):
    
    """ Returns a copy of the layout for the given graph.
    """
    
    l = self.__class__(graph, self.n)
    l.i = 0
    return l

</t>
<t tx="karstenw.20230329162306.7">def prepare(self):
    
    for n in self.graph.nodes:
        n.vx = 0
        n.vy = 0
        n.force = Point(0,0)    

</t>
<t tx="karstenw.20230329162306.8">def _bounds(self):
    
    # min = Point(float( INFINITY), float( INFINITY))
    # max = Point(float(-INFINITY), float(-INFINITY))
    minx, miny = float( INFINITY), float( INFINITY)
    maxx, maxy = float(-INFINITY), float(-INFINITY)
    for n in self.graph.nodes:
        if (n.vx &lt; minx): minx = n.vx
        if (n.vy &lt; miny): miny = n.vy
        if (n.vx &gt; maxx): maxx = n.vx
        if (n.vy &gt; maxy): maxy = n.vy
  
    # return (min, max)
    return Point(minx,miny), Point( maxx, maxy )

bounds = property(_bounds)

</t>
<t tx="karstenw.20230329162306.9">def _get_done(self):
    
    if self.i &gt;= self.n: 
        return True
    return False
    
done = property(_get_done)

</t>
<t tx="karstenw.20230329162353.1">##### GRAPH LAYOUT ###################################################################################

</t>
<t tx="karstenw.20230329162416.1">##### GRAPH CIRCLE LAYOUT ############################################################################

</t>
<t tx="karstenw.20230329162442.1">##### GRAPH SPRING LAYOUT ############################################################################

</t>
<t tx="karstenw.20230329163013.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20230329163023.1">import heapq
from random import random
from warnings import warn

</t>
<t tx="karstenw.20230329163023.2">#--- PRIORITY QUEUE ----------------------------------------------------------------------------------
# Currently not in use.

INFINITY = 1e20

class priorityqueue(dict):
    
    @others
</t>
<t tx="karstenw.20230329163023.3">def push(self, e, w): 
    self[e] = w

</t>
<t tx="karstenw.20230329163023.4">def pop(self):
    p, w = None, float(INFINITY)
    for e in self:
        if self[e] &lt;= w: p, w = e, self[e]
    if p: del self[p]
    return p

</t>
<t tx="karstenw.20230329163023.5">#--- DEPTH-FIRST SEARCH ------------------------------------------------------------------------------

def depth_first_search(root, visit=lambda node: False, traversable=lambda node, edge: True):

    """ Simple, multi-purpose depth-first search.
    
    Visits all the nodes connected to the root, depth-first.
    The visit function is called on each node.
    Recursion will stop if it returns True, and ubsequently dfs() will return True.
    The traversable function takes the current node and edge,
    and returns True if we are allowed to follow this connection to the next node.
    For example, the traversable for directed edges is follows:
    lambda node, edge: node == edge.node1
    
    Note: node._visited is expected to be False for all nodes.
    
    """

    stop = visit(root)
    root._visited = True
    for node in root.links:
        if stop: return True
        if not traversable(root, root.links.edge(node)): continue
        if not node._visited:
            stop = depth_first_search(node, visit, traversable)
    return stop

</t>
<t tx="karstenw.20230329163023.6">#--- ADJACENCY LIST ----------------------------------------------------------------------------------

def adjacency(graph, directed=False, reversed=False, stochastic=False, heuristic=None):
    
    """ An edge weight map indexed by node id's.
    
    A dictionary indexed by node id1's in which each value is a
    dictionary of connected node id2's linking to the edge weight.
    If directed, edges go from id1 to id2, but not the other way.
    If stochastic, all the weights for the neighbors of a given node sum to 1.
    A heuristic can be a function that takes two node id's and returns
    an additional cost for movement between the two nodes.
    
    """
    
    v = {}
    for n in graph.nodes:
        v[n.id] = {}
    
    for e in graph.edges:
        
        id1 = e.node1.id
        id2 = e.node2.id
        if reversed:
            id1, id2 = id2, id1
            
        #if not v.has_key(id1): v[id1] = {}
        #if not v.has_key(id2): v[id2] = {}
        v[id1][id2] = 1.0 - e.weight*0.5
        
        if heuristic:
            v[id1][id2] += heuristic(id1, id2)
        
        if not directed: 
            v[id2][id1] = v[id1][id2]
        
    if stochastic:
        for id1 in v:
            d = sum(v[id1].values())
            for id2 in v[id1]: 
                v[id1][id2] /= d
    
    return v

</t>
<t tx="karstenw.20230329163024.1">#--- DIJKSTRA SHORTEST PATH --------------------------------------------------------------------------

def dijkstra_shortest_path(graph, id1, id2, heuristic=None, directed=False):

    """ Dijkstra algorithm for finding shortest paths.
    
    Connelly Barnes, http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/119466
    Raises an IndexError between nodes on unconnected graphs.
    
    """
    
    G = adjacency(graph, directed=directed, heuristic=heuristic)
    start = id1
    end = id2
    
    # Flatten linked list of form [0,[1,[2,[]]]]
    def flatten(L):       
        while len(L) &gt; 0:
            yield L[0]
            L = L[1]

    q = [(0, start, ())]  # Heap of (cost, path_head, path_rest).
    visited = set()       # Visited vertices.
    while True:
        (cost1, v1, path) = heapq.heappop(q)
        if v1 not in visited:
            visited.add(v1)
        if v1 == end:
            return list(flatten(path))[::-1] + [v1]
        path = (v1, path)
        for (v2, cost2) in G[v1].items():
            if v2 not in visited:
                heapq.heappush(q, (cost1 + cost2, v2, path))

</t>
<t tx="karstenw.20230329163024.2">#--- BRANDES BETWEENNESS CENTRALITY ------------------------------------------------------------------

def brandes_betweenness_centrality(graph, normalized=True, directed=False):

    """ Betweenness centrality for nodes in the graph.
    
    Betweenness centrality is a measure of the number of shortests paths that pass through a node.
    Nodes in high-density areas will get a good score.
    
    The algorithm is Brandes' betweenness centrality,
    from NetworkX 0.35.1: Aric Hagberg, Dan Schult and Pieter Swart,
    based on Dijkstra's algorithm for shortest paths modified from Eppstein.
    https://networkx.lanl.gov/wiki
    
    """

    G = graph.keys()
    W = adjacency(graph, directed=directed)
    
    betweenness = dict.fromkeys(G, 0.0) # b[v]=0 for v in G
    for s in G: 
        S = [] 
        P = {} 
        for v in G: P[v] = [] 
        sigma = dict.fromkeys(G, 0) # sigma[v]=0 for v in G 
        D = {} 
        sigma[s] = 1
        seen = { s: 0 }  
        Q = [] # use Q as heap with (distance, node id) tuples 
        heapq.heappush(Q, (0, s, s)) 
        while Q:    
            (dist, pred, v) = heapq.heappop(Q) 
            if v in D: continue # already searched this node
            sigma[v] = sigma[v] + sigma[pred] # count paths 
            S.append(v) 
            D[v] = seen[v] 
            for w in graph[v].links:
                
                w = w.id
                vw_dist = D[v] + W[v][w]
                
                if w not in D and (w not in seen or vw_dist &lt; seen[w]): 
                    seen[w] = vw_dist 
                    heapq.heappush(Q, (vw_dist, v, w)) 
                    P[w] = [v] 
                elif vw_dist == seen[w]: # handle equal paths 
                    sigma[w] = sigma[w] + sigma[v] 
                    P[w].append(v)
                    
        delta = dict.fromkeys(G,0)  
        while S: 
            w = S.pop() 
            for v in P[w]: 
                delta[v] = delta[v] + (float(sigma[v]) / float(sigma[w])) * (1.0 + delta[w]) 
            if w != s: 
                betweenness[w] = betweenness[w] + delta[w]

        #-----------------------------------
        if normalized:
            # Normalize between 0.0 and 1.0.
            m = max(betweenness.values())
            if m == 0: m = 1
        else:
            m = 1
            
        betweenness = dict([(id, w/m) for id, w in betweenness.items()])
        return betweenness

</t>
<t tx="karstenw.20230329163024.3">class NoConvergenceError(Exception):
    pass

</t>
<t tx="karstenw.20230329163024.4">#--- EIGENVECTOR CENTRALITY --------------------------------------------------------------------------

def eigenvector_centrality(graph, normalized=True, reversed=True, rating={},
                           start=None, iterations=100, tolerance=0.0001):

    """ Eigenvector centrality for nodes in the graph (like Google's PageRank).
    
    Eigenvector centrality is a measure of the importance of a node in a directed network. 
    It rewards nodes with a high potential of (indirectly) connecting to high-scoring nodes.
    Nodes with no incoming connections have a score of zero.
    If you want to measure outgoing connections, reversed should be False.

    The eigenvector calculation is done by the power iteration method.
    It has no guarantee of convergence.
    A starting vector for the power iteration can be given in the start dict.
    
    You can adjust the importance of a node with the rating dictionary,
    which links node id's to a score.
    
    The algorithm is adapted from NetworkX, Aric Hagberg (hagberg@lanl.gov):
    https://networkx.lanl.gov/attachment/ticket/119/eigenvector_centrality.py

    """

    G = graph.keys()     
    W = adjacency (graph, directed=True, reversed=reversed)

    def _normalize(x):
        s = sum(x.values())
        if s != 0: s = 1.0 / s
        for k in x: 
            x[k] *= s
    
    x = start
    if x is None:
        x = dict([(n, random()) for n in G])
    _normalize(x)

    # Power method: y = Ax multiplication.
    for i in range(iterations):
        x0 = x
        x = dict.fromkeys(x0.keys(), 0)
        for n in x:
            for nbr in W[n]:
                r = 1
                if n in rating:
                    r = rating[n]
                x[n] += 0.01 + x0[nbr] * W[n][nbr] * r
        _normalize(x)          
        e = sum([abs(x[n]-x0[n]) for n in x])
        if e &lt; len(graph.nodes) * tolerance:
            if normalized:
                # Normalize between 0.0 and 1.0.
                m = max(x.values())
                if m == 0: m = 1
                x = dict([(id, w // m) for id, w in x.items()])
            return x

    #raise NoConvergenceError
    warn("node weight is 0 because eigenvector_centrality() did not converge.", Warning)
    return dict([(n, 0) for n in G])
</t>
<t tx="karstenw.20230329163234.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20230329163243.1">

# Copyright (c) 2007 Tom De Smedt.
# See LICENSE.txt for details.

import unicodedata

from math import degrees, sqrt, atan2,radians, sin, cos

CORNER = "corner"
CENTER = "center"

DEFAULT   = "default"
HIGHLIGHT = "highlight"  # used to mark shortest paths in pink
ROOT      = "root"       # used for the root node, big pink text
LIGHT     = "light"      # slightly important nodes (these are a bit darker)
DARK      = "dark"       # very important nodes (these are blue)
BACK      = "back"       # used as "back-button", green with a curved edge
IMPORTANT = "important"  # like dark, but with a double stroke
MARKED    = "marked"     # has a white dot inside the node

</t>
<t tx="karstenw.20230329163243.10">#### GRAPH STYLE GUIDE ###############################################################################
# Each node gets the default colors, type and drawing functions.
# The guide defines how and when to apply other styles based on node properties.
# It contains a set of style name keys linked to x(graph, node) functions.
# If such a function returns True for a node, the style is applied to that node.

class styleguide(dict):
    
    @others
</t>
<t tx="karstenw.20230329163243.11">def __init__(self, graph):
    self.graph = graph
    self.order = []

</t>
<t tx="karstenw.20230329163243.12">def append(self, stylename, function):
    """ The name of a style and a function that takes a graph and a node.
    It returns True when the style should be applied to the given node.
    """
    self[stylename] = function

</t>
<t tx="karstenw.20230329163243.13">def clear(self):
    self.order = []
    dict.__init__(self)

</t>
<t tx="karstenw.20230329163243.14">def apply(self):
    """ Check the rules for each node in the graph and apply the style.
    """
    sorted = self.order + list(self.keys())
    unique = []; [unique.append(x) for x in sorted if x not in unique]
    for node in self.graph.nodes:
        for s in unique:
            if s in self and self[s](self.graph, node): 
                node.style = s

</t>
<t tx="karstenw.20230329163243.15">def copy(self, graph):
    """ Returns a copy of the styleguide for the given graph.
    """
    g = styleguide(graph)
    g.order = self.order
    dict.__init__(g, [(k, v) for k, v in self.items()])
    return g

</t>
<t tx="karstenw.20230329163243.16">#### GRAPH STYLE #####################################################################################

class style:
    
    @others
</t>
<t tx="karstenw.20230329163243.17">def __init__(self, name, _ctx, **kwargs):
    
    """ Graph styling. 
    The default style is used for edges.
    When text is set to None, no id label is displayed.
    """

    self.name = name
    self._ctx = _ctx
    if not _ctx: 
        return
    
    # Defaults for colors and typography.
    self.background  = _ctx.color(0.18, 0.23, 0.28, 1.00)
    self.traffic     = _ctx.color(0.00, 0.00, 0.00, 0.07)
    self.fill        = _ctx.color(0.00, 0.00, 0.00, 0.10)
    self.stroke      = _ctx.color(0.80, 0.80, 0.80, 0.75)
    self.strokewidth = 0.5
    self.text        = _ctx.color(1.00, 1.00, 1.00, 0.85)
    self.font        = "Verdana"
    self.fontsize    = 10
    self.textwidth   = 100
    self.align       = 1
    self.depth       = True
        
    # The actual drawing methods are just a bunch of monkey patches,
    # so another function can easily be assigned.
    # Call style.draw_method(style, params) instead of style.draw_method(params).
    self.graph_background = graph_background
    self.graph_traffic    = graph_traffic
    self.node             = node
    self.node_label       = node_label
    self.edges            = edges
    self.edge             = edge
    self.edge_arrow       = edge_arrow
    self.edge_label       = edge_label
    self.path             = path
    
    # Each of the attributes is an optional named parameter in __init__().
    for attr in kwargs:
        if attr in self.__dict__:
            self.__dict__[attr] = kwargs[attr]

    # Use the Colors library for gradients and shadows?
    if self.depth:
        try: 
            global colors
            colors = _ctx.ximport("colors")
        except:
            self.depth = False

</t>
<t tx="karstenw.20230329163243.18">def copy(self, name=None):
    
    # Copy all attributes, link all monkey patch methods.
    s = style(self.name, self._ctx)
    for attr in self.__dict__: 
        v = self.__dict__[attr]
        if self._ctx and isinstance(v, self.fill.__class__): v = v.copy()
        s.__dict__[attr] = v
    if name != None: 
        s.name = name
    
    return s

</t>
<t tx="karstenw.20230329163243.19">#--- GRAPH BACKGROUND --------------------------------------------------------------------------------

def graph_background(s):

    """ Graph background color.
    """

    if s.background == None:
        s._ctx.background(None)
    else:
        s._ctx.background(s.background)  

    if s.depth:
        try:
            clr = colors.color(s.background).darker(0.2)
            p = s._ctx.rect(0, 0, s._ctx.WIDTH, s._ctx.HEIGHT, draw=False)
            colors.gradientfill(p, clr, clr.lighter(0.35))
            colors.shadow(dx=0, dy=0, blur=2, alpha=0.935, clr=s.background)
        except:
            pass

</t>
<t tx="karstenw.20230329163243.2">#### GRAPH STYLES ####################################################################################

class styles(dict):
    
    @others
</t>
<t tx="karstenw.20230329163243.20">#--- GRAPH TRAFFIC -----------------------------------------------------------------------------------

def graph_traffic(s, node, alpha=1.0):
    
    """ Visualization of traffic-intensive nodes (based on their centrality).
    """
    
    r = node.__class__(None).r
    r += (node.weight+0.5) * r * 5
    s._ctx.nostroke()
    if s.traffic:
        s._ctx.fill(
            s.traffic.r, 
            s.traffic.g, 
            s.traffic.b, 
            s.traffic.a * alpha
        )
        s._ctx.oval(node.x-r, node.y-r, r*2, r*2)      

</t>
<t tx="karstenw.20230329163243.21">#--- NODE --------------------------------------------------------------------------------------------

def node(s, node, alpha=1.0):

    """ Visualization of a default node.
    """

    if s.depth:
        try:
            colors.shadow(dx=5, dy=5, blur=10, alpha=0.5*alpha)
        except:
            pass
    
    s._ctx.nofill()
    s._ctx.nostroke()
    if s.fill:
        s._ctx.fill(
            s.fill.r, 
            s.fill.g, 
            s.fill.b, 
            s.fill.a * alpha
        )
    if s.stroke: 
        s._ctx.strokewidth(s.strokewidth)
        s._ctx.stroke(
            s.stroke.r, 
            s.stroke.g, 
            s.stroke.b, 
            s.stroke.a * alpha * 3
        )
    r = node.r
    s._ctx.oval(node.x-r, node.y-r, r*2, r*2)        

</t>
<t tx="karstenw.20230329163243.22">#--- NODE LABEL -------------------------------------------------------------------------------------

def node_label(s, node, alpha=1.0):

    """ Visualization of a node's id.
    """

    if s.text:
        s._ctx.lineheight(1)    
        s._ctx.font(s.font)
        s._ctx.fontsize(s.fontsize)
        s._ctx.nostroke()
        s._ctx.fill(
            s.text.r, 
            s.text.g, 
            s.text.b, 
            s.text.a * alpha
        )

        # Cache an outlined label text and translate it.
        # This enhances the speed and avoids wiggling text.
        try:
            p = node._textpath
        except: 
            txt = node.label
            try:
                txt = makeunicode(txt)
            except:
                pass
            # Abbreviation.
            #root = node.graph.root
            #if txt != root and txt[-len(root):] == root: 
            #    txt = txt[:len(txt)-len(root)]+root[0]+"."
            dx, dy = s._ctx.textwidth(" "), 0
            if s.align == 2: #CENTER
                dx = -s._ctx.textwidth(txt, s.textwidth) / 2
                dy =  s._ctx.textheight(txt) / 2
            node._textpath = s._ctx.textpath(txt, dx, dy, width=s.textwidth)
            p = node._textpath
        
        if s.depth:
            try:
                __colors.shadow(dx=2, dy=4, blur=5, alpha=0.3*alpha)
            except:
                pass
        
        s._ctx.push()
        s._ctx.translate(node.x, node.y)
        s._ctx.scale(alpha)
        s._ctx.drawpath(p)
        s._ctx.pop()

</t>
<t tx="karstenw.20230329163243.23">#--- EDGES -------------------------------------------------------------------------------------------

def edges(s, edges, alpha=1.0, weighted=False, directed=False):
    
    """ Visualization of the edges in a network.
    """
    
    p = s._ctx.BezierPath()
    if directed and s.stroke: 
        pd = s._ctx.BezierPath()    
    if weighted and s.fill: 
        pw = [s._ctx.BezierPath() for i in range(11)]
    
    # Draw the edges in a single BezierPath for speed.
    # Weighted edges are divided into ten BezierPaths,
    # depending on their weight rounded between 0 and 10.
    if len(edges) == 0: return
    for e in edges:
        try:  s2 = e.node1.graph.styles[e.node1.style]
        except: s2 = s
        if s2.edge:
            s2.edge(s2, p, e, alpha)
            if directed and s.stroke:
                s2.edge_arrow(s2, pd, e, radius=10)
            if weighted and s.fill:
                s2.edge(s2, pw[int(e.weight*10)], e, alpha)                

    s._ctx.autoclosepath(False)
    s._ctx.nofill()
    s._ctx.nostroke()

    # All weighted edges use the default fill.
    if weighted and s.fill:
        r = e.node1.__class__(None).r
        s._ctx.stroke(
            s.fill.r,
            s.fill.g,
            s.fill.b,
            s.fill.a * 0.65 * alpha
        )
        for w in range(1, len(pw)):
            s._ctx.strokewidth(r*w*0.1)
            s._ctx.drawpath(pw[w])        

    # All edges use the default stroke.
    if s.stroke: 
        s._ctx.strokewidth(s.strokewidth)
        s._ctx.stroke(
            s.stroke.r, 
            s.stroke.g, 
            s.stroke.b, 
            s.stroke.a * 0.65 * alpha
        )
    s._ctx.drawpath(p)
    
    if directed and s.stroke:
        clr = s._ctx.stroke().copy()
        clr.a *= 1.3
        s._ctx.fill(clr)
        s._ctx.drawpath(pd)
    
    for e in edges:
        try:  s2 = self.styles[e.node1.style]
        except: s2 = s
        if s2.edge_label:
            s2.edge_label(s2, e, alpha)

</t>
<t tx="karstenw.20230329163243.24">#--- EDGE --------------------------------------------------------------------------------------------

def edge(s, path, edge, alpha=1.0):
    
    """ Visualization of a single edge between two nodes.
    """
    
    path.moveto(edge.node1.x, edge.node1.y)
    if edge.node2.style == BACK:
        path.curveto(
            edge.node1.x,
            edge.node2.y,
            edge.node2.x,
            edge.node2.y,
            edge.node2.x,
            edge.node2.y,
        )        
    else:
        path.lineto(
            edge.node2.x, 
            edge.node2.y
        )

</t>
<t tx="karstenw.20230329163243.25">#--- EDGE ARROW --------------------------------------------------------------------------------------

def edge_arrow(s, path, edge, radius):

    if edge.node2.style == BACK: return

    x0, y0 = edge.node1.x, edge.node1.y
    x1, y1 = edge.node2.x, edge.node2.y

    coordinates = lambda x, y, d, a: (x+cos(radians(a))*d, y+sin(radians(a))*d)

    # Find the edge's angle based on node1 and node2 position.
    a = degrees(atan2(y1-y0, x1-x0))
    
    # The arrow points to node2's rim instead of it's center.
    r = edge.node2.r
    d = sqrt(pow(x1-x0, 2) + pow(y1-y0, 2))
    x01, y01 = coordinates(x0, y0, d-r-1, a)
    
    # Find the two other arrow corners under the given angle.
    r = edge.node1.r
    r = radius
    dx1, dy1 = coordinates(x01, y01, -r, a-20)
    dx2, dy2 = coordinates(x01, y01, -r, a+20)
    
    path.moveto(x01, y01)
    path.lineto(dx1, dy1)
    path.lineto(dx2, dy2)
    path.lineto(x01, y01)
    path.moveto(x1, y1)

</t>
<t tx="karstenw.20230329163243.26">#--- EDGE LABEL --------------------------------------------------------------------------------------

def edge_label(s, edge, alpha=1.0):

    """ Visualization of the label accompanying an edge.
    """

    if s.text and edge.label != "":       
        s._ctx.nostroke()
        s._ctx.fill(
            s.text.r, 
            s.text.g, 
            s.text.b, 
            s.text.a * alpha*0.75
        )
        s._ctx.lineheight(1)    
        s._ctx.font(s.font)
        s._ctx.fontsize(s.fontsize*0.75)
        
        # Cache an outlined label text and translate it.
        # This enhances the speed and avoids wiggling text.
        txt = "dummy"
        try:
            p = edge._textpath
        except:
            try:
                txt = makeunicode(edge.label)
            except Exception as err:
                print("edge_label ERROR:", err)
                print("txt:", repr(txt) )
            edge._textpath = s._ctx.textpath(txt, s._ctx.textwidth(" "), 0, width=s.textwidth)
            p = edge._textpath
        
        # Position the label centrally along the edge line.
        a  = degrees( atan2(edge.node2.y-edge.node1.y, edge.node2.x-edge.node1.x) )
        d  = sqrt((edge.node2.x-edge.node1.x)**2 +(edge.node2.y-edge.node1.y)**2)
        d  = abs(d-s._ctx.textwidth(edge.label)) * 0.5
        
        s._ctx.push()
        s._ctx.transform(CORNER)
        s._ctx.translate(edge.node1.x, edge.node1.y)
        s._ctx.rotate(-a)
        s._ctx.translate(d, s.fontsize*1.0)
        s._ctx.scale(alpha)
        
        # Flip labels on the left hand side so they are legible.
        if 90 &lt; a%360 &lt; 270:
            s._ctx.translate(s._ctx.textwidth(edge.label), -s.fontsize*2.0)
            s._ctx.transform(CENTER)
            s._ctx.rotate(180)
            s._ctx.transform(CORNER)
        
        s._ctx.drawpath(p)
        s._ctx.pop()        

</t>
<t tx="karstenw.20230329163243.27">#---- PATH -------------------------------------------------------------------------------------------

def path(s, graph, path):

    """ Visualization of a shortest path between two nodes.
    """

    def end(n):
        r = n.r * 0.35
        s._ctx.oval(n.x-r, n.y-r, r*2, r*2)

    if path and len(path) &gt; 1 and s.stroke:

        s._ctx.nofill()
        s._ctx.stroke(
            s.stroke.r,
            s.stroke.g,
            s.stroke.b,
            s.stroke.a
        )
        if s.name != DEFAULT:
            s._ctx.strokewidth(s.strokewidth)
        else:
            s._ctx.strokewidth(s.strokewidth*2)
            
        first = True
        for id in path:
            n = graph[id]
            if first:
                first = False
                s._ctx.beginpath(n.x, n.y)
                end(n)
            else:
                s._ctx.lineto(n.x, n.y)
        s._ctx.endpath()
        end(n)
</t>
<t tx="karstenw.20230329163243.3">def __init__(self, graph):
    self.guide = styleguide(graph)

</t>
<t tx="karstenw.20230329163243.4">def apply(self):
    self.guide.apply()

</t>
<t tx="karstenw.20230329163243.5">def create(self, stylename, **kwargs):
    """ Creates a new style which inherits from the default style,
    or any other style which name is supplied to the optional template parameter.
    """
    if stylename == "default":    
        self[stylename] = style(stylename, self._ctx, **kwargs)
        return self[stylename]
    k = kwargs.get("template", "default")
    s = self[stylename] = self[k].copy(stylename)
    for attr in kwargs:
        if attr in s.__dict__:
            s.__dict__[attr] = kwargs[attr]
    return s

</t>
<t tx="karstenw.20230329163243.6">def append(self, style):
    self[style.name] = style

</t>
<t tx="karstenw.20230329163243.7">def __getattr__(self, a):
    """ Keys in the dictionaries are accessible as attributes.
    """
    if a in self: 
        return self[a]
    raise AttributeError( "'styles' object has no attribute '"+a+"'" )
    
</t>
<t tx="karstenw.20230329163243.8">def __setattr__(self, a, v):
    """ Setting an attribute is like setting it in all of the contained styles.
    """
    if a == "guide":
        self.__dict__["guide"] = v
    elif len(self) &gt; 0 and a in list(self.values())[0].__dict__:
        for style in self.values(): 
            style.__dict__[a] = v
    else:
        raise AttributeError( "'style' object has no attribute '"+a+"'" )
        
</t>
<t tx="karstenw.20230329163243.9">def copy(self, graph):
    """ Returns a copy of all styles and a copy of the styleguide.
    """
    s = styles(graph)
    s.guide = self.guide.copy(graph)
    dict.__init__(s, [(v.name, v.copy()) for v in self.values()])
    return s

</t>
<t tx="karstenw.20230507112117.1"># py3 stuff
py3 = False
try:
    unicode('')
    punicode = unicode
    pstr = str
    punichr = unichr
except NameError:
    punicode = str
    pstr = bytes
    py3 = True
    punichr = chr
    long = int


def makeunicode(s, srcencoding="utf-8", normalizer="NFC"):
    """Make input string normalized unicode."""
    
    if type(s) not in (pstr, punicode):
        # apart from str/unicode/bytes we just need the repr
        s = str( s )
    if type(s) != punicode:
        s = punicode(s, srcencoding)
    s = unicodedata.normalize(normalizer, s)
    return s


</t>
<t tx="karstenw.20230507120719.1"></t>
<t tx="karstenw.20230507120724.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20230507120741.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20230507120743.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20230507120747.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20230507120753.1"># A graph that browses through the WordNet dictionary.
# You can click on nodes (including "has-parts" and "has-specific").
# You'll need the NodeBox Linguistics library installed.
# Author: Tom De Smedt.

query = "bird"

try:
    graph = ximport("graph")
except ImportError:
    graph = ximport("__init__")


from random import shuffle

import linguistics
import pattern
import pattern.text
import pattern.text.en
en = pattern.text.en
wordnet = pattern.text.en.wordnet


nouns = set(list( wordnet.NOUNS() ))



</t>
<t tx="karstenw.20230507120753.10">def is_expandable(self, id):
    
    """ Some of the branches are expandable:
    if you click on has-parts or has-specific, a detailed view will load.
    """
    
    if id in ["has-parts", "has-specific"]: 
        return True
    else:
        return False

</t>
<t tx="karstenw.20230507120753.11">def is_clickable(self, node):
    
    """ Every node that is a noun is clickable (except the root).
    """
    
    
    if node == self.root:
        return False

    id = node.id.lower()
    if id in nouns:
        return True
    if self.is_expandable(node.id):
        return True
    return False


</t>
<t tx="karstenw.20230507120753.12">def get_senses(self, word, top=6):

    """ The graph displays the different senses of a noun,
    e.g. light -&gt; lighter, luminosity, sparkle, ...
    """
    
    word = str(word)
    
    if self.is_expandable(word):
        return []
    
    # If there are 4 word senses and each of it a list of words,
    # take the first word from each list, then take the second etc.
    words = []
    fw = graph.FlowerWord( word )
    snses = fw.senses()
    for i in range(2):
        
        for sense in snses: # en.noun.senses(word):
            if (    len(sense) &gt; i
                and sense[i] != word
                and sense[i] not in words):
                words.append(sense[i])
                
    return words[:top]

</t>
<t tx="karstenw.20230507120753.13">def get_relations(self, word, previous=None):
    
    """ The graph displays semantic relations for a noun,
    e.g. light -&gt; has-specific -&gt; candlelight.
    """
    
    word = str(word)
    
    if self.is_expandable(word): 
        return self.expand(word, previous)

    words = []
    fw = graph.FlowerWord( word )
    # lexname = en.noun.lexname(word)
    lexname = fw.lexname
    if lexname != "":
        words.append((lexname, "category "))
    
    relations = [
        # (6, en.noun.holonym  , "has-parts"),
        (6, holonym  , "has-parts"),
        (2, meronym  , "is-part-of"),
        (2, antonym  , "is-opposite-of"),
        (3, hypernym , "is-a"),
        (2, senses   , "is-action"),
        (6, hyponym  , "has-specific"),
    ]
    # Get related words from WordNet.
    # Exclude long words and take the top of the list.
    for top, f, relation in relations:
        r = []
        try:
            rng = f(word, sense=self.senses.current)
        except:
            try:
                rng = f(word)
            except:
                continue
        for w in rng:
            if (    w[0] != word
                and w[0] not in r
                and len(w[0]) &lt; 20):
                r.append((w[0], relation))
                
        words.extend(r[:top])
        
    return words

</t>
<t tx="karstenw.20230507120753.14">def expand(self, relation, previous=None):
    
    """ Zoom in to the hyponym or holonym branch.
    """
    
    if relation == "has-specific" : f = en.noun.hyponym
    if relation == "has-parts"    : f = en.noun.holonym
    
    root = str(self.root.id.lower())
    unique = []
    if previous: previous = str(previous)
    for w in f(previous, sense=self.senses.current):
        if w[0] not in unique: unique.append(w[0])
    shuffle(unique)
    
    words = []
    i = 0
    for w in unique:
        # Organise connected nodes in branches of 4 nodes each.
        # Nodes that have the root id in their own id,
        # form a branch on their own.
        label = " "
        if w.find(root) &lt; 0:
            label = (i+4) / 4 * "  "
            i += 1
        words.append((w, label))
        
    return words

</t>
<t tx="karstenw.20230507120753.15">def click(self, node):
    
    """ If the node is indeed clickable, load it.
    """
    
    if self.is_clickable(node):
        p = self.root.id
        # Use the previous back node instead of "has specific".
        if self.is_expandable(p): p = self.nodes[-1].id
        self.load(node.id, previous=p)

</t>
<t tx="karstenw.20230507120753.16">def load(self, word, previous=None):
    
    self.clear()
    
    word = str(word)
    
    # Add the root (the clicked node) with the ROOT style.
    self.add_node(word, root=True, style="root")
    
    # Add the word senses to the root in the LIGHT style.
    for w in self.get_senses(word):
        self.add_node(w, style=self.styles.light.name)
        self.add_edge(word, w, 0.5)
        if len(self) &gt; self.max: break

    # Add relation branches to the root in the DARK style.
    for w, r in self.get_relations(word, previous):
        self.add_node(r, style="dark")
        self.add_edge(w, r, 1.0)
        self.add_edge(word, r)
        if len(self) &gt; self.max: break    

    # Provide a back link to the previous word.
    if previous and previous != self.root.id:
        n = self.add_node(previous, 10)
        if len(n.links) == 0: self.add_edge(word, n.id)
        n.style = "back"
    
    # Indicate the word corresponding to the current sense.
    if self.senses.count() &gt; 0:
        for w in en.noun.senses(word)[self.senses.current]:
            n = self.node(w)
            if n and n != self.root: 
                n.style = "marked"

</t>
<t tx="karstenw.20230507120753.17">def draw(self, *args, **kwargs):
    
    """ Additional drawing for sense selection buttons.
    """
    
    graph.graph.draw(self, *args, **kwargs)
    self.senses.draw()

</t>
<t tx="karstenw.20230507120753.18">### WORD SENSE SELECTION #######################################################

class senses:
    
    """ A row of word sense selection buttons.
    """
    
    @others
</t>
<t tx="karstenw.20230507120753.19">def __init__(self, graph, x, y):
    
    self.graph = graph
    self.word = ""
    self.x = x
    self.y = y
    
    self.current = 0
    self.pressed = None

</t>
<t tx="karstenw.20230507120753.2">def holonym( word, sense="" ):
    fw = FlowerWord( word )
    hn = fw.holonyms()
    if len(hn) &gt; 0:
        return hn[0]
    return ""

</t>
<t tx="karstenw.20230507120753.20">def count(self):
    
    """ The number of senses for the current word.
    The current word is synched to the graph's root node.
    """
    
    if self.word != self.graph.root.id:
        self.word = str(self.graph.root.id)
        self.current = 0
        self._count = 0
        try: self._count = len(en.noun.senses(self.word))
        except:
            pass
            
    return self._count

</t>
<t tx="karstenw.20230507120753.21">def draw(self):
    
    s = self.graph.styles.default
    x, y, f = self.x, self.y, s.fontsize
    
    _ctx.reset()
    _ctx.nostroke()
    _ctx.fontsize(f)
    
    for i in range(self.count()):
        
        clr = s.fill
        if i == self.current:
            clr = self.graph.styles.default.background
        _ctx.fill(clr)
        p = _ctx.rect(x, y, f*2, f*2)
        _ctx.fill(s.text)
        _ctx.align(CENTER)
        _ctx.text(str(i+1), x-f, y+f*1.5, width=f*4)
        x += f * 2.2
        
        self.log_pressed(p, i)
        self.log_clicked(p, i)

</t>
<t tx="karstenw.20230507120753.22">def log_pressed(self, path, i):
    
    """ Update senses.pressed to the last button pressed.
    """
    
    if mousedown \
    and self.graph.events.dragged == None \
    and path.contains(MOUSEX, MOUSEY):
        self.pressed = i

</t>
<t tx="karstenw.20230507120753.23">def log_clicked(self, path, i):
    
    """ Update senses.current to the last button clicked.
    """
    
    if not mousedown and self.pressed == i:
        self.pressed = None
        if path.contains(MOUSEX, MOUSEY):
            self.current = i
            self.graph.load(self.graph.root.id)      
    
</t>
<t tx="karstenw.20230507120753.24">def draw():
    g.styles.textwidth = 120
    g.draw(
        directed=True, 
        weighted=True,
        traffic=True
    )
    
</t>
<t tx="karstenw.20230507120753.3">def meronym( word, sense="" ):
    fw = FlowerWord( word )
    mn = fw.meronyms()
    if len(hn) &gt; 0:
        return mn[0]
    return ""

</t>
<t tx="karstenw.20230507120753.4">def antonym( word, sense="" ):
    fw = FlowerWord( word )
    hn = fw.holonyms()
    if len(hn) &gt; 0:
        return hn[0].antonym
    return ""

</t>
<t tx="karstenw.20230507120753.5">def hypernym( word, sense="" ):
    fw = FlowerWord( word )
    hn = fw.hypernyms()
    if len(hn) &gt; 0:
        return hn[0]
    return ""

</t>
<t tx="karstenw.20230507120753.6">def senses( word, sense="" ):
    fw = FlowerWord( word )
    hn = fw.hypernyms()
    if len(hn) &gt; 0:
        return hn[0]
    return ""

</t>
<t tx="karstenw.20230507120753.7">def hyponym( word, sense="" ):
    fw = FlowerWord( word )
    hn = fw.hyponyms()
    if len(hn) &gt; 0:
        return hn[0]
    return ""


#### WORDNET GRAPH #############################################################

</t>
<t tx="karstenw.20230507120753.8">class wordnetgraph(graph.graph):
    
    """ Browse WordNet in a graph.
    
    The wordnetgraph class is based on the standard graph class.
    I've added some functionality to fetch data from WordNet and browse
    through it.  When you click on a node, the wordnetgraph.click() method
    is fired.  This will check if the clicked node is a noun in WordNet, and
    if so, reload the graph's nodes and connections with that noun at the root.
    
    The main methods, get_senses() and get_relations(),
    are called when the graph reloads.
    They retrieve data from WordNet and format it as nodes.
    The expand() method is called when you click on "has-specific" or "has-parts".
    
    A helper class, senses, draws the interactive word sense selection buttons.
    
    """
    
    @others
</t>
<t tx="karstenw.20230507120753.9">def __init__(self, iterations=2000, distance=1.3):
    
    graph.graph.__init__(self, iterations, distance)
    self.styles = graph.create().styles
    self.events.click = self.click
    self.events.popup = True
    
    # Display a maximum of 20 nodes.
    self.max = 20
    
    # A row of buttons to select the current word sense.
    self.senses = senses(self, 20, 20)

</t>
<t tx="karstenw.20230507120755.1">try:
    graph = ximport("graph")
except ImportError:
    graph = ximport("__init__")
    # reload(graph)

size(800, 800)

g = graph.create(iterations=1000, distance=1.2, layout="spring")

# Add nodes with a random id,
# connected to other random nodes.
for i in range(60):
    node1 = g.add_node(random(500))
    if random() &gt; 0.5:
        for i in range(choice((1, 4))):
            node2 = choice(g.nodes)
            g.add_edge(node1.id, node2.id, weight=random())

g.prune()
g.styles.apply()

speed(10)
</t>
<t tx="karstenw.20230507120755.2">def draw():
    
    # If the graph layout is done,
    # show the shortest path between random nodes.
    path = []
    if g.done:
        id1 = choice( list(g.keys()) )
        id2 = choice( list(g.keys()) )
        path = g.shortest_path(id1, id2)    
        
    # Draw the graph and display the shortest path.
    g.draw(highlight=path, traffic=4, weighted=True, directed=True)
</t>
<t tx="karstenw.20230507120757.1">try:
    graph = ximport("graph")
except ImportError:
    graph = ximport("__init__")
    # reload(graph)

size(600, 600)

# A graph object.
g = graph.create(iterations=500, distance=1.0)

# Add nodes with a random id,
# connected to other random nodes.
for i in range(50):
    node1 = g.add_node(random(500))
    if random() &gt; 0.5:
        for i in range(choice((2, 3))):
            node2 = choice(g.nodes)
            g.add_edge(node1.id, node2.id, weight=random())

# We leave out any orphaned nodes.
g.prune()

# Colorize nodes.
# Nodes with higher importance are blue.
g.styles.apply()

# Update the graph layout until it's done.
g.solve()

# Show the shortest path between two random nodes.
path = []
id1 = choice( list(g.keys()) )
id2 = choice( list(g.keys()) )
path = g.shortest_path(id1, id2)

# Draw the graph and display the shortest path.
g.draw(highlight=path, weighted=True, directed=True)
</t>
<t tx="karstenw.20230507120759.1"># Import the library
try:
    # This is the statement you normally use.
    graph = ximport("graph")
except ImportError:
    # But since these examples are "inside" the library
    # we may need to try something different when
    # the library is not located in /Application Support
    graph = ximport("__init__")
    # reload(graph)

size(500, 500)

g = graph.create()

# Create some relations.
g.add_edge("roof"        , "house")
g.add_edge("garden"      , "house")
g.add_edge("room"        , "house")
g.add_edge("kitchen"     , "room")
g.add_edge("bedroom"     , "room")
g.add_edge("bathroom"    , "room")
g.add_edge("living room" , "room")
g.add_edge("sofa"        , "living room")
g.add_edge("table"       , "living room")

# Calculate a good layout.
g.solve()

# Apply default rules for node colors and size,
# for example, important nodes become blue.
g.styles.apply()

# Draw the graph, indicating the direction of each relation
# and the two nodes that get the most traffic.
g.draw(
    directed=True,
    traffic=1
)

# You'll see that "house" is the key node,
# and that "room" gets the most traffic.
</t>
<t tx="karstenw.20230518121333.1">#### REPLACEMENTS ##############################################################
# 
# these should move two levels up into linguistics


</t>
<t tx="karstenw.20230518121412.1">######################################################################################################

g = wordnetgraph(distance=1.2)
g.load(query)

size(550, 550)
speed(30) 
</t>
<t tx="karstenw.20230518183122.1"></t>
<t tx="karstenw.20230518183122.10">def holonyms(self):
    result = []
    for synset in self.synsets:
        holonyms = synset.holonyms()
        for holonym in holonyms:
            synonyms = hyponym.synonyms
            for synonym in synonyms:
                synonym = synonym.replace("_", " ")
                result.append( synonym )
    result = list(set(result))
    return result

</t>
<t tx="karstenw.20230518183122.11">def meronyms(self):
    result = []
    for synset in self.synsets:
        meronyms = synset.meronyms()
        for meronym in meronyms:
            synonyms = hyponym.synonyms
            for synonym in synonyms:
                synonym = synonym.replace("_", " ")
                result.append( synonym )
    result = list(set(result))
    return result

</t>
<t tx="karstenw.20230518183122.12">def sortnodes_zero( a, b ):
    if a[0] &gt; b[0]:
        return 1
    elif a[0] &lt; b[0]:
        return -1
    return 0

</t>
<t tx="karstenw.20230518183122.2"># py3 stuff
py3 = False
try:
    unicode('')
    punicode = unicode
    pstr = str
    punichr = unichr
except NameError:
    punicode = str
    pstr = bytes
    py3 = True
    punichr = chr
    long = int


</t>
<t tx="karstenw.20230518183122.3">def cmp_to_key(mycmp):
    'Convert a cmp= function into a key= function'
    class K:
        def __init__(self, obj, *args):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) &lt; 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) &gt; 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) &lt;= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) &gt;= 0
        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0
    return K


</t>
<t tx="karstenw.20230518183122.4">def sortlist(thelist, thecompare):
    if py3:
        sortkeyfunction = cmp_to_key( thecompare )
        thelist.sort( key=sortkeyfunction )
    else:
        thelist.sort( thecompare )


</t>
<t tx="karstenw.20230518183122.5">class FlowerWord:
    @others


</t>
<t tx="karstenw.20230518183122.6">def __init__(self, word):
    # pdb.set_trace()
    self.word = word
    self.synsets = wordnet.synsets( word )
    self.idx = 0
    self.antonym = ""
    self.gloss = ""
    self.synset = None
    self.synonyms = []
    self.antonym = ""
    self.gloss = ""
    self.lexname = ""

    if len(self.synsets) &gt; 0:
        synonyms = self.synsets[0].synonyms
        try:
            self.idx = synonyms.index(word)
            w = self.synset = self.synsets[self.idx]
            #print("Found synset:", w)
        except:
            w = self.synsets[0]
            #print("Use synset:", w)

        self.antonym = w.antonym
        self.gloss = w.gloss
        self.lexname = w.lexname

</t>
<t tx="karstenw.20230518183122.7">def hyponyms(self):
    result = []
    for synset in self.synsets:
        hyponyms = synset.hyponyms()
        for hyponym in hyponyms:
            synonyms = hyponym.synonyms
            for synonym in synonyms:
                synonym = synonym.replace("_", " ")
                result.append( synonym )
    result = list(set(result))
    return result

</t>
<t tx="karstenw.20230518183122.8">def hypernyms(self):
    result = []
    for synset in self.synsets:
        hypernyms = synset.hypernyms()
        for hypernym in hypernyms:
            synonyms = hypernym.synonyms
            for synonym in synonyms:
                synonym = synonym.replace("_", " ")
                result.append( synonym )
    result = list(set(result))
    return result


</t>
<t tx="karstenw.20230518183122.9">def senses(self):
    result = []
    for synset in self.synsets:
        senses = synset.senses
        result.append( senses )
    return result


</t>
</tnodes>
</leo_file>
