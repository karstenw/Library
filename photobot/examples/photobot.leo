<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="karstenw.20170709210102.1" a="E"><vh>examples</vh>
<v t="karstenw.20170709210735.1"><vh>@clean explore_gradients 1.py</vh>
<v t="karstenw.20170709210910.1"><vh>Declarations</vh></v>
</v>
<v t="karstenw.20170715185201.1"><vh>@clean explore_gradients 2.py</vh>
<v t="karstenw.20170715185207.1"><vh>Declarations</vh></v>
<v t="karstenw.20170715185207.2"><vh>dogradient</vh></v>
</v>
<v t="karstenw.20170709211002.1"><vh>@clean Layer_colorize.py</vh>
<v t="karstenw.20170709211010.1"><vh>Declarations</vh>
<v t="karstenw.20170710094409.1"><vh>&lt;&lt;initialisation&gt;&gt;</vh></v>
</v>
</v>
<v t="karstenw.20170710094259.1"><vh>@clean Layer_function_screen.py</vh>
<v t="karstenw.20170710094319.1"><vh>Declarations</vh>
<v t="karstenw.20170710094409.1"></v>
<v t="karstenw.20170710105816.1"><vh>&lt;&lt;image1&gt;&gt;</vh></v>
<v t="karstenw.20170710105845.1"><vh>&lt;&lt;image2&gt;&gt;</vh></v>
<v t="karstenw.20170710105940.1"><vh>&lt;&lt;image34&gt;&gt;</vh></v>
<v t="karstenw.20170710105956.1"><vh>&lt;&lt;image56&gt;&gt;</vh></v>
<v t="karstenw.20170710110147.1"><vh>&lt;&lt;outro&gt;&gt;</vh></v>
</v>
</v>
<v t="karstenw.20170710105607.1"><vh>@clean Layer_function_overlay.py</vh>
<v t="karstenw.20170710105617.1"><vh>Declarations</vh>
<v t="karstenw.20170710094409.1"></v>
<v t="karstenw.20170710105816.1"></v>
<v t="karstenw.20170710105845.1"></v>
<v t="karstenw.20170710105940.1"></v>
<v t="karstenw.20170710105956.1"></v>
<v t="karstenw.20170710110147.1"></v>
</v>
</v>
<v t="karstenw.20170710113238.1"><vh>@clean Layer_function_brightness.py</vh>
<v t="karstenw.20170710094409.1"></v>
</v>
<v t="karstenw.20170710113905.1"><vh>@clean Layer_function_color.py</vh>
<v t="karstenw.20170710113922.1"><vh>Declarations</vh>
<v t="karstenw.20170710094409.1"></v>
<v t="karstenw.20170710105816.1"></v>
<v t="karstenw.20170710105845.1"></v>
<v t="karstenw.20170710105940.1"></v>
<v t="karstenw.20170710105956.1"></v>
<v t="karstenw.20170710110147.1"></v>
</v>
</v>
<v t="karstenw.20170710122812.1"><vh>@clean Layer_function_mask.py</vh>
<v t="karstenw.20170710122823.1"><vh>Declarations</vh>
<v t="karstenw.20170710094409.1"></v>
<v t="karstenw.20170710105816.1"></v>
<v t="karstenw.20170710105845.1"></v>
<v t="karstenw.20170710110147.1"></v>
</v>
</v>
<v t="karstenw.20170710130259.1"><vh>@clean Layer_function_opacity.py</vh>
<v t="karstenw.20170710134831.1"><vh>&lt;&lt;initialisation&gt;&gt;</vh></v>
</v>
<v t="karstenw.20170710134714.1"><vh>@clean Layer_function_contrast.py</vh>
<v t="karstenw.20170710094409.1"></v>
</v>
<v t="karstenw.20170710140437.1"><vh>@clean Layer_function_flip.py</vh>
<v t="karstenw.20170710094409.1"></v>
<v t="karstenw.20170710110147.1"></v>
</v>
<v t="karstenw.20170715181646.1"><vh>@clean Layer_function_hue.py</vh>
<v t="karstenw.20170710094409.1"></v>
<v t="karstenw.20170710105816.1"></v>
<v t="karstenw.20170710105845.1"></v>
<v t="karstenw.20170710105940.1"></v>
<v t="karstenw.20170710105956.1"></v>
<v t="karstenw.20170710110147.1"></v>
</v>
<v t="karstenw.20170711131553.1"><vh>@clean Example collage 1.py</vh>
<v t="karstenw.20170711131604.1"><vh>Declarations</vh></v>
<v t="karstenw.20170711131604.2"><vh>cropImageToRatioHorizontal</vh></v>
<v t="karstenw.20170711131604.3"><vh>insetRect</vh></v>
<v t="karstenw.20170711131604.4"><vh>aspectRatio</vh></v>
<v t="karstenw.20170711131604.5"><vh>topLayer</vh></v>
</v>
<v t="karstenw.20170711131606.1"><vh>@clean Example collage 2.py</vh>
<v t="karstenw.20170711131614.1"><vh>Declarations</vh></v>
<v t="karstenw.20170711131614.2"><vh>topLayer</vh></v>
</v>
<v t="karstenw.20170711131616.1"><vh>@clean Example collage 3.py</vh>
<v t="karstenw.20170711131630.1"><vh>Declarations</vh></v>
<v t="karstenw.20170711131630.2"><vh>placeImage</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="karstenw.20170709210102.1"></t>
<t tx="karstenw.20170709210735.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170709210910.1">size(960, 1200)


pb = ximport("photobot")
reload(pb)

pbh = ximport("pbhelpers")
label = pbh.label

c = pb.canvas(WIDTH, HEIGHT)

c.fill((210, 210, 10))


# the gradients

# SOLID
grad1idx = c.gradient(pb.SOLID, 180, 180)
c.layers[grad1idx].translate(10, 10)
label("SOLID", 10, 10)

# LINEAR
grad2idx = c.gradient(pb.LINEAR, 180, 180)
c.layers[grad2idx].translate(200, 10)
label("LINEAR", 200, 10)

# RADIAL
grad3idx = c.gradient(pb.RADIAL, 180, 180)
c.layers[grad3idx].translate(390, 10)
label("RADIAL", 390, 10)

# DIAMOND
grad4idx = c.gradient(pb.DIAMOND, 180, 180)
c.layers[grad4idx].translate(580, 10)
label("DIAMOND", 580, 10)

# SINE (from 0 to 180)
grad5idx = c.gradient(pb.SINE, 180, 180)
c.layers[grad5idx].translate(10, 200)
label("SINE 0..180", 10, 200)

# COSINE (from 0 to 90)
grad6idx = c.gradient(pb.COSINE, 180, 180)
c.layers[grad6idx].translate(200, 200)
label("COSINE 0..90", 200, 200)

# ROUNDRECT (with radius arg)
grad7idx = c.gradient(pb.ROUNDRECT, 180, 180, radius=72, radius2=18)
c.layers[grad7idx].translate(390, 200)
label("ROUNDRECT", 390, 200)

# RADIALCOSINE
grad8idx = c.gradient(pb.RADIALCOSINE, 180, 180)
c.layers[grad8idx].translate(580, 200)
label("RADIALCOSINE", 580, 200)

# QUAD
grad8idx = c.gradient(pb.QUAD, 180, 180, radius=36, radius2=9)
c.layers[grad8idx].translate(770, 200)
label("QUAD", 770, 200)


# the gradients masked with itself
# 
gx, xy = 180, 180
# SOLID
grad1idx = c.gradient(pb.SOLID , gx, xy)
mask = c.gradient(pb.SOLID, gx, xy)
c.layers[mask].mask()
c.layers[grad1idx].translate(10, 390)


# LINEAR
grad2idx = c.gradient(pb.LINEAR, gx, xy)
mask = c.gradient(pb.LINEAR, gx, xy)
c.layers[mask].mask()
c.layers[grad2idx].translate(200, 390)


# RADIAL
# you want to have the RADIAL gradient inverted
grad3idx = c.gradient(pb.RADIAL, gx, xy, radius=36)
c.layers[grad3idx].invert()
mask = c.gradient(pb.RADIAL, gx, xy)
c.layers[mask].invert()
c.layers[mask].mask()
c.layers[grad3idx].translate(390, 390)


# DIAMOND
grad4idx = c.gradient(pb.DIAMOND, gx, xy)
mask = c.gradient(pb.DIAMOND, gx, xy)
c.layers[mask].mask()
c.layers[grad4idx].translate(580, 390)


# SINE 0..180
grad5idx = c.gradient(pb.SINE, gx, xy)
mask = c.gradient(pb.SINE, gx, xy)
c.layers[mask].mask()
c.layers[grad5idx].translate(10, 580)


# COSINE 0..90
grad6idx = c.gradient(pb.COSINE, gx, xy)
mask = c.gradient(pb.COSINE, gx, xy)
c.layers[mask].mask()
c.layers[grad6idx].translate(200, 580)


# ROUNDRECT 
grad7idx = c.gradient(pb.ROUNDRECT, gx, xy, radius=72, radius2=9)
mask = c.gradient(pb.ROUNDRECT, gx, xy, radius=72, radius2=9)
c.layers[mask].mask()
c.layers[grad7idx].translate(390, 580)


# RADIALCOSINE
grad8idx = c.gradient(pb.RADIALCOSINE, gx, xy)
mask = c.gradient(pb.RADIALCOSINE, gx, xy)
c.layers[mask].mask()
c.layers[grad8idx].translate(580, 580)

# QUAD
grad9idx = c.gradient(pb.QUAD, gx, xy, radius=36, radius2=9)
mask = c.gradient(pb.QUAD, gx, xy, radius=36, radius2=9)
c.layers[mask].mask()
c.layers[grad9idx].translate(770, 580)




# COSINE 0..90
grad6idx = c.gradient(pb.COSINE, gx, xy)
mask = c.gradient(pb.COSINE, gx, xy)
c.layers[mask].mask()
c.layers[grad6idx].translate(100, 800)
c.layers[grad6idx].rotate(45)


# RADIALCOSINE

grad8idx = c.gradient(pb.RADIALCOSINE, gx*2, xy)
mask = c.gradient(pb.RADIALCOSINE, gx*2, xy)
c.layers[mask].mask()
c.layers[grad8idx].translate(390, 770)


# QUAD
grad9idx = c.gradient(pb.QUAD, gx*2, xy)
mask = c.gradient(pb.QUAD, gx*2, xy)
c.layers[mask].mask()
c.layers[grad9idx].translate(390, 960)



c.draw(1, 1)

# put labels on top
canvas._grobs.reverse()
</t>
<t tx="karstenw.20170709211002.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170709211010.1">W,H = 532, 1050
&lt;&lt;initialisation&gt;&gt;
#
# Image 1
#

#  create, scale and place the image
x, y = 10, 10
top, w1, h1 = pb.placeImage(c, img1path, x, y, 512, "Image 1", width=True)
label("Image 1", x, y)


# apply colorize
c.layers[top].colorize((240, 120, 0), (255, 255, 127))


# draw the result
c.draw(0, 0)
</t>
<t tx="karstenw.20170710094259.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170710094319.1">W,H = 550, 1050
&lt;&lt;initialisation&gt;&gt;
&lt;&lt;image1&gt;&gt;
&lt;&lt;image2&gt;&gt;

#
# Screen Images 1 &amp; 2
#

&lt;&lt;image34&gt;&gt;
c.top.screen()
label("Screen Image 1 over Image 2", x, y)


#
# Screen Images 2 &amp; 1
#

&lt;&lt;image56&gt;&gt;
c.top.screen()
label("Screen Image 2 over Image 1", x, y)

&lt;&lt;outro&gt;&gt;
</t>
<t tx="karstenw.20170710094409.1"># 
# Note:
#
# The examples may be easier to understand if you have LEO http://leoeditor.com installed
# and read them using the photobot.leo file
#
#
kwdbg = False

size(W, H)

background( 0.333 )

# need a different name; random is taken
import random as rnd

if kwdbg:
    # make random choices repeatable for debugging
    rnd.seed(0)

# import photobot
pb = ximport("photobot")
pbh = ximport("pbhelpers")
label = pbh.label

# import extensions if nodebox version &lt; 1.9.18
try:
    imagefiles
except NameError:
    from nodeboxExtensions import *

# create the canvas
c = pb.canvas(int(WIDTH), int(HEIGHT))

# get all images from system "Desktop Pictures" folder
filetuples = imagefiles( "/Library/Desktop Pictures", False )

# filter out all 1 pix one color images by ignoring all files &lt; 100k
tiles = []
for t in filetuples:
    path, filesize, lastmodified, mode, islink = t
    if filesize &lt; 100000:
        continue
    tiles.append( path )

# shuffle the images
rnd.shuffle(tiles)
rnd.shuffle(tiles)
rnd.shuffle(tiles)


img1path = tiles.pop()
img2path = tiles.pop()

</t>
<t tx="karstenw.20170710105607.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170710105617.1">W,H = 542, 1050
&lt;&lt;initialisation&gt;&gt;
&lt;&lt;image1&gt;&gt;
&lt;&lt;image2&gt;&gt;


#
# Overlay Images 1 &amp; 2
#

&lt;&lt;image34&gt;&gt;

c.top.overlay()
label("Overlay Image2 over Image1", x, y)

#
# Overlay Images 2 &amp; 1
#

&lt;&lt;image56&gt;&gt;

c.top.overlay()
label("Overlay Image1 over Image2", x, y)

&lt;&lt;outro&gt;&gt;



</t>
<t tx="karstenw.20170710105816.1">#
# Image 1
#

#  create, scale and place the image
x, y = 10, 10
top, w1, h1 = pb.placeImage(c, img1path, x, y, 256, "Image 1")
label("Image 1", x, y)

</t>
<t tx="karstenw.20170710105845.1">#
# Image 2
#
x, y = w1+20, 10
top, w2, h2 = pb.placeImage(c, img2path, x, y, 256, "Image 2")
label("Image 2", x, y)

</t>
<t tx="karstenw.20170710105940.1">h = max(h1, h2)
x, y = 10 , h + 20

top, w3, h3 = pb.placeImage(c, img1path, x, y, 522, "Image 3")
top, w4, h4 = pb.placeImage(c, img2path, x, y, 522, "Image 4")

</t>
<t tx="karstenw.20170710105956.1">h = max(h3, h4)
x, y = 10 , h + 20 + y

top, w4, h4 = pb.placeImage(c, img2path, x, y, 522, "Image 5")
top, w3, h3 = pb.placeImage(c, img1path, x, y, 522, "Image 6")

</t>
<t tx="karstenw.20170710110147.1"># draw the result
c.draw(0, 0)


# this is just mean
# if you understand what it does, you're the next NodeBox maintainer...
canvas._grobs.reverse()


</t>
<t tx="karstenw.20170710113238.1">@language python
@tabwidth -4
@others
W,H = 542, 1050
&lt;&lt;initialisation&gt;&gt;
#
# Image 1
#

#  create, scale and place the image
x, y = 10, 10
img1, w1, h1 = pb.placeImage(c, img1path, x, y, 256, "Image 1", width=True)
label("Image 1 Brightness: 100", x, y)

#
# Image 2
#
c.layers[img1].duplicate()
c.top.name = "Image 2"
c.top.brightness(80)

x, y = w1+20, 10
c.top.translate( x, y)
label("Image 2 Brightness: 80", x, y)

#
# Image 3
#
c.layers[img1].duplicate()
c.top.name = "Image 3"
c.top.brightness(60)

x, y = 10, h1 + 20
c.top.translate( x, y)
label("Image 3 Brightness: 60", x, y)

#
# Image 4
#
c.layers[img1].duplicate()
c.top.name = "Image 4"
c.top.brightness(40)

x, y = w1+20, h1 + 20
c.top.translate( x, y)
label("Image 4 Brightness: 40", x, y)

#
# Image 5
#
c.layers[img1].duplicate()
c.top.name = "Image 5"
c.top.brightness(20)

x, y = 10, 2*h1 + 30
c.top.translate( x, y)
label("Image 3 Brightness: 20", x, y)

#
# Image 6
#
c.layers[img1].duplicate()
c.top.name = "Image 6"
c.top.brightness(10)

x, y = w1+20, 2*h1 + 30
c.top.translate( x, y)
label("Image 6 Brightness: 10", x, y)

#
# Image 7
#
c.layers[img1].duplicate()
c.top.name = "Image 7"
c.top.brightness(150)

x, y = 10, 3*h1 + 40
c.top.translate( x, y)
label("Image 7 Brightness: 150", x, y)

#
# Image 8
#
c.layers[img1].duplicate()
c.top.name = "Image 8"
c.top.brightness(200)

x, y = w1 + 20, 3*h1 + 40
c.top.translate( x, y)
label("Image 8 Brightness: 200", x, y)



# draw the result
c.draw(0, 0)


# this is just mean
# if you understand what it does, you're the next NodeBox maintainer...
canvas._grobs.reverse()
</t>
<t tx="karstenw.20170710113905.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170710113922.1">W,H = 542, 1050
&lt;&lt;initialisation&gt;&gt;
&lt;&lt;image1&gt;&gt;
&lt;&lt;image2&gt;&gt;

#
# Color Images 1 &amp; 2
#

&lt;&lt;image34&gt;&gt;

c.layers[top].color()
label("Color Image2 over Image1", x, y)

#
# Color Images 2 &amp; 1
#

&lt;&lt;image56&gt;&gt;

c.layers[top].color()
label("Color Image1 over Image2", x, y)

&lt;&lt;outro&gt;&gt;



</t>
<t tx="karstenw.20170710122812.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170710122823.1">W,H = 542, 1050
&lt;&lt;initialisation&gt;&gt;
&lt;&lt;image1&gt;&gt;
&lt;&lt;image2&gt;&gt;


#
# Mask Images 1 &amp; 2
#

h = max(h1, h2)
x, y = 10 , h + 20

top, w3, h3 = pb.placeImage(c, img1path, 0, 0, 522, "Image 3")
top, w4, h4 = pb.placeImage(c, img2path, 0, 0, 522, "Image 4")
c.layers[top].mask()
c.top.translate(x, y)

label("Mask Image1 over Image2", x, y)

#
# Mask Images 2 &amp; 1
#

h = max(h3, h4)
x, y = 10 , h + 20 + y

top, w4, h4 = pb.placeImage(c, img2path, 0, 0, 522, "Image 5")
top, w3, h3 = pb.placeImage(c, img1path, 0, 0, 522, "Image 6")
c.top.mask()
c.top.translate(x, y)

label("Mask Image2 over Image1", x, y)

&lt;&lt;outro&gt;&gt;



</t>
<t tx="karstenw.20170710130259.1">@language python
@tabwidth -4
W,H = 542, 1050
&lt;&lt;initialisation&gt;&gt;
#
# Image 1
#

#  create, scale and place the image
x, y = 10, 10
img1, w1, h1 = pb.placeImage(c, img1path, x, y, 256, "Image 1", width=True)
label("Image 1 Opacity: 100", x, y)

#
# Image 2
#
c.layers[img1].duplicate()
c.top.name = "Image 2"
c.top.opacity(80)

x, y = w1+20, 10
c.top.translate( x, y)
label("Image 2 Opacity: 80", x, y)

#
# Image 3
#
c.layers[img1].duplicate()
c.top.name = "Image 3"
c.top.opacity(60)

x, y = 10, h1 + 20
c.top.translate( x, y)
label("Image 3 Opacity: 60", x, y)

#
# Image 4
#
c.layers[img1].duplicate()
c.top.name = "Image 4"
c.top.opacity(40)

x, y = w1+20, h1 + 20
c.top.translate( x, y)
label("Image 4 Opacity: 40", x, y)

#
# Image 5
#
c.layers[img1].duplicate()
c.top.name = "Image 5"
c.top.opacity(20)

x, y = 10, 2*h1 + 30
c.top.translate( x, y)
label("Image 3 Opacity: 20", x, y)

#
# Image 6
#
c.layers[img1].duplicate()
c.top.name = "Image 6"
c.top.opacity(10)

x, y = w1+20, 2*h1 + 30
c.top.translate( x, y)
label("Image 6 Opacity: 10", x, y)

#
# Image 7
#
c.layers[img1].duplicate()
c.top.name = "Image 7"
c.top.opacity(150)

x, y = 10, 3*h1 + 40
c.top.translate( x, y)
label("Image 7 Opacity: 150", x, y)

#
# Image 8
#
c.layers[img1].duplicate()
c.top.name = "Image 8"
c.top.opacity(200)

x, y = w1 + 20, 3*h1 + 40
c.top.translate( x, y)
label("Image 8 Opacity: 200", x, y)



# draw the result
c.draw(0, 0)


# this is just mean
# if you understand what it does, you're the next NodeBox maintainer...
canvas._grobs.reverse()
</t>
<t tx="karstenw.20170710134714.1">@language python
@tabwidth -4
W,H = 542, 1050
&lt;&lt;initialisation&gt;&gt;

#
# Image 1
#

#  create, scale and place the image
x, y = 10, 10
img1, w1, h1 = pb.placeImage(c, img1path, x, y, 256, "Image 1", width=True)
label("Image 1 Contrast: 100", x, y)

#
# Image 2
#
c.layers[img1].duplicate()
c.top.name = "Image 2"
c.top.contrast(80)

x, y = w1+20, 10
c.top.translate( x, y)
label("Image 2 Contrast: 80", x, y)

#
# Image 3
#
c.layers[img1].duplicate()
c.top.name = "Image 3"
c.top.contrast(60)

x, y = 10, h1 + 20
c.top.translate( x, y)
label("Image 3 Contrast: 60", x, y)

#
# Image 4
#
c.layers[img1].duplicate()
c.top.name = "Image 4"
c.top.contrast(40)

x, y = w1+20, h1 + 20
c.top.translate( x, y)
label("Image 4 Contrast: 40", x, y)

#
# Image 5
#
c.layers[img1].duplicate()
c.top.name = "Image 5"
c.top.contrast(20)

x, y = 10, 2*h1 + 30
c.top.translate( x, y)
label("Image 3 Contrast: 20", x, y)

#
# Image 6
#
c.layers[img1].duplicate()
c.top.name = "Image 6"
c.top.contrast(10)

x, y = w1+20, 2*h1 + 30
c.top.translate( x, y)
label("Image 6 Contrast: 10", x, y)

#
# Image 7
#
c.layers[img1].duplicate()
c.top.name = "Image 7"
c.top.contrast(150)

x, y = 10, 3*h1 + 40
c.top.translate( x, y)
label("Image 7 Contrast: 150", x, y)

#
# Image 8
#
c.layers[img1].duplicate()
c.top.name = "Image 8"
c.top.contrast(200)

x, y = w1 + 20, 3*h1 + 40
c.top.translate( x, y)
label("Image 8 Contrast: 200", x, y)

# draw the result
c.draw(0, 0)


# this is just mean
# if you understand what it does, you're the next NodeBox maintainer...
canvas._grobs.reverse()
</t>
<t tx="karstenw.20170710134831.1">kwdbg = False

size(W, H)

background( 0.333 )

# need a different name; random is taken
import random as rnd

if kwdbg:
    # make random choices repeatable for debugging
    rnd.seed(0)

# import photobot
try:
    pb = ximport("photobot")
    pbh = ximport("pbhelpers")
except ImportError:
    pb = ximport("__init__")
    reload(pb)
from pbhelpers import *

# import extensions if nodebox version &lt; 1.9.18
try:
    imagefiles
except NameError:
    from nodeboxExtensions import *

# create the canvas
c = pb.canvas(int(WIDTH), int(HEIGHT))

# get all images from system "Desktop Pictures" folder
filetuples = imagefiles( "/Library/Desktop Pictures", False )

# filter out all 1 pix one color images by ignoring all files &lt; 100k
tiles = []
for t in filetuples:
    path, filesize, lastmodified, mode, islink = t
    if filesize &lt; 100000:
        continue
    tiles.append( path )

# shuffle the images
rnd.shuffle(tiles)
rnd.shuffle(tiles)
rnd.shuffle(tiles)


img1path = tiles.pop()
img2path = tiles.pop()


</t>
<t tx="karstenw.20170710140437.1">@language python
@tabwidth -4
@others
W,H = 1084, 798
&lt;&lt;initialisation&gt;&gt;
imsize = int((W-30)/2)
x, y = 10, 10
img1, w1, h1 = pb.placeImage(c, img1path, x, y, imsize, "image1")
label("Original Image", x, y)

#
# flip horizontal
#
c.layers["image1"].duplicate()
c.top.name = "flip1"

x, y = w1+20, 10
c.top.translate( x, y)
c.top.flip( pb.HORIZONTAL )
label("Horizontal Flip", x, y)


#
# flip vertical
#

c.layers["image1"].duplicate()
c.top.name = "flip2"
x, y = 10 , h1 + 20
c.top.flip( pb.VERTICAL )
c.top.translate( x, y )
label("Vertical Flip", x, y)



#
# flip horizontal &amp; vertical
#

# duplicate does not return top
c.layers["image1"].duplicate()
c.top.name = "flip3"

x, y = w1 + 20, h1 + 20
c.top.flip( pb.HORIZONTAL | pb.VERTICAL)
# c.top.flip( pb.VERTICAL )
c.top.translate( x, y)
label("Horizontal  and Vertical Flip", x, y)

&lt;&lt;outro&gt;&gt;



</t>
<t tx="karstenw.20170711131553.1">@others
if 1:
    # orange hue mask finish
    top = c.fill((200,100,0))
    c.top.opacity(30)
    c.top.hue()

if paintoverlay:
    # paint overlay
    top = c.layer( os.path.abspath("./paint.jpg") )
    w, h = c.top.bounds()
    xs = WIDTH / float(w)
    ys = HEIGHT / float(h)
    s = max(xs,ys)
    c.top.scale(s, s)
    c.top.opacity(10)
    c.top.overlay()

c.draw(0, 0)
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170711131604.1"># heavily inspired by https://www.nodebox.net/code/index.php/Landslide
import sys, os

import pprint
pp = pprint.pprint
kwdbg = False

# need a different name
import random as rnd

if kwdbg:
    # make random choices repeatable for debugging
    rnd.seed(0)


W, H = 1024,768
W, H = 1920, 1080


# import photobot
try:
    pb = ximport("photobot")
    size(W, H)
    background( 0.333 )
except ImportError:
    pb = ximport("__init__")
    reload(pb)
    size(W, H)
    background( 0.333 )
except NameError:
    import photobot as pb
    WIDTH, HEIGHT = W, H
RATIO = WIDTH / HEIGHT

# load the image library
# check for command line folders
additionals = sys.argv[1:]

</t>
<t tx="karstenw.20170711131604.2"># get all images from user image wells
imagewell = pb.loadImageWell(   bgsize=(W, H),
                                minsize=(256,256),
                                pathonly=True,
                                additionals=additionals)

</t>
<t tx="karstenw.20170711131604.3"># tiles are images &gt;256x256 and &lt;=1024x768
tiles = imagewell['tiles']

</t>
<t tx="karstenw.20170711131604.4"># backgrounds are images &gt;1024x768
backgrounds = imagewell['backgrounds']
rnd.shuffle(tiles)
rnd.shuffle(backgrounds)

print "tiles:", len(tiles)
print "backgrounds:", len(backgrounds)


# CONFIGURATION

# create the canvas
c = pb.canvas( WIDTH, HEIGHT)
c.fill( (85,85,85) )


# CONFIGURATION

columns = 5
rows = 3

randomblur = 0
randomflip = 0
paintoverlay = 0
gilb =0


# 
y_offset = HEIGHT / float(rows)
y_offset = int(round(y_offset))

x_offset = WIDTH / float(columns)

# 
if 1:
    bgimage = backgrounds.pop()
    top = c.layer(bgimage)
    w, h = c.top.bounds()
    hght = True
    if w &gt; h:
        h
    
    w1,h1 = pb.aspectRatio( (w,h), WIDTH, height=False, assize=True )
    c.top.scale(w1,h1)
else:
    bgimage = backgrounds.pop()
    pb.placeImage(c, bgimage, 0, 0, WIDTH, "bgimage")
print "Background:", bgimage.encode("utf-8")

idx = 0
</t>
<t tx="karstenw.20170711131604.5">
for j in range(rows):
    colw = 0
    for i in range(columns):
        idx += 1
        # new layer with a random image
        path = tiles.pop()
        print idx,path.encode("utf-8")
        top = c.layer( path )

        # get current image bounds
        w, h = c.top.bounds()

        # calculate scale &amp; apply
        s = pb.aspectRatio( (w,h), y_offset, height=True)
        c.top.scale(s, s)

        # uniform
        layer = pb.cropImageToRatioHorizontal( c.top, RATIO )

        # add contrast
        c.top.contrast(1.1)

        # get the new image bounds
        w, h = c.top.bounds()

        r = 0.4 
        r = rnd.random()
        # 10%
        if r &lt; 0.1:
            # create a dual ramp gradient
            _ = c.gradient(pb.LINEAR, w/2, h)
            c.top.flip( pb.HORIZONTAL )

            # layer translate half a pict right
            c.top.translate(w/2, j*y_offset)

            # create another gradient layer and merge with first gradient
            top = c.gradient(pb.LINEAR, w/2, h)
            # merge both gradients; destroys top layer
            c.merge([ top-1 , top ])
        elif 0.1 &lt;= r &lt; 0.5:
            #print "SINE"
            top = c.gradient(pb.SINE, w, h)
            
        elif 0.6 &lt;= r &lt; 0.75:
            #print "RADIALCOSINE"
            top = c.gradient(pb.RADIALCOSINE, w, h)
            c.top.invert()
        else:
            #print "ROUNDRECT"
            # 25%
            top = c.gradient(pb.ROUNDRECT, w, h, radius=int(w/5.0))

        c.top.brightness(1.4)

        # mask destroys top layer
        c.top.mask()
        
        # c.top.translate(colw+i*w, j*y_offset)
        c.top.translate(x_offset * i, j*y_offset)
        
        c.top.opacity( 66 + rnd.random() * 29 )

        if randomblur:
            if rnd.random() &gt; 0.5:
                c.top.flip()

            if rnd.random() &gt; 0.5:
                c.top.blur()

</t>
<t tx="karstenw.20170711131606.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170711131614.1"># heavily inspired by https://www.nodebox.net/code/index.php/Landslide
size(0, 0)
import sys, os

import pprint
pp = pprint.pprint

# need a different name
import random as rnd

background( 0.5 )

try:
    pb = ximport("photobot")
except ImportError:
    pb = ximport("__init__")
    reload(pb)


import pbhelpers

try:
    imagefiles
except NameError:
    import helper_for_older_nodebox
    imagefiles = helper_for_older_nodebox.imagefiles

c = pb.canvas(int(WIDTH), int(HEIGHT))

tiles = list(imagefiles( "/Library/Desktop Pictures" ))


columns = 8
rows = 4

# 
y_offset = HEIGHT / (rows+1)

# x_offset = WIDTH / (columns * 2)

enoughTiles = len(tiles) &gt; (columns*2*rows)

picts = []
for t in range(columns*rows*2):
    s = choice(tiles)
    picts.append(s)
    if enoughTiles:
        tiles.remove(s)

rnd.shuffle(picts)
nextpictpath = picts.pop()
currlayer = c.layer(nextpictpath, name="0001")
c.layers[currlayer].scale(0.2,0.2)



</t>
<t tx="karstenw.20170711131614.2">def topLayer( c ):
    # return top layer index
    return len(c.layers) -1

for j in range(rows):
    for i in range(columns):

        # create image in canvas at 0,0
        nextpictpath = picts.pop()
        # print repr(nextpictpath)

        c.layer( nextpictpath )

        nlayers = len(c.layers)
        lastIndex = topLayer( c )
        c.layers[lastIndex].scale(0.2,0.2)

        # add contrast
        c.layers[ lastIndex ].contrast(1.1)

        # get current image bounds
        w, h = c.layers[ lastIndex ].bounds()

        # create gradient layer
        c.gradient(pb.LINEAR, w/2, h)

        nlayers = len(c.layers)
        lastIndex = topLayer( c )

        # layer + 4 flip
        c.layers[ lastIndex ].flip()

        # layer +4 translate half a pict right
        c.layers[ lastIndex ].translate(w/2, j*y_offset)

        # create gradient layer
        c.gradient(pb.LINEAR, w/2, h)
        lastIndex = topLayer( c )

        # merge gradient with 
        c.merge([ lastIndex - 1 , lastIndex ])
        lastIndex = topLayer( c )

        c.layers[ lastIndex ].brightness(1.4)
        
        c.layers[ lastIndex ].mask()
        lastIndex = topLayer( c )

        c.layers[ lastIndex ].translate(i*w/3, j*y_offset)

        if random() &gt; 0.5:
            c.layers[ lastIndex ].flip()

        if random() &gt; 0.5:
            c.layers[ lastIndex ].blur()

c.draw(10, 10)
</t>
<t tx="karstenw.20170711131616.1">@others
if 0:
    # orange hue mask finish
    #print "Mr. Orange"
    top = c.fill((200,100,0))
    c.top.opacity(30)
    c.top.hue()

if paintoverlay:
    # paint overlay
    #print "VINCENT"
    top = c.layer( os.path.abspath("./paint.jpg") )
    w, h = c.top.bounds()
    xs = WIDTH / float(w)
    ys = HEIGHT / float(h)
    s = max(xs,ys)
    c.top.scale(s, s)
    c.top.opacity(50)
    c.top.overlay()

c.draw(0, 0)
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170711131630.1"># heavily inspired by https://www.nodebox.net/code/index.php/Landslide

import sys
import os

W,H = 1920, 1080
RATIO = W / H

kwdbg = False

size(W, H)

background( 0.333 )

# need a different name; random is taken
import random as rnd

if kwdbg:
    # make random choices repeatable for debugging
    rnd.seed(0)

# import photobot
try:
    pb = ximport("photobot")
    pbh = ximport("pbhelpers")
except ImportError:
    pb = ximport("__init__")
    reload(pb)

# from pbhelpers import *


# create the canvas
c = pb.canvas(int(WIDTH), int(HEIGHT))

# load the image library
# check for command line folders
additionals = sys.argv[1:]

# get all images from user image wells
imagewell = pb.loadImageWell(   bgsize=(W,H),
                                minsize=(256,256),
                                pathonly=True,
                                additionals=additionals)

# tiles are images &gt;256x256 and &lt;=1024x768
tiles = imagewell['tiles']

# backgrounds are images &gt;1024x768
backgrounds = imagewell['backgrounds']
rnd.shuffle(tiles)
rnd.shuffle(backgrounds)

print "tiles:", len(tiles)
print "backgrounds:", len(backgrounds)


bgimage = backgrounds.pop()
</t>
<t tx="karstenw.20170711131630.2">

# CONFIGURATION
columns = 5
rows = 3

colwidth = int(WIDTH / columns)
rowheight = int(HEIGHT / rows)
maxsize = int(max(colwidth,rowheight)*1.2)

# print "colwidth/rowheight:", colwidth, rowheight

xgutter = colwidth * 0.0667
ygutter = rowheight * 0.0667
# print "xgutter/ygutter:", xgutter, ygutter

realwidth = colwidth - 1*xgutter
realheight = rowheight - 1*ygutter 

positions = list(grid(columns, rows, colwidth, rowheight))

randomblur = not kwdbg
paintoverlay = not kwdbg


#
# Base Image
#

#  create, scale and place the image
x, y = 0, 0
top, w, h = pb.placeImage(c, bgimage, x, y, W, "Image 1")


for position in positions:
    x, y = position


    # create image in canvas at 0,0
    p = tiles.pop()
    print p
    top, w, h = pb.placeImage(c, p, 0, 0, maxsize, "Image %i,%i" % (x,y))

    # scale the layer to row height
    pb.scaleLayerToHeight( c.top, rowheight )

    # uniform width
    #cropImageToRatioHorizontal( c.top, RATIO )

    # get the new image bounds - layer still valid
    w, h = c.top.bounds()

    # add contrast - layer still valid
    c.top.contrast(1.1)


    r = rnd.random()
    # 10%
    if 0 &lt; r &lt; 0.2:
        #print "20% LINEAR"
        # create gradient layer
        # top is now gradient index
        c.gradient(pb.LINEAR, w/2, h)
        c.top.flip( pb.HORIZONTAL )

        # translate half a pict right
        c.top.translate(w/2, 0)

        # create gradient layer
        # top is now second gradient image
        topidx = c.gradient(pb.LINEAR, w/2, h)

        # merge both gradients; destroys top layer
        c.merge([ topidx-1 , topidx ])

    elif 0.2 &lt;= r &lt; 0.4:
        #print "20% SINE"
        top = c.gradient(pb.SINE, w, h)
        
    elif 0.4 &lt;= r &lt; 0.6:
        #print "20% RADIALCOSINE"
        top = c.gradient(pb.RADIALCOSINE, w, h)
        # c.top.invert()
    elif 0.6 &lt;= r &lt; 0.8:
        #print "20% ROUNDRECT"
        # 25%
        top = c.gradient(pb.ROUNDRECT, w, h, "", radius=w/5.0, radius2=w/5.0)
    elif r &gt;= 0.8:
        #print "20% QUAD"
        top = c.gradient(pb.QUAD, w, h, "", 0, 0)
            
    # enhance mask
    c.top.brightness(1.4)
    c.top.mask()

    # top layer is now image with mask

    destx = x - xgutter
    desty = y - ygutter
    # print "Image@", x, y
    # c.top.translate(destx, desty)
    c.top.translate(x, y)

    if randomblur:
        if rnd.random() &gt; 0.75:
            #print "FLIP"
            c.top.flip()

        if rnd.random() &gt; 0.75:
            #print "BLUR"
            c.top.blur()

</t>
<t tx="karstenw.20170715181646.1">@language python
@tabwidth -4
@others
W,H = 542, 1050
&lt;&lt;initialisation&gt;&gt;

&lt;&lt;image1&gt;&gt;

&lt;&lt;image2&gt;&gt;

#
# Hue Images 1 &amp; 2
#

&lt;&lt;image34&gt;&gt;

c.layers[top].hue()
label("Hue Image2 over Image1", x, y)

#
# Hue Images 2 &amp; 1
#

&lt;&lt;image56&gt;&gt;

c.top.hue()
label("Hue Image1 over Image2", x, y)

&lt;&lt;outro&gt;&gt;
</t>
<t tx="karstenw.20170715185201.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170715185207.1">size(512,512)
background(0.334)
pb = ximport("photobot")
reload(pb)

pbh = ximport("pbhelpers")
label = pbh.label


</t>
<t tx="karstenw.20170715185207.2">def dogradient(s):
    sx, sy = WIDTH, HEIGHT
    inset = 10
    c = pb.canvas(sx, sy)
    #c.fill((210, 210, 10))
    c.fill((85, 85, 85))
    r1, r2 = 72, 36
    x, y = inset, inset
    w, h = sx-inset-inset, sy-inset-inset
    grad1idx = c.gradient(s, w, h, radius=r1, radius2=r2)
    mask = c.gradient(s, w, h, radius=r1, radius2=r2)
    c.layers[mask].mask()
    c.layers[grad1idx].translate(x, y)
    label(s.upper(), x, y)
    c.draw(1, 1)
    canvas._grobs.reverse()

gradients = (
    pb.SOLID,
    pb.LINEAR,
    pb.RADIAL,
    pb.DIAMOND,
    pb.SINE,
    pb.COSINE,
    pb.ROUNDRECT,
    pb.RADIALCOSINE,
    pb.QUAD)


var("Gradient", MENU, default=dogradient, value=gradients)

dogradient("solid")
</t>
</tnodes>
</leo_file>
