<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="karstenw.20170709210040.1" a="E"><vh>@clean ../__init__.py</vh>
<v t="karstenw.20170709210125.1"><vh>Declarations</vh></v>
<v t="karstenw.20170709210125.2"><vh>hashFromString</vh></v>
<v t="karstenw.20170709210125.3"><vh>datestring</vh></v>
<v t="karstenw.20170709210125.4"><vh>invertimage</vh></v>
<v t="karstenw.20170727231657.1"><vh>cropimage</vh></v>
<v t="karstenw.20170709210125.5"><vh>class Canvas</vh>
<v t="karstenw.20170709210125.6"><vh>__init__</vh></v>
<v t="karstenw.20170709210125.7"><vh>layer</vh></v>
<v t="karstenw.20170709210125.8"><vh>fill</vh></v>
<v t="karstenw.20170709210125.9"><vh>makegradientimage</vh></v>
<v t="karstenw.20170709210125.10"><vh>gradient</vh></v>
<v t="karstenw.20170709210125.11"><vh>merge</vh></v>
<v t="karstenw.20170709210125.12"><vh>flatten</vh></v>
<v t="karstenw.20170709210125.13"><vh>export</vh></v>
<v t="karstenw.20170709210125.14"><vh>draw</vh></v>
<v t="karstenw.20170709210125.15"><vh>preferences</vh></v>
<v t="karstenw.20170710142919.1"><vh>topLayer</vh></v>
</v>
<v t="karstenw.20170709210125.16"><vh>canvas</vh></v>
<v t="karstenw.20170709210125.17"><vh>class Layers</vh>
<v t="karstenw.20170709210125.18"><vh>__getitem__</vh></v>
<v t="karstenw.20170709210125.19"><vh>_get_bg</vh></v>
<v t="karstenw.20170709210125.20"><vh>_set_bg</vh></v>
</v>
<v t="karstenw.20170709210125.21"><vh>class Layer</vh>
<v t="karstenw.20170709210125.22"><vh>__init__</vh></v>
<v t="karstenw.20170709210125.23"><vh>prnt</vh></v>
<v t="karstenw.20170709210125.24"><vh>index</vh></v>
<v t="karstenw.20170709210125.25"><vh>copy</vh></v>
<v t="karstenw.20170709210125.26"><vh>delete</vh></v>
<v t="karstenw.20170709210125.27"><vh>up</vh></v>
<v t="karstenw.20170709210125.28"><vh>down</vh></v>
<v t="karstenw.20170709210125.29"><vh>bounds</vh></v>
<v t="karstenw.20170709210125.30"><vh>select</vh></v>
<v t="karstenw.20170709210125.31"><vh>mask</vh></v>
<v t="karstenw.20170709210125.32"><vh>duplicate</vh></v>
<v t="karstenw.20170727231803.1"><vh>BLENDS</vh>
<v t="karstenw.20170709210125.33"><vh>opacity</vh></v>
<v t="karstenw.20170709210125.34"><vh>multiply</vh></v>
<v t="karstenw.20170709210125.35"><vh>screen</vh></v>
<v t="karstenw.20170709210125.36"><vh>overlay</vh></v>
<v t="karstenw.20170709210125.37"><vh>hue</vh></v>
<v t="karstenw.20170709210125.38"><vh>color</vh></v>
</v>
<v t="karstenw.20170727231827.1"><vh>INTENSITIES</vh>
<v t="karstenw.20170709210125.39"><vh>brightness</vh></v>
<v t="karstenw.20170709210125.40"><vh>contrast</vh></v>
<v t="karstenw.20170709210125.41"><vh>desaturate</vh></v>
<v t="karstenw.20170709210125.42"><vh>colorize</vh></v>
</v>
<v t="karstenw.20170709210125.43"><vh>invert</vh></v>
<v t="karstenw.20170727232236.1" a="E"><vh>GEOMETRY</vh>
<v t="karstenw.20170709210125.44"><vh>translate</vh></v>
<v t="karstenw.20170709210125.45"><vh>scale</vh></v>
<v t="karstenw.20170709210125.47"><vh>rotate</vh></v>
<v t="karstenw.20170709210125.46"><vh>distort</vh></v>
<v t="karstenw.20170709210125.48"><vh>flip</vh></v>
<v t="karstenw.20170727233343.1"><vh>crop</vh></v>
</v>
<v t="karstenw.20170727232434.1"><vh>autocontrast</vh></v>
<v t="karstenw.20170709210125.49"><vh>blur</vh></v>
<v t="karstenw.20170709210125.50"><vh>sharpen</vh></v>
<v t="karstenw.20170709210125.51"><vh>statistics</vh></v>
<v t="karstenw.20170709210125.52"><vh>levels</vh></v>
</v>
<v t="karstenw.20170709210125.53"><vh>class Blend</vh>
<v t="karstenw.20170709210125.54"><vh>overlay</vh></v>
<v t="karstenw.20170709210125.55"><vh>hue</vh></v>
<v t="karstenw.20170709210125.56"><vh>color</vh></v>
</v>
<v t="karstenw.20170709210125.57"><vh>class Pixels</vh>
<v t="karstenw.20170709210125.58"><vh>__init__</vh></v>
<v t="karstenw.20170709210125.59"><vh>__getitem__</vh></v>
<v t="karstenw.20170709210125.60"><vh>__setitem__</vh></v>
<v t="karstenw.20170709210125.61"><vh>__iter__</vh></v>
<v t="karstenw.20170709210125.62"><vh>__len__</vh></v>
<v t="karstenw.20170709210125.63"><vh>update</vh></v>
<v t="karstenw.20170709210125.64"><vh>convolute</vh></v>
</v>
<v t="karstenw.20170709210125.65"><vh>aspectRatio</vh></v>
<v t="karstenw.20170709210125.66"><vh>normalizeOrientationImage</vh></v>
<v t="karstenw.20170709210125.67"><vh>resizeImage</vh></v>
</v>
<v t="karstenw.20170709210102.1"><vh>examples</vh>
<v t="karstenw.20170709210735.1"><vh>@clean explore_gradients 1.py</vh>
<v t="karstenw.20170709210910.1"><vh>Declarations</vh></v>
</v>
<v t="karstenw.20170715185201.1"><vh>@clean explore_gradients 2.py</vh>
<v t="karstenw.20170715185207.1"><vh>Declarations</vh></v>
<v t="karstenw.20170715185207.2"><vh>dogradient</vh></v>
</v>
<v t="karstenw.20170709211002.1"><vh>@clean Layer_colorize.py</vh>
<v t="karstenw.20170709211010.1"><vh>Declarations</vh>
<v t="karstenw.20170710094409.1"><vh>&lt;&lt;initialisation&gt;&gt;</vh></v>
</v>
</v>
<v t="karstenw.20170710094259.1"><vh>@clean Layer_function_screen.py</vh>
<v t="karstenw.20170710094319.1"><vh>Declarations</vh>
<v t="karstenw.20170710094409.1"></v>
<v t="karstenw.20170710105816.1"><vh>&lt;&lt;image1&gt;&gt;</vh></v>
<v t="karstenw.20170710105845.1"><vh>&lt;&lt;image2&gt;&gt;</vh></v>
<v t="karstenw.20170710105940.1"><vh>&lt;&lt;image34&gt;&gt;</vh></v>
<v t="karstenw.20170710105956.1"><vh>&lt;&lt;image56&gt;&gt;</vh></v>
<v t="karstenw.20170710110147.1"><vh>&lt;&lt;outro&gt;&gt;</vh></v>
</v>
</v>
<v t="karstenw.20170710105607.1"><vh>@clean Layer_function_overlay.py</vh>
<v t="karstenw.20170710105617.1"><vh>Declarations</vh>
<v t="karstenw.20170710094409.1"></v>
<v t="karstenw.20170710105816.1"></v>
<v t="karstenw.20170710105845.1"></v>
<v t="karstenw.20170710105940.1"></v>
<v t="karstenw.20170710105956.1"></v>
<v t="karstenw.20170710110147.1"></v>
</v>
</v>
<v t="karstenw.20170710113238.1"><vh>@clean Layer_function_brightness.py</vh>
<v t="karstenw.20170710094409.1"></v>
</v>
<v t="karstenw.20170710113905.1"><vh>@clean Layer_function_color.py</vh>
<v t="karstenw.20170710113922.1"><vh>Declarations</vh>
<v t="karstenw.20170710094409.1"></v>
<v t="karstenw.20170710105816.1"></v>
<v t="karstenw.20170710105845.1"></v>
<v t="karstenw.20170710105940.1"></v>
<v t="karstenw.20170710105956.1"></v>
<v t="karstenw.20170710110147.1"></v>
</v>
</v>
<v t="karstenw.20170710122812.1"><vh>@clean Layer_function_mask.py</vh>
<v t="karstenw.20170710122823.1"><vh>Declarations</vh>
<v t="karstenw.20170710094409.1"></v>
<v t="karstenw.20170710105816.1"></v>
<v t="karstenw.20170710105845.1"></v>
<v t="karstenw.20170710110147.1"></v>
</v>
</v>
<v t="karstenw.20170710130259.1"><vh>@clean Layer_function_opacity.py</vh>
<v t="karstenw.20170710134831.1"><vh>&lt;&lt;initialisation&gt;&gt;</vh></v>
</v>
<v t="karstenw.20170710134714.1"><vh>@clean Layer_function_contrast.py</vh>
<v t="karstenw.20170710094409.1"></v>
</v>
<v t="karstenw.20170710140437.1"><vh>@clean Layer_function_flip.py</vh>
<v t="karstenw.20170710094409.1"></v>
<v t="karstenw.20170710110147.1"></v>
</v>
<v t="karstenw.20170715181646.1"><vh>@clean Layer_function_hue.py</vh>
<v t="karstenw.20170710094409.1"></v>
<v t="karstenw.20170710105816.1"></v>
<v t="karstenw.20170710105845.1"></v>
<v t="karstenw.20170710105940.1"></v>
<v t="karstenw.20170710105956.1"></v>
<v t="karstenw.20170710110147.1"></v>
</v>
<v t="karstenw.20170711131553.1"><vh>@clean Example collage 1.py</vh>
<v t="karstenw.20170711131604.1"><vh>Declarations</vh></v>
<v t="karstenw.20170711131604.2"><vh>cropImageToRatioHorizontal</vh></v>
<v t="karstenw.20170711131604.3"><vh>insetRect</vh></v>
<v t="karstenw.20170711131604.4"><vh>aspectRatio</vh></v>
<v t="karstenw.20170711131604.5"><vh>topLayer</vh></v>
</v>
<v t="karstenw.20170711131606.1"><vh>@clean Example collage 2.py</vh>
<v t="karstenw.20170711131614.1"><vh>Declarations</vh></v>
<v t="karstenw.20170711131614.2"><vh>topLayer</vh></v>
</v>
<v t="karstenw.20170711131616.1"><vh>@clean Example collage 3.py</vh>
<v t="karstenw.20170711131630.1"><vh>Declarations</vh></v>
<v t="karstenw.20170711131630.2"><vh>placeImage</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="karstenw.20170709210040.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170709210102.1"></t>
<t tx="karstenw.20170709210125.1"># PhotoBot 0.8 beta - last updated for NodeBox 1rc4 
# Author: Tom De Smedt &lt;tomdesmedt@trapdoor.be&gt;
# Manual: http://nodebox.net/code/index.php/PhotoBot
# Copyright (c) 2006 by Tom De Smedt.
# Refer to the "Use" section on http://nodebox.net/code/index.php/Use


import sys
import os
import types
FloatType = types.FloatType
StringType = types.StringType


import math
sqrt = math.sqrt
pow = math.pow
sin = math.sin
cos = math.cos
degrees = math.degrees
radians = math.radians
asin = math.asin

import datetime
import time
import hashlib

import colorsys

import pdb
import pprint
pp = pprint.pprint

import PIL
import PIL.ImageFilter as ImageFilter
import PIL.Image as Image
import PIL.ImageChops as ImageChops
import PIL.ImageEnhance as ImageEnhance
import PIL.ImageOps as ImageOps
import PIL.ImageDraw as ImageDraw
import PIL.ImageStat as ImageStat

# PIL interpolation modes
NEAREST = Image.NEAREST
BICUBIC = Image.BICUBIC
BILINEAR = Image.BILINEAR
LANCZOS = Image.LANCZOS
INTERPOLATION = Image.BICUBIC

LAYERS = []

# blend modes
NORMAL = "normal"
MULTIPLY = "multiply"
SCREEN = "screen"
OVERLAY = "overlay"
HUE = "hue"
COLOR = "color"

HORIZONTAL = 1
VERTICAL = 2

SOLID = "solid"
LINEAR = "linear"
RADIAL = "radial"
DIAMOND = "diamond"
COSINE = "cosine"
SINE = "sine"
ROUNDRECT = "roundrect"
RADIALCOSINE = "radialcosine"
QUAD = "quad"


</t>
<t tx="karstenw.20170709210125.10">def gradient(self, style=LINEAR, w=1.0, h=1.0, name="", radius=0, radius2=0):

    """Creates a gradient layer.

    Creates a gradient layer, that is usually used together
    with the mask() function.

    All the image functions work on gradients, so they can
    easily be flipped, rotated, scaled, inverted, made brighter
    or darker, ...

    Styles for gradients are LINEAR, RADIAL, DIAMOND, SINE,
    COSINE and ROUNDRECT
    """

    w0 = self.w
    h0 = self.h
    if type(w) == FloatType:
        w = int(w*w0)
    if type(h) == FloatType:
        h = int(h*h0)

    img = None
    if style in (SOLID, LINEAR, RADIAL, DIAMOND, SINE, COSINE, RADIALCOSINE):
        img = self.makegradientimage(style, w, h)
        img = img.convert("RGBA")
        return self.layer(img, 0, 0, name=name)

    if style == QUAD:
        # make a rectangle with softened edges
        result = Image.new("L", (int(w),int(h)), 255)
        
        # 
        mask = Image.new("L", (w,h), 255)
        draw = ImageDraw.Draw(mask)

        if radius == 0 and radius2 == 0:
            radius = w / 4.0
            radius2 = w / 10.0

        r1 = int(round(radius,0))
        r2 = int(round(radius2,0))
        
        if r1 == 0:
            r1 = 1
        if r2 == 0:
            r2 = 1
        d1 = 2 * r1
        d2 = 2 * r2

        # create the base rect
        baserect = self.makegradientimage(SOLID, w-d1, h-d2)
        
        # create the vertical gradients
        verleft = self.makegradientimage(COSINE, r1, h)
        verleft = verleft.transpose(Image.FLIP_LEFT_RIGHT)
        vertright = verleft.rotate( 180 )

        # create the horizontal gradients
        # since LINEAR goes from left to right, 
        horup = self.makegradientimage(COSINE, r2, w)
        horup = horup.transpose(Image.FLIP_LEFT_RIGHT)
        hordown = horup.rotate( -90, expand=1 )
        horup = hordown.rotate( 180 )

        # assemble
        result.paste( baserect, box=( r1,     0) )
        result.paste( verleft,  box=( 0,      0) )
        result.paste( vertright,box=( w-r1,   0) )

        mask.paste( hordown,  box=( 0,     0) )
        mask.paste( horup,    box=( 0,     h-r2) )

        result = ImageChops.darker(result, mask)
        result = result.convert("RGBA")
        del mask
        del horup
        del hordown
        del baserect
        del verleft
        del vertright
        return self.layer(result, 0, 0, name=name)

    if style == ROUNDRECT:
        result = Image.new("L", (int(w),int(h)), 255)
        r1 = int(round(radius))
        r2 = int(round(radius2))
        if r1==0: r1=1
        if r2==0: r2=1
        d1 = 2 * r1
        d2 = 2 * r2

        # take 1 radial grad for the 4 corners
        corners = self.makegradientimage(RADIALCOSINE, d1, d2)
        # corners = invertimage( corners )

        # top left
        b = corners.copy()
        tl = b.crop( box=(0,0,r1,r2) )

        # top right
        b = corners.copy()
        tr = b.crop( box=(r1,0,d1,r2) )

        # bottom left
        b = corners.copy()
        bl = b.crop( box=(0,r2,r1,d2) )

        # bottom right
        b = corners.copy()
        br = b.crop( box=(r1,r2,d1,d2) )

        # create the base rect
        brw = w - d1
        brh = h - d2
        baserect = self.makegradientimage(SOLID, brw, brh)
        
        # create the vertical gradients
        verleft = self.makegradientimage(COSINE, r1, brh)
        verleft = verleft.transpose(Image.FLIP_LEFT_RIGHT)
        vertright = verleft.rotate( 180 )

        # create the horizontal gradients
        # since LINEAR goes from left to right, 
        horup = self.makegradientimage(COSINE, r2, brw)
        horup = horup.transpose(Image.FLIP_LEFT_RIGHT)
        hordown = horup.rotate( -90, expand=1 )
        horup = hordown.rotate( 180 )

        # assemble
        result.paste( baserect, box=( r1,     r2) )

        result.paste( hordown,    box=( r1,     0) )
        result.paste( horup,  box=( r1,     brh+r2) )

        result.paste( verleft,  box=( 0,     r2) )
        result.paste( vertright,box=( brw+r1, r2) )

        result.paste( tl,       box=( 0,     0) )
        result.paste( tr,       box=( brw+r1, 0) )
        result.paste( bl,       box=( 0,     brh+r2) )
        result.paste( br,       box=( brw+r1, brh+r2) )
        img = result.convert("RGBA")
        del corners, tl, tr, bl, br, b
        del horup
        del hordown
        del baserect
        del verleft
        del vertright
        return self.layer(img, 0, 0, name=name)


</t>
<t tx="karstenw.20170709210125.11">def merge(self, layers):
    
    """Flattens the given layers on the canvas.
    
    Merges the given layers with the indices in the list
    on the bottom layer in the list.
    The other layers are discarded.
    
    """
    
    layers.sort()
    if layers[0] == 0: del layers[0]
    self.flatten(layers)


</t>
<t tx="karstenw.20170709210125.12">def flatten(self, layers=[]):

    """Flattens all layers according to their blend modes.

    Merges all layers to the canvas,
    using the blend mode and opacity defined for each layer.
    Once flattened, the stack of layers is emptied except
    for the transparent background (bottom layer).
    """
    
    #When the layers argument is omitted,
    #flattens all the layers on the canvas.
    #When given, merges the indexed layers.
    
    #Layers that fall outside of the canvas are cropped:
    #this should be fixed by merging to a transparent background
    #large enough to hold all the given layers' data
    #(=time consuming).
    
    if layers == []: 
        layers = range(1, len(self.layers))
    background = self.layers._get_bg()
    background.name = "Background"
    
    for i in layers:

        layer = self.layers[i]
    
        #Determine which portion of the canvas
        #needs to be updated with the overlaying layer.
    
        x = max(0, layer.x)
        y = max(0, layer.y)
        w = min(background.w, layer.x+layer.w)
        h = min(background.h, layer.y+layer.h)
    
        base = background.img.crop((x, y, w, h))

        #Determine which piece of the layer
        #falls within the canvas.

        x = max(0, -layer.x)
        y = max(0, -layer.y)
        w -= layer.x
        h -= layer.y

        blend = layer.img.crop((x, y, w, h))
    
        #Buffer layer blend modes:
        #the base below is a flattened version
        #of all the layers below this one,
        #on which to merge this blended layer.
    
        if layer.blend == NORMAL:
            buffer = blend
        if layer.blend == MULTIPLY:
            buffer = ImageChops.multiply(base, blend)
        if layer.blend == SCREEN:
            buffer = ImageChops.screen(base, blend)
        if layer.blend == OVERLAY:
            buffer = Blend().overlay(base, blend)
        if layer.blend == HUE:
            buffer = Blend().hue(base, blend)
        if layer.blend == COLOR:
            buffer = Blend().color(base, blend)
        
        #Buffer a merge between the base and blend
        #according to the blend's alpha channel:
        #the base shines through where the blend is less opaque.
    
        #Merging the first layer to the transparent canvas
        #works slightly different than the other layers.
    
        alpha = buffer.split()[3]
        if i == 1:
            buffer = Image.composite(base, buffer, base.split()[3])
        else:
            buffer = Image.composite(buffer, base, alpha)
    
        #The alpha channel becomes a composite of
        #this layer and the base:
        #the base's (optional) tranparent background
        #is retained in arrays where the blend layer
        #is transparent as well.
    
        alpha = ImageChops.lighter(alpha, base.split()[3])
        buffer.putalpha(alpha)
    
        #Apply the layer's opacity,
        #merging the buffer to the base with
        #the given layer opacity.
    
        base = Image.blend(base, buffer, layer.alpha)

        #Merge the base to the flattened canvas.

        x = max(0, int(layer.x))
        y = max(0, int(layer.y))
        background.img.paste(base, (x,y))
        del base, buffer, alpha, blend

    layers.reverse()
    for i in layers:
        del self.layers[i].img
        del self.layers[i]

    img = Image.new("RGBA", (self.w,self.h), (255,255,255,0))
    self.layers._set_bg(Layer(self, img, 0, 0, name="_bg"))
    
    if len(self.layers) == 1:
        self.layers.append(background)
    else:
        self.layers.insert(layers[-1], background)
    
</t>
<t tx="karstenw.20170709210125.13">def export(self, filename):

    """Exports the flattened canvas.

    Flattens the canvas.
    PNG retains the alpha channel information.
    Other possibilities are JPEG and GIF.

    """

    self.flatten()
    self.layers[1].img.save(filename, format="PNG")
    return filename
    
</t>
<t tx="karstenw.20170709210125.14">def draw(self, x, y):
    
    """Places the flattened canvas in NodeBox.
    
    Exports to a temporary PNG file.
    Draws the PNG in NodeBox using the image() command.
    Removes the temporary file.
    
    """
    
    try:
        filename = "photobot_" + datestring() + ".png"
        filename = os.path.abspath(filename)
        self.export(filename)
        _ctx.image(filename, x, y)
        os.unlink(filename)
    except Exception, err:
        print err

</t>
<t tx="karstenw.20170709210125.15">def preferences(interpolation=INTERPOLATION):

    """Settings that influence image manipulation.

    Currently, only defines the image interpolation, which
    can be set to NEAREST, BICUBIC, BILINEAR or LANCZOS.

    """

    self.interpolation = interpolation
    
</t>
<t tx="karstenw.20170709210125.16">def canvas(w, h):
    return Canvas(w, h)
    
</t>
<t tx="karstenw.20170709210125.17">class Layers(list):
    
    """Extends the canvas.layers[] list so it indexes layers names.
    
    When the index is an integer, returns the layer at that  index.
    When the index is a string, returns the first layer with that name.
    
    The first element, canvas.layers[0],
    is the transparent background and must remain untouched.
    
    """
    
    @others
</t>
<t tx="karstenw.20170709210125.18">def __getitem__(self, index):

    if type(index) in (int, long):
        return list.__getitem__(self, index)

    elif type(index) in (str, unicode):
        for layer in self:
            if layer.name == index:
                return layer
    return None

</t>
<t tx="karstenw.20170709210125.19">def _get_bg(self):
    
    return list.__getitem__(self, 0)
    
</t>
<t tx="karstenw.20170709210125.2">def hashFromString( s ):
    h = hashlib.sha1()
    h.update( s )
    return h.hexdigest()

</t>
<t tx="karstenw.20170709210125.20">def _set_bg(self, layer):
    
    list.__setitem__(self, 0, layer)

</t>
<t tx="karstenw.20170709210125.21">class Layer:
    
    """Implements a layer on the canvas.
    
    A canvas layer stores an image at a given position on the canvas,
    and all the Photoshop transformations possible for this layer:
    duplicate(), desature(), overlay(), rotate(), and so on.
    
    """
    
    @others
</t>
<t tx="karstenw.20170709210125.22">def __init__(self, canvas, img, x=0, y=0, name=""):
    
    self.canvas = canvas
    self.name = name
    self.img = img
    self.x = x
    self.y = y
    self.w = img.size[0]
    self.h = img.size[1]
    self.alpha = 1.0
    self.blend = NORMAL
    self.pixels = Pixels(self.img, self)
    

</t>
<t tx="karstenw.20170709210125.23">def prnt(self):
    # for debugging
    print "-" * 20
    print "name:", self.name
    print "xy:", self.x, self.y
    print "wh:", self.w, self.h
    print "alpha:", self.alpha
    print "blend:", self.blend
    print "-" * 20

</t>
<t tx="karstenw.20170709210125.24">def index(self):
    
    """Returns this layer's index in the canvas.layers[].
    
    Searches the position of this layer in the canvas'
    layers list, return None when not found.
    
    """
    
    for i in range(len(self.canvas.layers)):
        if self.canvas.layers[i] == self: break
    if self.canvas.layers[i] == self: 
        return i
    else:
        return None
        
</t>
<t tx="karstenw.20170709210125.25">def copy(self):
    
    """Returns a copy of the layer.
    
    This is different from the duplicate() method,
    which duplicates the layer as a new layer on the canvas.
    The copy() method returns a copy of the layer
    that can be added to a different canvas.
    
    """
    
    layer = Layer(None, self.img.copy(), self.x, self.y, self.name)
    layer.w = self.w
    layer.h = self.h
    layer.alpha = self.alpha
    layer.blend = self.blend
    
    return layer
    
</t>
<t tx="karstenw.20170709210125.26">def delete(self):
    
    """Removes this layer from the canvas.
          
    """
    
    i = self.index()
    if i != None: del self.canvas.layers[i]
    
</t>
<t tx="karstenw.20170709210125.27">def up(self):
    
    """Moves the layer up in the stacking order.
    
    """
    
    i = self.index()
    if i != None:
        del self.canvas.layers[i]
        i = min(len(self.canvas.layers), i+1)
        self.canvas.layers.insert(i, self)
        
</t>
<t tx="karstenw.20170709210125.28">def down(self):
    
    """Moves the layer down in the stacking order.
    
    """
    
    i = self.index()
    if i != None:
        del self.canvas.layers[i]
        i = max(0, i-1)
        self.canvas.layers.insert(i, self)

</t>
<t tx="karstenw.20170709210125.29">def bounds(self):

    """Returns the size of the layer.

    This is the width and height of the bounding box,
    the invisible rectangle around the layer.

    """

    return self.img.size

</t>
<t tx="karstenw.20170709210125.3">def datestring(dt = None, dateonly=False, nospaces=True, nocolons=True):
    """Make an ISO datestring. The defaults are good for using the result of
    'datestring()' in a filename.
    """
    if not dt:
        now = str(datetime.datetime.now())
    else:
        now = str(dt)
    if not dateonly:
        now = now[:19]
    else:
        now = now[:10]
    if nospaces:
        now = now.replace(" ", "_")
    if nocolons:
        now = now.replace(":", "")
    return now


</t>
<t tx="karstenw.20170709210125.30">def select(self, path, feather=True):

    """Applies the polygonal lasso tool on a layer.

    The path paramater is a list of points,
    either [x1, y1, x2, y2, x3, y3, ...]
    or [(x1,y1), (x2,y2), (x3,y3), ...]

    The parts of the layer that fall outside
    this polygonal area are cut.
    
    The selection is not anti-aliased,
    but the feather parameter creates soft edges.

    """

    w, h = self.img.size
    mask = Image.new("L", (w,h), 0)
    draw = ImageDraw.Draw(mask)
    
    draw = ImageDraw.Draw(mask)
    draw.polygon(path, fill=255)

    if feather:
        mask = mask.filter(ImageFilter.SMOOTH_MORE)
        mask = mask.filter(ImageFilter.SMOOTH_MORE)
        
    mask = ImageChops.darker(mask, self.img.split()[3])
    self.img.putalpha(mask)

</t>
<t tx="karstenw.20170709210125.31">def mask(self):

    """Masks the layer below with this layer.

    Commits the current layer to the alpha channel of 
    the previous layer. Primarily, mask() is useful when 
    using gradient layers as masks on images below. 

    For example:
    canvas.layer("image.jpg")
    canvas.gradient()
    canvas.layer(2).flip()
    canvas.layer(2).mask()

    Adds a white-to-black linear gradient to
    the alpha channel of image.jpg, 
    making it evolve from opaque on 
    the left to transparent on the right.

    """

    if len(self.canvas.layers) &lt; 2:
        return
    i = self.index()
    if i == 0:
        return
    
    layer = self.canvas.layers[i-1]

    alpha = Image.new("L", layer.img.size, 0)

    #Make a composite of the mask layer in grayscale
    #and its own alpha channel.

    mask = self.canvas.layers[i]        
    flat = ImageChops.darker(mask.img.convert("L"), mask.img.split()[3])
    alpha.paste(flat, (mask.x,mask.y))
    alpha = ImageChops.darker(alpha, layer.img.split()[3])
    layer.img.putalpha(alpha)

    self.delete()

</t>
<t tx="karstenw.20170709210125.32">def duplicate(self):

    """Creates a copy of the current layer.

    This copy becomes the top layer on the canvas.

    """

    i = self.canvas.layer(self.img.copy(), self.x, self.y, self.name)
    clone = self.canvas.layers[i]
    clone.alpha = self.alpha
    clone.blend = self.blend
                
</t>
<t tx="karstenw.20170709210125.33">def opacity(self, a=100):

    self.alpha = a * 0.01

</t>
<t tx="karstenw.20170709210125.34">def multiply(self):

    self.blend = MULTIPLY

</t>
<t tx="karstenw.20170709210125.35">def screen(self):

    self.blend = SCREEN

</t>
<t tx="karstenw.20170709210125.36">def overlay(self):

    self.blend = OVERLAY
    
</t>
<t tx="karstenw.20170709210125.37">def hue(self):

    self.blend = HUE
    
</t>
<t tx="karstenw.20170709210125.38">def color(self):

    self.blend = COLOR
    
</t>
<t tx="karstenw.20170709210125.39">def brightness(self, value=1.0):

    """Increases or decreases the brightness in the layer.

    The given value is a percentage to increase
    or decrease the image brightness,
    for example 0.8 means brightness at 80%.

    """
    if value &gt; 5:
        value = value * 0.01
    b = ImageEnhance.Brightness(self.img) 
    self.img = b.enhance(value)

</t>
<t tx="karstenw.20170709210125.4">def invertimage( img ):
    alpha = img.split()[3]
    img = img.convert("RGB")
    img = ImageOps.invert(img)
    img = img.convert("RGBA")
    img.putalpha(alpha)
    return img


</t>
<t tx="karstenw.20170709210125.40">def contrast(self, value=1.0):

    """Increases or decreases the contrast in the layer.

    The given value is a percentage to increase
    or decrease the image contrast,
    for example 1.2 means contrast at 120%.

    """

    if value &gt; 5:
        value = value * 0.01
    c = ImageEnhance.Contrast(self.img) 
    self.img = c.enhance(value) 

</t>
<t tx="karstenw.20170709210125.41">def desaturate(self):

    """Desaturates the layer, making it grayscale.

    Instantly removes all color information from the layer,
    while maintaing its alpha channel.

    """

    alpha = self.img.split()[3]
    self.img = self.img.convert("L")
    self.img = self.img.convert("RGBA")
    self.img.putalpha(alpha)

</t>
<t tx="karstenw.20170709210125.42">def colorize(self, black, white):

    """Use the ImageOps.colorize() on desaturated layer.
    
    """
    # 
    alpha = self.img.split()[3]
    img = self.img.convert("L")
    img = ImageOps.colorize(img, black, white)
    img = img.convert("RGBA")
    img.putalpha(alpha)
    self.img = img

</t>
<t tx="karstenw.20170709210125.43">def invert(self):

    """Inverts the layer.

    """
    self.img = invertimage( self.img )

</t>
<t tx="karstenw.20170709210125.44">def translate(self, x, y):

    """Positions the layer at the given coordinates.

    The x and y parameters define where to position 
    the top left corner of the layer,
    measured from the top left of the canvas.

    """

    self.x = int(x)
    self.y = int(y)

</t>
<t tx="karstenw.20170709210125.45">def scale(self, w=1.0, h=1.0):

    """Resizes the layer to the given width and height.

    When width w or height h is a floating-point number,
    scales percentual, 
    otherwise scales to the given size in pixels.

    """

    w0, h0 = self.img.size
    if type(w) == FloatType: w = int(w*w0)
    if type(h) == FloatType: h = int(h*h0)

    self.img = self.img.resize((w,h), resample=LANCZOS)
    self.w = w
    self.h = h

</t>
<t tx="karstenw.20170709210125.46">def distort(self, x1=0,y1=0, x2=0,y2=0, x3=0,y3=0, x4=0,y4=0):

    """Distorts the layer.
    
    Distorts the layer by translating 
    the four corners of its bounding box to the given coordinates:
    upper left (x1,y1), upper right(x2,y2),
    lower right (x3,y3) and lower left (x4,y4).
    
    """

    w, h = self.img.size
    quad = (-x1,-y1, -x4,h-y4, w-x3,w-y3, w-x2,-y2)
    # quad = (x1,y1, x2,y2, x3,y3, x4,y4)
    self.img = self.img.transform(self.img.size, Image.QUAD, quad) #, LANCZOS)

</t>
<t tx="karstenw.20170709210125.47">def rotate(self, angle):

    """Rotates the layer.

    Rotates the layer by given angle.
    Positive numbers rotate counter-clockwise,
    negative numbers rotate clockwise.

    Rotate commands are executed instantly,
    so many subsequent rotates will distort the image.

    """

    #When a layer rotates, its corners will fall outside
    #of its defined width and height.
    #Thus, its bounding box needs to be expanded.

    #Calculate the diagonal width, and angle from the layer center.
    #This way we can use the layers's corners 
    #to calculate the bounding box.

    w0, h0 = self.img.size
    d = sqrt(pow(w0,2) + pow(h0,2))
    d_angle = degrees(asin((w0*0.5) / (d*0.5)))

    angle = angle % 360
    if angle &gt; 90 and angle &lt;= 270: d_angle += 180

    w = sin(radians(d_angle + angle)) * d
    w = max(w, sin(radians(d_angle - angle)) * d)
    w = int(abs(w))

    h = cos(radians(d_angle + angle)) * d
    h = max(h, cos(radians(d_angle - angle)) * d)
    h = int(abs(h))

    dx = int((w-w0) / 2)
    dy = int((h-h0) / 2)
    d = int(d)

    #The rotation box's background color
    #is the mean pixel value of the rotating image.
    #This is the best option to avoid borders around
    #the rotated image.

    bg = ImageStat.Stat(self.img).mean
    bg = (int(bg[0]), int(bg[1]), int(bg[2]), 0)

    box = Image.new("RGBA", (d,d), bg)
    box.paste(self.img, ((d-w0)/2, (d-h0)/2))
    box = box.rotate(angle, Image.BICUBIC)
    box = box.crop(((d-w)/2+2, (d-h)/2, d-(d-w)/2, d-(d-h)/2))
    self.img = box

    #Since rotate changes the bounding box size,
    #update the layers' width, height, and position,
    #so it rotates from the center.

    self.x += (self.w-w)/2
    self.y += (self.h-h)/2
    self.w = w
    self.h = h   

</t>
<t tx="karstenw.20170709210125.48">def flip(self, axis=HORIZONTAL):

    """Flips the layer, either HORIZONTAL or VERTICAL.

    """

    if axis &amp; HORIZONTAL:
        #print "FLIP HOR", axis
        self.img = self.img.transpose(Image.FLIP_LEFT_RIGHT)
    if axis &amp; VERTICAL:
        #print "FLIP VERT", axis
        self.img = self.img.transpose(Image.FLIP_TOP_BOTTOM)

</t>
<t tx="karstenw.20170709210125.49">def blur(self):
    
    """Blurs the layer.
    
    """

    self.img = self.img.filter(ImageFilter.BLUR)

</t>
<t tx="karstenw.20170709210125.5">class Canvas:
    
    """Implements a canvas with layers.
    
    A canvas is an empty Photoshop document,
    where layers can be placed and manipulated.
    """

    @others
</t>
<t tx="karstenw.20170709210125.50">def sharpen(self, value=1.0):

    """Increases or decreases the sharpness in the layer.

    The given value is a percentage to increase
    or decrease the image sharpness,
    for example 0.8 means sharpness at 80%.

    """
 
    s = ImageEnhance.Sharpness(self.img) 
    self.img = s.enhance(value)
    
</t>
<t tx="karstenw.20170709210125.51">def statistics(self):
    
    return ImageStat.Stat(self.img, self.img.split()[3])
    
</t>
<t tx="karstenw.20170709210125.52">def levels(self):
    
    """Returns a histogram for each RGBA channel.
    
    Returns a 4-tuple of lists, r, g, b, and a.
    Each list has 255 items, a count for each pixel value.
            
    """
    
    h = self.img.histogram()
    r = h[0:255]
    g = h[256:511]
    b = h[512:767]
    a = h[768:1024]
    
    return r, g, b, a

</t>
<t tx="karstenw.20170709210125.53">class Blend:
    
    """Layer blending modes.
    
    Implements additional blending modes to those present in PIL.
    These blending functions can not be used separately from
    the canvas.flatten() method, where the alpha compositing
    of two layers is handled.
    
    Since these blending are not part of a C library,
    but pure Python, they take forever to process.
    
    """
    
    @others
</t>
<t tx="karstenw.20170709210125.54">def overlay(self, img1, img2):

    """Applies the overlay blend mode.

    Overlays image img2 on image img1.
    The overlay pixel combines multiply and screen:
    it multiplies dark pixels values and screen light values.
    Returns a composite image with the alpha channel retained.

    """

    p1 = list(img1.getdata())
    p2 = list(img2.getdata())

    for i in range(len(p1)):
    
        p3 = ()
        for j in range(len(p1[i])):

            a = p1[i][j] / 255.0
            b = p2[i][j] / 255.0
        
            #When overlaying the alpha channels,
            #take the alpha of the most transparent layer.
        
            if j == 3:
                #d = (a+b)*0.5
                #d = a
                d = min(a,b)
            elif a &gt; 0.5: 
                d = 2*(a+b-a*b)-1
            else: 
                d = 2*a*b            
            p3 += (int(d*255),)
    
        p1[i] = p3
    
    img = Image.new("RGBA", img1.size, 255)
    img.putdata(p1)
    return img

</t>
<t tx="karstenw.20170709210125.55">def hue(self, img1, img2):

    """Applies the hue blend mode.

    Hues image img1 with image img2.
    The hue filter replaces the hues of pixels in img1
    with the hues of pixels in img2.
    Returns a composite image with the alpha channel retained.

    """

    p1 = list(img1.getdata())
    p2 = list(img2.getdata())
    for i in range(len(p1)):
    
        r1, g1, b1, a1 = p1[i]
        r1 = r1 / 255.0
        g1 = g1 / 255.0
        b1 = b1 / 255.0
    
        h1, s1, v1 = colorsys.rgb_to_hsv(r1, g1, b1)
    
        r2, g2, b2, a2 = p2[i]
        r2 = r2 / 255.0
        g2 = g2 / 255.0
        b2 = b2 / 255.0
        h2, s2, v2 = colorsys.rgb_to_hsv(r2, g2, b2)
    
        r3, g3, b3 = colorsys.hsv_to_rgb(h2, s1, v1)
    
        r3 = int(r3*255)
        g3 = int(g3*255)
        b3 = int(b3*255)
        p1[i] = (r3, g3, b3, a1)

    img = Image.new("RGBA", img1.size, 255)
    img.putdata(p1)
    return img

</t>
<t tx="karstenw.20170709210125.56">def color(self, img1, img2):

    """Applies the color blend mode.

    Colorize image img1 with image img2.
    The color filter replaces the hue and saturation of pixels in img1
    with the hue and saturation of pixels in img2.
    Returns a composite image with the alpha channel retained.

    """
    p1 = list(img1.getdata())
    p2 = list(img2.getdata())
    for i in range(len(p1)):
    
        r1, g1, b1, a1 = p1[i]
        r1 = r1 / 255.0
        g1 = g1 / 255.0
        b1 = b1 / 255.0
    
        h1, s1, v1 = colorsys.rgb_to_hsv(r1, g1, b1)
    
        r2, g2, b2, a2 = p2[i]
        r2 = r2 / 255.0
        g2 = g2 / 255.0
        b2 = b2 / 255.0
        h2, s2, v2 = colorsys.rgb_to_hsv(r2, g2, b2)
    
        r3, g3, b3 = colorsys.hsv_to_rgb(h2, s2, v1)
    
        r3 = int(r3*255)
        g3 = int(g3*255)
        b3 = int(b3*255)
        p1[i] = (r3, g3, b3, a1)

    img = Image.new("RGBA", img1.size, 255)
    img.putdata(p1)
    return img

</t>
<t tx="karstenw.20170709210125.57">class Pixels:
    
    """Provides direct access to a layer's pixels.
    
    The layer.pixels[] contains all pixel values
    in a 1-dimensional array.
    Each pixel is a tuple containing (r,g,b,a) values.
    
    After the array has been updated, layer.pixels.update()
    must be called for the changes to commit.
    
    """
    
    @others
</t>
<t tx="karstenw.20170709210125.58">def __init__(self, img, layer):
    
    self.layer = layer
    self.img = img
    self.data = None
    
</t>
<t tx="karstenw.20170709210125.59">def __getitem__(self, i):

    w, h = self.img.size
    if i &gt;= w*h: i -= w*h
    if i &lt; 0: i += w*h
    
    if self.data == None: self.data = list(self.img.getdata())
    return self.data[i]
    
</t>
<t tx="karstenw.20170709210125.6">def __init__(self, w, h):
    
    """Creates a new canvas.

    Creates the working area on which to blend layers.
    The canvas background is transparent,
    but a background color could be set using the fill() function.
    """
    
    self.interpolation = INTERPOLATION
    self.layers = Layers()
    self.w = w
    self.h = h
    
    img = Image.new("RGBA", (w,h), (255,255,255,0))
    self.layer(img, name="_bg")


</t>
<t tx="karstenw.20170709210125.60">def __setitem__(self, i, rgba):
    
    w, h = self.img.size
    if i &gt;= w*h: i -= w*h
    if i &lt; 0: i += w*h
    
    if self.data == None: self.data = list(self.img.getdata())
    self.data[i] = rgba

</t>
<t tx="karstenw.20170709210125.61">def __iter__(self):
    
    for i in range(len(self)):
        yield self[i]

</t>
<t tx="karstenw.20170709210125.62">def __len__(self):
    
    w, h = self.img.size
    return w * h
                
</t>
<t tx="karstenw.20170709210125.63">def update(self):
    
    if self.data != None: 
        self.img.putdata(self.data)
        self.data = None
    
</t>
<t tx="karstenw.20170709210125.64">def convolute(self, kernel, scale=None, offset=0):
    
    """A (3,3) or (5,5) convolution kernel.
    
    The kernel argument is a list with either 9 or 25 elements,
    the weight for each surrounding pixels to convolute.
    
    """
    
    if len(kernel)   ==  9: size = (3,3)
    elif len(kernel) == 25: size = (5,5)
    else: return
    
    if scale == None:
        scale = 0
        for x in kernel: scale += x
        if scale == 0: scale = 1
 
    f = ImageFilter.BuiltinFilter()
    f.filterargs = size, scale, offset, kernel
    self.layer.img = self.layer.img.filter(f)


</t>
<t tx="karstenw.20170709210125.65">def aspectRatio(size, maxsize):
    """scale a (w,h) tuple to maxsize (either w or h)."""

    maxcurrent = max(size)
    if maxcurrent == maxsize:
        return size
    elif maxsize == 0:
        return size
    else:
        ratio = maxcurrent / float(maxsize)
        neww = int(round(size[0] / ratio))
        newh = int(round(size[1] / ratio))
        return neww, newh


</t>
<t tx="karstenw.20170709210125.66">def normalizeOrientationImage( img ):
    """Rotate an image according to exif info."""

    rotation = 0
    try:
        info = img._getexif()
        if 274 in info:
            r = info[274]
            if r == 3:
                rotation = 180
            elif r == 6:
                rotation = -90
            elif r == 8:    
                rotation = 90
    except (Exception, IndexError), err:
        pass
    if rotation != 0:
        return img.rotate( rotation )
    return img


</t>
<t tx="karstenw.20170709210125.67">def resizeImage( filepath, maxsize, orientation=True):
    """Get a downsampled image for use in layers."""

    try:
        img = Image.open(filepath)
    except Exception, err:
        print "\nresizeImage() FAILED", repr(filepath,)
        print err
        return ""
    # downsample the image
    if maxsize:
        newx, newy = aspectRatio( (img.size), maxsize)
        img = img.resize( (newx, newy), resample=Image.LANCZOS)

    # respect exif orientation
    if orientation:
        img = normalizeOrientationImage( img )
    return img.convert("RGBA")


</t>
<t tx="karstenw.20170709210125.7">def layer(self, img, x=0, y=0, name=""):

    """Creates a new layer from file, Layer, PIL Image.

    If img is an image file or PIL Image object,
    Creates a new layer with the given image file.
    The image is positioned on the canvas at x, y.
    
    If img is a Layer,
    uses that layer's x and y position and name.
    """

    if isinstance(img, Image.Image):
        img = img.convert("RGBA")
        self.layers.append(Layer(self, img, x, y, name))
        return len(self.layers)-1

    if isinstance(img, Layer):
        img.canvas = self
        self.layers.append(img)
        return len(self.layers) - 1

    if type(img) in (str, unicode): 
        img = Image.open(img)
        img = img.convert("RGBA")
        self.layers.append(Layer(self, img, x, y, name))
        return len(self.layers)-1


</t>
<t tx="karstenw.20170709210125.8">def fill(self, rgb, x=0, y=0, w=None, h=None, name=""):

    """Creates a new fill layer.

    Creates a new layer filled with the given rgb color.
    For example, fill((255,0,0)) creates a red fill.
    The layers fills the entire canvas by default.
    """ 

    if w == None:
        w = self.w - x
    if h == None:
        h = self.h - y
    img = Image.new("RGBA", (w,h), rgb)
    return self.layer(img, x, y, name)


</t>
<t tx="karstenw.20170709210125.9">def makegradientimage(self, style, w, h):
    """Creates the actual gradient image.
    
    This has been factored out of gradient() so complex gradients like ROUNDRECT
    which consist of multiple images can be composed.
    """
    w0 = self.w 
    h0 = self.h
    if type(w) == FloatType:
        w *= w0
    if type(h) == FloatType:
        h *= h0
    
    if style not in (RADIALCOSINE,):
        img = Image.new("L", (int(w),int(h)), 255)
    else:
        img = Image.new("L", (int(w),int(h)), 0)
    draw = ImageDraw.Draw(img)

    if style == SOLID:
        draw.rectangle((0, 0, w, h), fill=255)

    if style == LINEAR:
        for i in range(int(w)):
            k = 255.0 * i/w
            draw.rectangle((i, 0, i, h), fill=int(k))
        
    if style == RADIAL:
        r = min(w,h)/2
        for i in range(int(r)):
            k = 255 - 255.0 * i/r
            draw.ellipse((w/2-r+i, h/2-r+i,
                          w/2+r-i, h/2+r-i), fill=int(k))
        
    if style == RADIALCOSINE:
        r = max(w,h) / 2.0
        rx = w / 2.0
        ry = h / 2.0
        
        deg = 90
        base = 90 - deg
        deltaxdeg = deg / rx
        deltaydeg = deg / ry
        deltadeg = deg / r
        #print "RADIALCOSINE w, h, r", w, h, r
        #print "RADIALCOSINE steps xy:", deltaxdeg, deltaydeg
        
        step = min(deltaxdeg, deltaydeg)
        for i in range(int(r)):
            # k = 255.0 * i/r
            k = 256 * sin( radians( base + i * deltadeg ) )
            ix = i * (rx / r)
            iy = i * (ry / r)
            draw.ellipse((0 + ix, 0 + iy,
                          w - ix, h - iy), fill=int(k))

    if style == DIAMOND:
        r = max(w,h)
        for i in range(int(r)):
            x = int(i*w/r*0.5)
            y = int(i*h/r*0.5)
            k = 255.0 * i/r
            draw.rectangle((x, y, w-x, h-y), outline=int(k))
    
    if style in (SINE, COSINE):
        # sin/cos 0...180 left to right
        action = sin
        deg = 180.0
        base = 0
        if style == COSINE:
            action = cos
            deg = 90.0
            base = 90.0 - deg
        deltadeg = deg / w
        for i in range( int(w) ):
            k = 256 * action( radians( base + i * deltadeg ) )
            # draw.rectangle((i, 0, i, h), fill=int(k))
            draw.line( (i,0,i, h), fill=int(k), width=1)

    result = img.convert("RGBA")
    del img
    del draw
    return result


</t>
<t tx="karstenw.20170709210735.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170709210910.1">size(960, 1200)


pb = ximport("photobot")
reload(pb)

pbh = ximport("pbhelpers")
label = pbh.label

c = pb.canvas(WIDTH, HEIGHT)

c.fill((210, 210, 10))


# the gradients

# SOLID
grad1idx = c.gradient(pb.SOLID, 180, 180)
c.layers[grad1idx].translate(10, 10)
label("SOLID", 10, 10)

# LINEAR
grad2idx = c.gradient(pb.LINEAR, 180, 180)
c.layers[grad2idx].translate(200, 10)
label("LINEAR", 200, 10)

# RADIAL
grad3idx = c.gradient(pb.RADIAL, 180, 180)
c.layers[grad3idx].translate(390, 10)
label("RADIAL", 390, 10)

# DIAMOND
grad4idx = c.gradient(pb.DIAMOND, 180, 180)
c.layers[grad4idx].translate(580, 10)
label("DIAMOND", 580, 10)

# SINE (from 0 to 180)
grad5idx = c.gradient(pb.SINE, 180, 180)
c.layers[grad5idx].translate(10, 200)
label("SINE 0..180", 10, 200)

# COSINE (from 0 to 90)
grad6idx = c.gradient(pb.COSINE, 180, 180)
c.layers[grad6idx].translate(200, 200)
label("COSINE 0..90", 200, 200)

# ROUNDRECT (with radius arg)
grad7idx = c.gradient(pb.ROUNDRECT, 180, 180, radius=72, radius2=18)
c.layers[grad7idx].translate(390, 200)
label("ROUNDRECT", 390, 200)

# RADIALCOSINE
grad8idx = c.gradient(pb.RADIALCOSINE, 180, 180)
c.layers[grad8idx].translate(580, 200)
label("RADIALCOSINE", 580, 200)

# QUAD
grad8idx = c.gradient(pb.QUAD, 180, 180, radius=36, radius2=9)
c.layers[grad8idx].translate(770, 200)
label("QUAD", 770, 200)


# the gradients masked with itself
# 
gx, xy = 180, 180
# SOLID
grad1idx = c.gradient(pb.SOLID , gx, xy)
mask = c.gradient(pb.SOLID, gx, xy)
c.layers[mask].mask()
c.layers[grad1idx].translate(10, 390)


# LINEAR
grad2idx = c.gradient(pb.LINEAR, gx, xy)
mask = c.gradient(pb.LINEAR, gx, xy)
c.layers[mask].mask()
c.layers[grad2idx].translate(200, 390)


# RADIAL
# you want to have the RADIAL gradient inverted
grad3idx = c.gradient(pb.RADIAL, gx, xy, radius=36)
c.layers[grad3idx].invert()
mask = c.gradient(pb.RADIAL, gx, xy)
c.layers[mask].invert()
c.layers[mask].mask()
c.layers[grad3idx].translate(390, 390)


# DIAMOND
grad4idx = c.gradient(pb.DIAMOND, gx, xy)
mask = c.gradient(pb.DIAMOND, gx, xy)
c.layers[mask].mask()
c.layers[grad4idx].translate(580, 390)


# SINE 0..180
grad5idx = c.gradient(pb.SINE, gx, xy)
mask = c.gradient(pb.SINE, gx, xy)
c.layers[mask].mask()
c.layers[grad5idx].translate(10, 580)


# COSINE 0..90
grad6idx = c.gradient(pb.COSINE, gx, xy)
mask = c.gradient(pb.COSINE, gx, xy)
c.layers[mask].mask()
c.layers[grad6idx].translate(200, 580)


# ROUNDRECT 
grad7idx = c.gradient(pb.ROUNDRECT, gx, xy, radius=72, radius2=9)
mask = c.gradient(pb.ROUNDRECT, gx, xy, radius=72, radius2=9)
c.layers[mask].mask()
c.layers[grad7idx].translate(390, 580)


# RADIALCOSINE
grad8idx = c.gradient(pb.RADIALCOSINE, gx, xy)
mask = c.gradient(pb.RADIALCOSINE, gx, xy)
c.layers[mask].mask()
c.layers[grad8idx].translate(580, 580)

# QUAD
grad9idx = c.gradient(pb.QUAD, gx, xy, radius=36, radius2=9)
mask = c.gradient(pb.QUAD, gx, xy, radius=36, radius2=9)
c.layers[mask].mask()
c.layers[grad9idx].translate(770, 580)




# COSINE 0..90
grad6idx = c.gradient(pb.COSINE, gx, xy)
mask = c.gradient(pb.COSINE, gx, xy)
c.layers[mask].mask()
c.layers[grad6idx].translate(100, 800)
c.layers[grad6idx].rotate(45)


# RADIALCOSINE

grad8idx = c.gradient(pb.RADIALCOSINE, gx*2, xy)
mask = c.gradient(pb.RADIALCOSINE, gx*2, xy)
c.layers[mask].mask()
c.layers[grad8idx].translate(390, 770)


# QUAD
grad9idx = c.gradient(pb.QUAD, gx*2, xy)
mask = c.gradient(pb.QUAD, gx*2, xy)
c.layers[mask].mask()
c.layers[grad9idx].translate(390, 960)



c.draw(1, 1)

# put labels on top
canvas._grobs.reverse()
</t>
<t tx="karstenw.20170709211002.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170709211010.1">W,H = 532, 1050
&lt;&lt;initialisation&gt;&gt;


#
# Image 1
#

#  create, scale and place the image
x, y = 10, 10
top, w1, h1 = placeImage(img1path, x, y, 512, "Image 1")
label("Image 1", x, y)


# apply colorize
c.layers[top].colorize((240, 120, 0), (255, 255, 127))


# draw the result
c.draw(0, 0)
</t>
<t tx="karstenw.20170710094259.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170710094319.1">W,H = 550, 1050
&lt;&lt;initialisation&gt;&gt;

&lt;&lt;image1&gt;&gt;
&lt;&lt;image2&gt;&gt;

#
# Screen Images 1 &amp; 2
#

&lt;&lt;image34&gt;&gt;
c.layers[top].screen()
label("Screen Image 1 over Image 2", x, y)


#
# Screen Images 2 &amp; 1
#

&lt;&lt;image56&gt;&gt;
c.layers[top].screen()
label("Screen Image 2 over Image 1", x, y)

&lt;&lt;outro&gt;&gt;
</t>
<t tx="karstenw.20170710094409.1"># 
# Note:
#
# The examples may be easier to understand if you have LEO http://leoeditor.com installed
# and read them using the photobot.leo file
#
#
kwdbg = False

size(W, H)

background( 0.333 )

# need a different name; random is taken
import random as rnd

if kwdbg:
    # make random choices repeatable for debugging
    rnd.seed(0)

# import photobot
pb = ximport("photobot")
pbh = ximport("pbhelpers")
label = pbh.label

# import extensions if nodebox version &lt; 1.9.18
try:
    imagefiles
except NameError:
    from nodeboxExtensions import *

# create the canvas
c = pb.canvas(int(WIDTH), int(HEIGHT))

# get all images from system "Desktop Pictures" folder
filetuples = imagefiles( "/Library/Desktop Pictures", False )

# filter out all 1 pix one color images by ignoring all files &lt; 100k
tiles = []
for t in filetuples:
    path, filesize, lastmodified, mode, islink = t
    if filesize &lt; 100000:
        continue
    tiles.append( path )

# shuffle the images
rnd.shuffle(tiles)
rnd.shuffle(tiles)
rnd.shuffle(tiles)


img1path = tiles.pop()
img2path = tiles.pop()


def placeImage(path, x, y, maxsize, name):
    img1 = pb.resizeImage(path, maxsize)
    top = c.layer(img1, name=name)
    c.layers[top].translate(x, y)
    w, h, = c.layers[ top ].bounds()
    return top, w, h

</t>
<t tx="karstenw.20170710105607.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170710105617.1">W,H = 542, 1050
&lt;&lt;initialisation&gt;&gt;

&lt;&lt;image1&gt;&gt;
&lt;&lt;image2&gt;&gt;


#
# Overlay Images 1 &amp; 2
#

&lt;&lt;image34&gt;&gt;

c.layers[top].overlay()
label("Overlay Image1 over Image2", x, y)

#
# Overlay Images 2 &amp; 1
#

&lt;&lt;image56&gt;&gt;

c.layers[top].overlay()
label("Overlay Image2 over Image1", x, y)

&lt;&lt;outro&gt;&gt;

</t>
<t tx="karstenw.20170710105816.1">#
# Image 1
#

#  create, scale and place the image
x, y = 10, 10
top, w1, h1 = placeImage(img1path, x, y, 256, "Image 1")
label("Image 1", x, y)

</t>
<t tx="karstenw.20170710105845.1">#
# Image 2
#
x, y = w1+20, 10
top, w2, h2 = placeImage(img2path, x, y, 256, "Image 2")
label("Image 2", x, y)

</t>
<t tx="karstenw.20170710105940.1">h = max(h1, h2)
x, y = 10 , h + 20

top, w3, h3 = placeImage(img1path, x, y, 522, "Image 3")
top, w4, h4 = placeImage(img2path, x, y, 522, "Image 4")

</t>
<t tx="karstenw.20170710105956.1">h = max(h3, h4)
x, y = 10 , h + 20 + y

top, w4, h4 = placeImage(img2path, x, y, 522, "Image 5")
top, w3, h3 = placeImage(img1path, x, y, 522, "Image 6")

</t>
<t tx="karstenw.20170710110147.1"># draw the result
c.draw(0, 0)


# this is just mean
# if you understand what it does, you're the next NodeBox maintainer...
canvas._grobs.reverse()


</t>
<t tx="karstenw.20170710113238.1">@language python
@tabwidth -4
@others
W,H = 542, 1050
&lt;&lt;initialisation&gt;&gt;

#
# Image 1
#

#  create, scale and place the image
x, y = 10, 10
img1, w1, h1 = placeImage(img1path, x, y, 256, "Image 1")
label("Image 1 Brightness: 100", x, y)

#
# Image 2
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 2"
c.layers[top].brightness(80)

x, y = w1+20, 10
c.layers[top].translate( x, y)
label("Image 2 Brightness: 80", x, y)

#
# Image 3
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 3"
c.layers[top].brightness(60)

x, y = 10, h1 + 20
c.layers[top].translate( x, y)
label("Image 3 Brightness: 60", x, y)

#
# Image 4
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 4"
c.layers[top].brightness(40)

x, y = w1+20, h1 + 20
c.layers[top].translate( x, y)
label("Image 4 Brightness: 40", x, y)

#
# Image 5
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 5"
c.layers[top].brightness(20)

x, y = 10, 2*h1 + 30
c.layers[top].translate( x, y)
label("Image 3 Brightness: 20", x, y)

#
# Image 6
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 6"
c.layers[top].brightness(10)

x, y = w1+20, 2*h1 + 30
c.layers[top].translate( x, y)
label("Image 6 Brightness: 10", x, y)

#
# Image 7
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 7"
c.layers[top].brightness(150)

x, y = 10, 3*h1 + 40
c.layers[top].translate( x, y)
label("Image 7 Brightness: 150", x, y)

#
# Image 8
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 8"
c.layers[top].brightness(200)

x, y = w1 + 20, 3*h1 + 40
c.layers[top].translate( x, y)
label("Image 8 Brightness: 200", x, y)



# draw the result
c.draw(0, 0)


# this is just mean
# if you understand what it does, you're the next NodeBox maintainer...
canvas._grobs.reverse()
</t>
<t tx="karstenw.20170710113905.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170710113922.1">W,H = 542, 1050
&lt;&lt;initialisation&gt;&gt;

&lt;&lt;image1&gt;&gt;
&lt;&lt;image2&gt;&gt;

#
# Color Images 1 &amp; 2
#

&lt;&lt;image34&gt;&gt;

c.layers[top].color()
label("Color Image2 over Image1", x, y)

#
# Color Images 2 &amp; 1
#

&lt;&lt;image56&gt;&gt;

c.layers[top].color()
label("Color Image1 over Image2", x, y)

&lt;&lt;outro&gt;&gt;

</t>
<t tx="karstenw.20170710122812.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170710122823.1">W,H = 542, 1050
&lt;&lt;initialisation&gt;&gt;

&lt;&lt;image1&gt;&gt;
&lt;&lt;image2&gt;&gt;


#
# Mask Images 1 &amp; 2
#

h = max(h1, h2)
x, y = 10 , h + 20

top, w3, h3 = placeImage(img1path, 0, 0, 522, "Image 3")
top, w4, h4 = placeImage(img2path, 0, 0, 522, "Image 4")
c.layers[top].mask()
top = c.topLayer()
c.layers[top].translate(x, y)

label("Mask Image1 over Image2", x, y)

#
# Mask Images 2 &amp; 1
#

h = max(h3, h4)
x, y = 10 , h + 20 + y

top, w4, h4 = placeImage(img2path, 0, 0, 522, "Image 5")
top, w3, h3 = placeImage(img1path, 0, 0, 522, "Image 6")
c.layers[top].mask()
top = c.topLayer()
c.layers[top].translate(x, y)

label("Mask Image2 over Image1", x, y)

&lt;&lt;outro&gt;&gt;

</t>
<t tx="karstenw.20170710130259.1">@language python
@tabwidth -4
W,H = 542, 1050
&lt;&lt;initialisation&gt;&gt;

#
# Image 1
#

#  create, scale and place the image
x, y = 10, 10
img1, w1, h1 = placeImage(img1path, x, y, 256, "Image 1")
label("Image 1 Opacity: 100", x, y)

#
# Image 2
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 2"
c.layers[top].opacity(80)

x, y = w1+20, 10
c.layers[top].translate( x, y)
label("Image 2 Opacity: 80", x, y)

#
# Image 3
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 3"
c.layers[top].opacity(60)

x, y = 10, h1 + 20
c.layers[top].translate( x, y)
label("Image 3 Opacity: 60", x, y)

#
# Image 4
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 4"
c.layers[top].opacity(40)

x, y = w1+20, h1 + 20
c.layers[top].translate( x, y)
label("Image 4 Opacity: 40", x, y)

#
# Image 5
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 5"
c.layers[top].opacity(20)

x, y = 10, 2*h1 + 30
c.layers[top].translate( x, y)
label("Image 3 Opacity: 20", x, y)

#
# Image 6
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 6"
c.layers[top].opacity(10)

x, y = w1+20, 2*h1 + 30
c.layers[top].translate( x, y)
label("Image 6 Opacity: 10", x, y)

#
# Image 7
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 7"
c.layers[top].opacity(150)

x, y = 10, 3*h1 + 40
c.layers[top].translate( x, y)
label("Image 7 Opacity: 150", x, y)

#
# Image 8
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 8"
c.layers[top].opacity(200)

x, y = w1 + 20, 3*h1 + 40
c.layers[top].translate( x, y)
label("Image 8 Opacity: 200", x, y)



# draw the result
c.draw(0, 0)


# this is just mean
# if you understand what it does, you're the next NodeBox maintainer...
canvas._grobs.reverse()
</t>
<t tx="karstenw.20170710134714.1">@language python
@tabwidth -4
W,H = 542, 1050
&lt;&lt;initialisation&gt;&gt;

#
# Image 1
#

#  create, scale and place the image
x, y = 10, 10
img1, w1, h1 = placeImage(img1path, x, y, 256, "Image 1")
label("Image 1 Contrast: 100", x, y)

#
# Image 2
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 2"
c.layers[top].contrast(80)

x, y = w1+20, 10
c.layers[top].translate( x, y)
label("Image 2 Contrast: 80", x, y)

#
# Image 3
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 3"
c.layers[top].contrast(60)

x, y = 10, h1 + 20
c.layers[top].translate( x, y)
label("Image 3 Contrast: 60", x, y)

#
# Image 4
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 4"
c.layers[top].contrast(40)

x, y = w1+20, h1 + 20
c.layers[top].translate( x, y)
label("Image 4 Contrast: 40", x, y)

#
# Image 5
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 5"
c.layers[top].contrast(20)

x, y = 10, 2*h1 + 30
c.layers[top].translate( x, y)
label("Image 3 Contrast: 20", x, y)

#
# Image 6
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 6"
c.layers[top].contrast(10)

x, y = w1+20, 2*h1 + 30
c.layers[top].translate( x, y)
label("Image 6 Contrast: 10", x, y)

#
# Image 7
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 7"
c.layers[top].contrast(150)

x, y = 10, 3*h1 + 40
c.layers[top].translate( x, y)
label("Image 7 Contrast: 150", x, y)

#
# Image 8
#
c.layers[img1].duplicate()
top = c.topLayer()
c.layers[top].name = "Image 8"
c.layers[top].contrast(200)

x, y = w1 + 20, 3*h1 + 40
c.layers[top].translate( x, y)
label("Image 8 Contrast: 200", x, y)



# draw the result
c.draw(0, 0)


# this is just mean
# if you understand what it does, you're the next NodeBox maintainer...
canvas._grobs.reverse()
</t>
<t tx="karstenw.20170710134831.1">kwdbg = False

size(W, H)

background( 0.333 )

# need a different name; random is taken
import random as rnd

if kwdbg:
    # make random choices repeatable for debugging
    rnd.seed(0)

# import photobot
try:
    pb = ximport("photobot")
    pbh = ximport("pbhelpers")
except ImportError:
    pb = ximport("__init__")
    reload(pb)
from pbhelpers import *

# import extensions if nodebox version &lt; 1.9.18
try:
    imagefiles
except NameError:
    from nodeboxExtensions import *

# create the canvas
c = pb.canvas(int(WIDTH), int(HEIGHT))

# get all images from system "Desktop Pictures" folder
filetuples = imagefiles( "/Library/Desktop Pictures", False )

# filter out all 1 pix one color images by ignoring all files &lt; 100k
tiles = []
for t in filetuples:
    path, filesize, lastmodified, mode, islink = t
    if filesize &lt; 100000:
        continue
    tiles.append( path )

# shuffle the images
rnd.shuffle(tiles)
rnd.shuffle(tiles)
rnd.shuffle(tiles)


img1path = tiles.pop()
img2path = tiles.pop()


def placeImage(path, x, y, maxsize, name):
    img1 = pb.resizeImage(path, maxsize)
    top = c.layer(img1, name=name)
    c.layers[top].translate(x, y)
    w, h, = c.layers[ top ].bounds()
    return top, w, h

</t>
<t tx="karstenw.20170710140437.1">@language python
@tabwidth -4
@others
W,H = 1084, 798
&lt;&lt;initialisation&gt;&gt;

imsize = int((W-30)/2)
x, y = 10, 10
img1, w1, h1 = placeImage(img1path, x, y, imsize, "image1")
label("Original Image", x, y)

#
# flip horizontal
#
c.layers["image1"].duplicate()
top = c.topLayer()
c.layers[top].name = "flip1"

x, y = w1+20, 10
c.layers[top].translate( x, y)
c.layers[top].flip( pb.HORIZONTAL )
label("Horizontal Flip", x, y)


#
# flip vertical
#

c.layers["image1"].duplicate()
top = c.topLayer()
c.layers[top].name = "flip2"
x, y = 10 , h1 + 20
c.layers[top].flip( pb.VERTICAL )
c.layers[top].translate( x, y )
label("Vertical Flip", x, y)



#
# flip horizontal &amp; vertical
#

# duplicate does not return top
c.layers["image1"].duplicate()
top = c.topLayer()
c.layers[top].name = "flip3"

x, y = w1 + 20, h1 + 20
c.layers[top].flip( pb.HORIZONTAL | pb.VERTICAL)
# c.layers[top].flip( pb.VERTICAL )
c.layers[top].translate( x, y)
label("Horizontal  and Vertical Flip", x, y)

&lt;&lt;outro&gt;&gt;

</t>
<t tx="karstenw.20170710142919.1">def topLayer( self ):
    # return top layer index
    return len(self.layers) -1


</t>
<t tx="karstenw.20170711131553.1">@others
if 1:
    # orange hue mask finish
    top = c.fill((200,100,0))
    c.layers[top].opacity(30)
    c.layers[top].hue()

if paintoverlay:
    # paint overlay
    top = c.layer( os.path.abspath("./paint.jpg") )
    w, h = c.layers[top].bounds()
    xs = WIDTH / float(w)
    ys = HEIGHT / float(h)
    s = max(xs,ys)
    c.layers[top].scale(s, s)
    c.layers[top].opacity(10)
    c.layers[top].overlay()



c.draw(0, 0)
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170711131604.1"># heavily inspired by https://www.nodebox.net/code/index.php/Landslide
kwdbg = False

if 0: #not kwdbg:
    size(0, 0)
    if not WIDTH and HEIGHT:
        size(1024, 768)
else:
    size(1024, 768)


RATIO = WIDTH / HEIGHT

background( 0.333 )

import sys, os

import pprint
pp = pprint.pprint

# need a different name
import random as rnd

if kwdbg:
    # make random choices repeatable for debugging
    rnd.seed(0)

# import photobot
try:
    pb = ximport("photobot")
except ImportError:
    pb = ximport("__init__")
    reload(pb)

# import extensions if nodebox version &lt; 1.9.18
try:
    imagefiles
except NameError:
    from nodeboxExtensions import *

</t>
<t tx="karstenw.20170711131604.2">def cropImageToRatioHorizontal( layer, ratio ):
    w, h = layer.bounds()
    neww = int( round( h*ratio) )
    d = int( neww / 2.0 )
    x,y,w,h = insetRect( (0,0,w,h), d, 0 )
    layer.img = layer.img.crop(box=(x,y,x+w,y+h))
    return layer
    

</t>
<t tx="karstenw.20170711131604.3">def insetRect( rectangle, horInset, vertInset):
    x, y, w, h = rectangle
    dh = horInset / 2.0
    dv = vertInset / 2.0
    return x+dh, y+dv, w-horInset, h-vertInset

</t>
<t tx="karstenw.20170711131604.4">def aspectRatio(size, maxheight):
    """scale a (w,h) tuple to maxheight."""
    
    # NEEDED: scale to center square, not height
    
    w, h = size
    if h == maxheight:
        return 1.0
    elif maxheight == 0:
        return 1.0
    else:
        return float(maxheight) / h




# create the canvas
c = pb.canvas(int(WIDTH), int(HEIGHT))


# get all images from system "Desktop Pictures" folder
filetuples = imagefiles( "/Library/Desktop Pictures", False )

# filter out all 1 pix one color images by ignoring all files &lt; 100k
tiles = []
for t in filetuples:
    path, filesize, lastmodified, mode, islink = t
    if filesize &lt; 100000:
        continue
    tiles.append( path )


rnd.shuffle(tiles)



# CONFIGURATION

columns = 3
rows = 2

randomblur = False
paintoverlay = False


# 
y_offset = HEIGHT / (rows)


# 
if 1:
    top = c.layer(tiles.pop())
    w, h = c.layers[ top ].bounds()
    s = aspectRatio( (w,h), HEIGHT )
    c.layers[1].scale(s, s)


</t>
<t tx="karstenw.20170711131604.5">def topLayer( c ):
    # return top layer index
    return len(c.layers) -1


for j in range(rows):
    colw = 0
    for i in range(columns):

        # create image in canvas at 0,0
        nextpictpath = tiles.pop()

        # top is the index of the image layer
        top = c.layer( nextpictpath )

        # get current image bounds
        w, h = c.layers[ top ].bounds()

        # calculate scale &amp; apply
        s = aspectRatio( (w,h), y_offset)
        c.layers[ top ].scale(s, s)

        # uniform
        layer = c.layers[ top ]
        layer = cropImageToRatioHorizontal( layer, RATIO )
        c.layers[ top ]= layer

        # get the new image bounds
        w, h = c.layers[ top ].bounds()

        # add contrast
        c.layers[ top ].contrast(1.1)


        r = 0.4 #rnd.random()
        # 10%
        if r &lt; 0.1:
            #print "COSINE/LINEAR"
            # create gradient layer
            # top is now gradient index
            top = c.gradient(pb.LINEAR, w/2, h)
            c.layers[ top ].flip( pb.HORIZONTAL )

            # layer + 4 flip
            # c.layers[ top ].flip( pb.HORIZONTAL )

            # layer +4 translate half a pict right
            c.layers[ top ].translate(w/2, j*y_offset)

            # create gradient layer
            # top is now second gradient index
            top = c.gradient(pb.LINEAR, w/2, h)
            # merge both gradients; destroys top layer
            c.merge([ top-1 , top ])
        elif 0.1 &lt;= r &lt; 0.5:
            #print "SINE"
            # create gradient layer
            # top i now gradient index
            top = c.gradient(pb.SINE, w, h)
            
        elif 0.6 &lt;= r &lt; 0.75:
            #print "RADIALCOSINE"
            # create gradient layer
            # top i now gradient index
            top = c.gradient(pb.RADIALCOSINE, w, h)
            c.layers[top].invert()
        else:
            #print "ROUNDRECT"
            # 25%
            top = c.gradient(pb.ROUNDRECT, w, h, radius=int(w/5.0))
            
        
        top = topLayer( c )

        c.layers[ top ].brightness(1.4)
        # mask destroys top layer
        c.layers[ top ].mask()

        # top layer is now image with mask
        top = topLayer( c )
        # c.layers[ top ].translate(colw+i*w/3, j*y_offset)
        c.layers[ top ].translate(colw+i*w, j*y_offset)
        # colw += i*w/2.0

        if randomblur:
            if rnd.random() &gt; 0.5:
                c.layers[ top ].flip()

            if rnd.random() &gt; 0.5:
                c.layers[ top ].blur()

</t>
<t tx="karstenw.20170711131606.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170711131614.1"># heavily inspired by https://www.nodebox.net/code/index.php/Landslide
size(0, 0)
import sys, os

import pprint
pp = pprint.pprint

# need a different name
import random as rnd

background( 0.5 )

try:
    pb = ximport("photobot")
except ImportError:
    pb = ximport("__init__")
    reload(pb)


import pbhelpers

try:
    imagefiles
except NameError:
    import helper_for_older_nodebox
    imagefiles = helper_for_older_nodebox.imagefiles

c = pb.canvas(int(WIDTH), int(HEIGHT))

tiles = list(imagefiles( "/Library/Desktop Pictures" ))


columns = 8
rows = 4

# 
y_offset = HEIGHT / (rows+1)

# x_offset = WIDTH / (columns * 2)

enoughTiles = len(tiles) &gt; (columns*2*rows)

picts = []
for t in range(columns*rows*2):
    s = choice(tiles)
    picts.append(s)
    if enoughTiles:
        tiles.remove(s)

rnd.shuffle(picts)
nextpictpath = picts.pop()
currlayer = c.layer(nextpictpath, name="0001")
c.layers[currlayer].scale(0.2,0.2)


</t>
<t tx="karstenw.20170711131614.2">def topLayer( c ):
    # return top layer index
    return len(c.layers) -1

for j in range(rows):
    for i in range(columns):

        # create image in canvas at 0,0
        nextpictpath = picts.pop()
        # print repr(nextpictpath)

        c.layer( nextpictpath )

        nlayers = len(c.layers)
        lastIndex = topLayer( c )
        c.layers[lastIndex].scale(0.2,0.2)

        # add contrast
        c.layers[ lastIndex ].contrast(1.1)

        # get current image bounds
        w, h = c.layers[ lastIndex ].bounds()

        # create gradient layer
        c.gradient(pb.LINEAR, w/2, h)

        nlayers = len(c.layers)
        lastIndex = topLayer( c )

        # layer + 4 flip
        c.layers[ lastIndex ].flip()

        # layer +4 translate half a pict right
        c.layers[ lastIndex ].translate(w/2, j*y_offset)

        # create gradient layer
        c.gradient(pb.LINEAR, w/2, h)
        lastIndex = topLayer( c )

        # merge gradient with 
        c.merge([ lastIndex - 1 , lastIndex ])
        lastIndex = topLayer( c )

        c.layers[ lastIndex ].brightness(1.4)
        
        c.layers[ lastIndex ].mask()
        lastIndex = topLayer( c )

        c.layers[ lastIndex ].translate(i*w/3, j*y_offset)

        if random() &gt; 0.5:
            c.layers[ lastIndex ].flip()

        if random() &gt; 0.5:
            c.layers[ lastIndex ].blur()

c.draw(10, 10)
</t>
<t tx="karstenw.20170711131616.1">@others
if 0:
    # orange hue mask finish
    #print "Mr. Orange"
    top = c.fill((200,100,0))
    c.layers[top].opacity(30)
    c.layers[top].hue()

if paintoverlay:
    # paint overlay
    #print "VINCENT"
    top = c.layer( os.path.abspath("./paint.jpg") )
    w, h = c.layers[top].bounds()
    xs = WIDTH / float(w)
    ys = HEIGHT / float(h)
    s = max(xs,ys)
    c.layers[top].scale(s, s)
    c.layers[top].opacity(50)
    c.layers[top].overlay()



c.draw(0, 0)
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170711131630.1"># heavily inspired by https://www.nodebox.net/code/index.php/Landslide
W,H = 1280, 950
RATIO = W / H
import os
kwdbg = False

size(W, H)

background( 0.333 )

# need a different name; random is taken
import random as rnd

if kwdbg:
    # make random choices repeatable for debugging
    rnd.seed(0)

# import photobot
try:
    pb = ximport("photobot")
    pbh = ximport("pbhelpers")
except ImportError:
    pb = ximport("__init__")
    reload(pb)
from pbhelpers import *

# import extensions if nodebox version &lt; 1.9.18
try:
    imagefiles
except NameError:
    from nodeboxExtensions import *

# create the canvas
c = pb.canvas(int(WIDTH), int(HEIGHT))

# get all images from system "Desktop Pictures" folder
filetuples = imagefiles( "/Library/Desktop Pictures", False )

# filter out all 1 pix one color images by ignoring all files &lt; 100k
tiles = []
for t in filetuples:
    path, filesize, lastmodified, mode, islink = t
    if filesize &lt; 100000:
        continue
    tiles.append( path )

# shuffle the images
rnd.shuffle(tiles)
rnd.shuffle(tiles)
rnd.shuffle(tiles)


img1path = tiles.pop()
img2path = tiles.pop()


</t>
<t tx="karstenw.20170711131630.2">def placeImage(path, x, y, maxsize, name):
    img1 = pb.resizeImage(path, maxsize)
    top = c.layer(img1, name=name)
    c.layers[top].translate(x, y)
    w, h, = c.layers[ top ].bounds()
    return top, w, h



# CONFIGURATION

columns = 3
rows = 2

colwidth = int(WIDTH / columns)
rowheight = int(HEIGHT / rows)
maxsize = int(max(colwidth,rowheight)*1.2)

# print "colwidth/rowheight:", colwidth, rowheight

xgutter = colwidth * 0.0667
ygutter = rowheight * 0.0667
# print "xgutter/ygutter:", xgutter, ygutter

realwidth = colwidth - 1*xgutter
realheight = rowheight - 1*ygutter 

positions = list(grid(columns, rows, colwidth, rowheight))

randomblur = not kwdbg
paintoverlay = not kwdbg


#
# Base Image
#

#  create, scale and place the image
x, y = 0, 0
top, w, h = placeImage(img1path, x, y, W, "Image 1")


for position in positions:
    x, y = position


    # create image in canvas at 0,0
    p = tiles.pop()
    print p
    top, w, h = placeImage(p, 0, 0, maxsize, "Image %i,%i" % (x,y))

    # scale the layer to row height
    layer = c.layers[ top ]
    layer = scaleLayerToHeight( layer, rowheight )
    c.layers[ top ] = layer

    # uniform width
    #layer = c.layers[ top ]
    #layer = cropImageToRatioHorizontal( layer, RATIO )
    #c.layers[ top ] = layer

    # get the new image bounds - layer still valid
    w, h = layer.bounds()

    # add contrast - layer still valid
    layer.contrast(1.1)


    r = rnd.random()
    # 10%
    if 0 &lt; r &lt; 0.2:
        #print "20% LINEAR"
        # create gradient layer
        # top is now gradient index
        top = c.gradient(pb.LINEAR, w/2, h)
        c.layers[ top ].flip( pb.HORIZONTAL )

        # layer + 4 flip
        # c.layers[ top ].flip( pb.HORIZONTAL )

        # layer +4 translate half a pict right
        c.layers[ top ].translate(w/2, 0)

        # create gradient layer
        # top is now second gradient index
        top = c.gradient(pb.LINEAR, w/2, h)

        # merge both gradients; destroys top layer
        c.merge([ top-1 , top ])
    elif 0.2 &lt;= r &lt; 0.4:
        #print "20% SINE"
        top = c.gradient(pb.SINE, w, h)
        
    elif 0.4 &lt;= r &lt; 0.6:
        #print "20% RADIALCOSINE"
        top = c.gradient(pb.RADIALCOSINE, w, h)
        # c.layers[top].invert()
    elif 0.6 &lt;= r &lt; 0.8:
        #print "20% ROUNDRECT"
        # 25%
        top = c.gradient(pb.ROUNDRECT, w, h, "", radius=w/5.0, radius2=w/5.0)
    elif r &gt;= 0.8:
        #print "20% QUAD"
        top = c.gradient(pb.QUAD, w, h, "", 0, 0)
            
    # print "After mask"
    top = c.topLayer()
    c.layers[ top ].brightness(1.4)
    # mask destroys top layer
    c.layers[ top ].mask()

    # top layer is now image with mask
    top = c.topLayer()

    destx = x - xgutter
    desty = y - ygutter
    # print "Image@", x, y
    # c.layers[ top ].translate(destx, desty)
    c.layers[ top ].translate(x, y)

    if randomblur:
        if rnd.random() &gt; 0.5:
            #print "FLIP"
            c.layers[ top ].flip()

        if rnd.random() &gt; 0.5:
            #print "BLUR"
            c.layers[ top ].blur()

</t>
<t tx="karstenw.20170715181646.1">@language python
@tabwidth -4
@others
W,H = 542, 1050
&lt;&lt;initialisation&gt;&gt;

&lt;&lt;image1&gt;&gt;

&lt;&lt;image2&gt;&gt;

#
# Hue Images 1 &amp; 2
#

&lt;&lt;image34&gt;&gt;

c.layers[top].hue()
label("Hue Image2 over Image1", x, y)

#
# Hue Images 2 &amp; 1
#

&lt;&lt;image56&gt;&gt;

c.layers[top].hue()
label("Hue Image1 over Image2", x, y)

&lt;&lt;outro&gt;&gt;
</t>
<t tx="karstenw.20170715185201.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170715185207.1">size(800,800)
background(0.334)
pb = ximport("photobot")
reload(pb)

pbh = ximport("pbhelpers")
label = pbh.label


</t>
<t tx="karstenw.20170715185207.2">def dogradient(s):
    sx, sy = WIDTH, HEIGHT
    inset = 10
    c = pb.canvas(sx, sy)
    #c.fill((210, 210, 10))
    c.fill((85, 85, 85))
    r1, r2 = 72, 36
    x, y = inset, inset
    w, h = sx-inset-inset, sy-inset-inset
    grad1idx = c.gradient(s, w, h, radius=r1, radius2=r2)
    mask = c.gradient(s, w, h, radius=r1, radius2=r2)
    c.layers[mask].mask()
    c.layers[grad1idx].translate(x, y)
    label(s.upper(), x, y)
    c.draw(1, 1)
    canvas._grobs.reverse()

gradients = (
    pb.SOLID,
    pb.LINEAR,
    pb.RADIAL,
    pb.DIAMOND,
    pb.SINE,
    pb.COSINE,
    pb.ROUNDRECT,
    pb.RADIALCOSINE,
    pb.QUAD)


var("Gradient", MENU, default=dogradient, value=gradients)

dogradient("solid")
</t>
<t tx="karstenw.20170727231657.1">def cropimage( img, bounds):
    """Crop a pillow image at bounds(left, top, right, bottom)"""
    return img.crop( bounds )


</t>
<t tx="karstenw.20170727231803.1"></t>
<t tx="karstenw.20170727231827.1"></t>
<t tx="karstenw.20170727232236.1"></t>
<t tx="karstenw.20170727232434.1"></t>
<t tx="karstenw.20170727233343.1">def crop( self, bounds):

    """
    
    Crop a pillow image at bounds(left, top, right, bottom)
    """
    w0, h0 = self.img.size
    x, y = self.x, self.y
    left, top, right, bottom = bounds
    left = max(x, left)
    top = max(y, top)
    right = min(right, w0)
    bottom = min(bottom, h0)
    self.img = self.img.crop( (left, top, right, bottom) )
    self.w, self.h = self.img.size


</t>
</tnodes>
</leo_file>
