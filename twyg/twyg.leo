<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="karstenw.20170725105442.2" a="E"><vh>Twyg</vh>
<v t="karstenw.20170725105509.1"><vh>@clean __init__.py</vh>
<v t="karstenw.20170725105526.1"><vh>Declarations</vh></v>
<v t="karstenw.20170725105526.2"><vh>_fullname</vh></v>
<v t="karstenw.20170725105526.3"><vh>_init</vh></v>
<v t="karstenw.20170725105526.4"><vh>_has_levels</vh></v>
<v t="karstenw.20170725105526.5"><vh>_get_style</vh></v>
<v t="karstenw.20170725105526.6"><vh>_create_drawers</vh></v>
<v t="karstenw.20170725105526.7"><vh>get_scale_factor</vh></v>
<v t="karstenw.20170725105526.8"><vh>generate_output</vh></v>
<v t="karstenw.20170725105526.9"><vh>generate_output_nodebox</vh></v>
<v t="karstenw.20170725105526.10"><vh>_buildtree</vh></v>
<v t="karstenw.20170725105526.11"><vh>buildtree</vh></v>
</v>
<v t="karstenw.20170725105546.1" a="E"><vh>@clean cairowrapper.py</vh>
<v t="karstenw.20170725110856.1"><vh>Declarations</vh></v>
<v t="karstenw.20170725110856.2" a="E"><vh>class Color</vh>
<v t="karstenw.20170725110856.3"><vh>__init__</vh></v>
<v t="karstenw.20170725110856.4"><vh>__repr__</vh></v>
<v t="karstenw.20170725110856.5"><vh>copy</vh></v>
<v t="karstenw.20170725110856.6"><vh>rgba</vh></v>
<v t="karstenw.20170725110856.7"><vh>darken</vh></v>
<v t="karstenw.20170725110856.8"><vh>lighten</vh></v>
<v t="karstenw.20170725110856.9"><vh>blend</vh></v>
<v t="karstenw.20170725110856.10"><vh>_update_hsv</vh></v>
<v t="karstenw.20170725110856.11"><vh>_update_rgb</vh></v>
</v>
<v t="karstenw.20170725110856.12"><vh>color</vh></v>
<v t="karstenw.20170725110856.13" a="E"><vh>class Context</vh>
<v t="karstenw.20170725110856.14"><vh>__init__</vh></v>
<v t="karstenw.20170725110856.15"><vh>init</vh></v>
<v t="karstenw.20170725115953.1" a="E"><vh>SHAPES</vh>
<v t="karstenw.20170725110856.16"><vh>rect</vh></v>
<v t="karstenw.20170725110856.17"><vh>oval</vh></v>
<v t="karstenw.20170725110856.18"><vh>line</vh></v>
<v t="karstenw.20170725110856.19"><vh>arrow</vh></v>
<v t="karstenw.20170725110856.20"><vh>star</vh></v>
</v>
<v t="karstenw.20170725120016.1"><vh>PATH</vh>
<v t="karstenw.20170725110856.21"><vh>beginpath</vh></v>
<v t="karstenw.20170725110856.22"><vh>moveto</vh></v>
<v t="karstenw.20170725110856.23"><vh>lineto</vh></v>
<v t="karstenw.20170725110856.24"><vh>curveto</vh></v>
<v t="karstenw.20170725110856.25"><vh>findpath</vh></v>
<v t="karstenw.20170725110856.26"><vh>endpath</vh></v>
<v t="karstenw.20170725110856.27"><vh>drawpath</vh></v>
<v t="karstenw.20170725110856.28"><vh>beginclip</vh></v>
<v t="karstenw.20170725110856.29"><vh>endclip</vh></v>
<v t="karstenw.20170725110856.30"><vh>autoclosepath</vh></v>
</v>
<v t="karstenw.20170725120058.1"><vh>TRANSFORM</vh>
<v t="karstenw.20170725110856.31"><vh>transform</vh></v>
<v t="karstenw.20170725110856.32"><vh>translate</vh></v>
<v t="karstenw.20170725110856.33"><vh>rotate</vh></v>
<v t="karstenw.20170725110856.34"><vh>scale</vh></v>
<v t="karstenw.20170725110856.35"><vh>skew</vh></v>
<v t="karstenw.20170725110856.36"><vh>push</vh></v>
<v t="karstenw.20170725110856.37"><vh>pop</vh></v>
<v t="karstenw.20170725110856.38"><vh>reset</vh></v>
</v>
<v t="karstenw.20170725120123.1"><vh>COLOR</vh>
<v t="karstenw.20170725110856.39"><vh>outputmode</vh></v>
<v t="karstenw.20170725110856.40"><vh>colormode</vh></v>
<v t="karstenw.20170725110856.41"><vh>color</vh></v>
<v t="karstenw.20170725110856.42"><vh>fill</vh></v>
<v t="karstenw.20170725110856.43"><vh>nofill</vh></v>
<v t="karstenw.20170725110856.44"><vh>stroke</vh></v>
<v t="karstenw.20170725110856.45"><vh>nostroke</vh></v>
<v t="karstenw.20170725110856.46"><vh>strokewidth</vh></v>
<v t="karstenw.20170725110856.47"><vh>background</vh></v>
</v>
<v t="karstenw.20170725120152.1"><vh>TYPOGRAPHY</vh>
<v t="karstenw.20170725110856.48"><vh>font</vh></v>
<v t="karstenw.20170725110856.49"><vh>fontsize</vh></v>
<v t="karstenw.20170725110856.50"><vh>text</vh></v>
<v t="karstenw.20170725110856.51"><vh>textpath</vh></v>
<v t="karstenw.20170725110856.52"><vh>textwidth</vh></v>
<v t="karstenw.20170725110856.53"><vh>textheight</vh></v>
<v t="karstenw.20170725110856.54"><vh>textmetrics</vh></v>
<v t="karstenw.20170725110856.55"><vh>lineheight</vh></v>
<v t="karstenw.20170725110856.56"><vh>align</vh></v>
</v>
<v t="karstenw.20170725120215.1"><vh>IMAGE</vh>
<v t="karstenw.20170725110856.57"><vh>image</vh></v>
<v t="karstenw.20170725110856.58"><vh>imagesize</vh></v>
</v>
<v t="karstenw.20170725120232.1"><vh>UTILITY</vh>
<v t="karstenw.20170725110856.59"><vh>size</vh></v>
<v t="karstenw.20170725110856.60"><vh>var</vh></v>
<v t="karstenw.20170725110856.61"><vh>random</vh></v>
<v t="karstenw.20170725110856.62"><vh>choice</vh></v>
<v t="karstenw.20170725110856.63"><vh>grid</vh></v>
<v t="karstenw.20170725110856.64"><vh>files</vh></v>
<v t="karstenw.20170725110856.65"><vh>autotext</vh></v>
</v>
<v t="karstenw.20170725120250.1" a="E"><vh>COLORS LIBRARY</vh>
<v t="karstenw.20170725110856.66"><vh>rgba_color</vh></v>
<v t="karstenw.20170725110856.67"><vh>gradientfill</vh></v>
<v t="karstenw.20170725110856.68"><vh>shadow</vh></v>
<v t="karstenw.20170725110856.69"><vh>noshadow</vh></v>
</v>
<v t="karstenw.20170725120312.1" a="E"><vh>HELPER FUNCTIONS</vh>
<v t="karstenw.20170725110856.70"><vh>initsurface</vh></v>
<v t="karstenw.20170725110856.71"><vh>writesurface</vh></v>
<v t="karstenw.20170725110856.72"><vh>_make_color_obj</vh></v>
<v t="karstenw.20170725110856.73"><vh>_draw_stroke</vh></v>
<v t="karstenw.20170725110856.74"><vh>_draw</vh></v>
<v t="karstenw.20170725110856.75"><vh>_draw_shadow</vh></v>
<v t="karstenw.20170725110856.76"><vh>_render_bitmap_shadow</vh></v>
</v>
</v>
</v>
<v t="karstenw.20170725105558.1"><vh>@clean cmdline.py</vh>
<v t="karstenw.20170725110859.1"><vh>Declarations</vh></v>
<v t="karstenw.20170725110859.2"><vh>exit_error</vh></v>
<v t="karstenw.20170725110859.3"><vh>main</vh></v>
</v>
<v t="karstenw.20170725110620.1"><vh>@clean colorizer.py</vh>
<v t="karstenw.20170725110903.1"><vh>Declarations</vh></v>
<v t="karstenw.20170725110903.2"><vh>class Colorizer</vh>
<v t="karstenw.20170725110903.3"><vh>__init__</vh></v>
<v t="karstenw.20170725110903.4"><vh>_defaults_path</vh></v>
<v t="karstenw.20170725110903.5"><vh>_eval_func</vh></v>
<v t="karstenw.20170725110903.6"><vh>colorize</vh></v>
<v t="karstenw.20170725110903.7"><vh>background_color</vh></v>
<v t="karstenw.20170725110903.8"><vh>_calc_auto_textcolor</vh></v>
<v t="karstenw.20170725110903.9"><vh>_set_basecolor</vh></v>
</v>
<v t="karstenw.20170725110903.10"><vh>class CycleColorizer</vh>
<v t="karstenw.20170725110903.11"><vh>__init__</vh></v>
<v t="karstenw.20170725110903.12"><vh>_set_basecolor</vh></v>
</v>
<v t="karstenw.20170725110903.13"><vh>class DepthColorizer</vh>
<v t="karstenw.20170725110903.14"><vh>__init__</vh></v>
<v t="karstenw.20170725110903.15"><vh>_set_basecolor</vh></v>
</v>
<v t="karstenw.20170725110903.16"><vh>class BranchColorizer</vh>
<v t="karstenw.20170725110903.17"><vh>__init__</vh></v>
<v t="karstenw.20170725110903.18"><vh>_set_basecolor</vh></v>
</v>
<v t="karstenw.20170725110903.19"><vh>colorizer_by_name</vh></v>
</v>
<v t="karstenw.20170725110631.1"><vh>@clean common.py</vh>
<v t="karstenw.20170725110905.1"><vh>Declarations</vh></v>
<v t="karstenw.20170725110905.2"><vh>init</vh></v>
<v t="karstenw.20170725110905.3"><vh>validate_margins</vh></v>
<v t="karstenw.20170725110905.4"><vh>calculate_margins</vh></v>
<v t="karstenw.20170725110905.5"><vh>brightness</vh></v>
<v t="karstenw.20170725110905.6"><vh>loadjson</vh></v>
<v t="karstenw.20170725110905.7"><vh>textwidth</vh></v>
<v t="karstenw.20170725110905.8"><vh>createpath</vh></v>
</v>
<v t="karstenw.20170725110641.1"><vh>@clean config.py</vh>
<v t="karstenw.20170725110908.1"><vh>Declarations</vh></v>
<v t="karstenw.20170725110908.2"><vh>class ConfigError</vh>
<v t="karstenw.20170725110908.3"><vh>__init__</vh></v>
<v t="karstenw.20170725110908.4"><vh>__str__</vh></v>
</v>
<v t="karstenw.20170725110908.5"><vh>class Pattern</vh>
<v t="karstenw.20170725110908.6"><vh>__init__</vh></v>
</v>
<v t="karstenw.20170725110908.7"><vh>tokenize</vh></v>
<v t="karstenw.20170725110908.8"><vh>buildconfig</vh></v>
<v t="karstenw.20170725110908.9"><vh>_tokenize_file</vh></v>
<v t="karstenw.20170725110908.10"><vh>loaddefaults</vh></v>
<v t="karstenw.20170725110908.11"><vh>loadconfig</vh></v>
<v t="karstenw.20170725110908.12"><vh>find_config</vh></v>
<v t="karstenw.20170725110908.13"><vh>defaults_path</vh></v>
<v t="karstenw.20170725110908.14"><vh>colors_path</vh></v>
<v t="karstenw.20170725110908.15"><vh>config_path</vh></v>
<v t="karstenw.20170725110908.16"><vh>include_path</vh></v>
<v t="karstenw.20170725110908.17"><vh>parsecolor</vh></v>
<v t="karstenw.20170725110908.18"><vh>init_variable_table_defaults</vh></v>
<v t="karstenw.20170725110908.19"><vh>class SymbolBase</vh>
<v t="karstenw.20170725110908.20"><vh>nud</vh></v>
<v t="karstenw.20170725110908.21"><vh>led</vh></v>
<v t="karstenw.20170725110908.22"><vh>__repr__</vh></v>
<v t="karstenw.20170725110908.23"><vh>isoperator</vh></v>
</v>
<v t="karstenw.20170725110908.24"><vh>symbol</vh></v>
<v t="karstenw.20170725110908.25"><vh>operator</vh></v>
<v t="karstenw.20170725110908.26"><vh>infix</vh></v>
<v t="karstenw.20170725110908.27"><vh>prefix</vh></v>
<v t="karstenw.20170725110908.28"><vh>method</vh></v>
<v t="karstenw.20170725110908.29"><vh>nud</vh></v>
<v t="karstenw.20170725110908.30"><vh>led</vh></v>
<v t="karstenw.20170725110908.31"><vh>led</vh></v>
<v t="karstenw.20170725110908.32"><vh>nud</vh></v>
<v t="karstenw.20170725110908.33"><vh>unaryop</vh></v>
<v t="karstenw.20170725110908.34"><vh>binaryop</vh></v>
<v t="karstenw.20170725110908.35"><vh>eval</vh></v>
<v t="karstenw.20170725110908.36"><vh>eval</vh></v>
<v t="karstenw.20170725110908.37"><vh>isfunction</vh></v>
<v t="karstenw.20170725110908.38"><vh>eval</vh></v>
<v t="karstenw.20170725110908.39"><vh>eval</vh></v>
<v t="karstenw.20170725110908.40"><vh>dot_operator</vh></v>
<v t="karstenw.20170725110908.41"><vh>eval</vh></v>
<v t="karstenw.20170725110908.42"><vh>eval</vh></v>
<v t="karstenw.20170725110908.43"><vh>nexttoken</vh></v>
<v t="karstenw.20170725110908.44"><vh>expression</vh></v>
<v t="karstenw.20170725110908.45"><vh>advance</vh></v>
<v t="karstenw.20170725110908.46"><vh>parse_expr</vh></v>
<v t="karstenw.20170725110908.47"><vh>eval_expr</vh></v>
<v t="karstenw.20170725110908.48"><vh>class Level</vh>
<v t="karstenw.20170725110908.49"><vh>__init__</vh></v>
<v t="karstenw.20170725110908.50"><vh>__repr__</vh></v>
<v t="karstenw.20170725110908.51"><vh>_eval</vh></v>
<v t="karstenw.20170725110908.52"><vh>selects</vh></v>
</v>
<v t="karstenw.20170725110908.53"><vh>createlevel</vh></v>
<v t="karstenw.20170725110908.54"><vh>class SectionLevel</vh>
<v t="karstenw.20170725110908.55"><vh>__init__</vh></v>
<v t="karstenw.20170725110908.56"><vh>__repr__</vh></v>
</v>
<v t="karstenw.20170725110908.57"><vh>class Property</vh>
<v t="karstenw.20170725110908.58"><vh>__init__</vh></v>
<v t="karstenw.20170725110908.59"><vh>eval</vh></v>
</v>
<v t="karstenw.20170725110908.60"><vh>class StringProperty</vh>
<v t="karstenw.20170725110908.61"><vh>_validate</vh></v>
</v>
<v t="karstenw.20170725110908.62"><vh>class NumberProperty</vh>
<v t="karstenw.20170725110908.63"><vh>__init__</vh></v>
<v t="karstenw.20170725110908.64"><vh>_validate</vh></v>
</v>
<v t="karstenw.20170725110908.65"><vh>class ColorProperty</vh>
<v t="karstenw.20170725110908.66"><vh>_validate</vh></v>
</v>
<v t="karstenw.20170725110908.67"><vh>class EnumProperty</vh>
<v t="karstenw.20170725110908.68"><vh>__init__</vh></v>
<v t="karstenw.20170725110908.69"><vh>eval</vh></v>
</v>
<v t="karstenw.20170725110908.70"><vh>class BooleanProperty</vh>
<v t="karstenw.20170725110908.71"><vh>eval</vh></v>
</v>
<v t="karstenw.20170725110908.72"><vh>class ArrayProperty</vh>
<v t="karstenw.20170725110908.73"><vh>__init__</vh></v>
<v t="karstenw.20170725110908.74"><vh>_validate</vh></v>
</v>
<v t="karstenw.20170725110908.75"><vh>class Properties</vh>
<v t="karstenw.20170725110908.76"><vh>__init__</vh></v>
</v>
<v t="karstenw.20170725110908.77"><vh>format_paramvalue_error</vh></v>
<v t="karstenw.20170725110908.78"><vh>get_stylename</vh></v>
</v>
<v t="karstenw.20170725110659.1"><vh>@clean connection.py</vh>
<v t="karstenw.20170725110911.1"><vh>Declarations</vh></v>
<v t="karstenw.20170725110911.2"><vh>defaults_path</vh></v>
<v t="karstenw.20170725110911.3"><vh>class CurveConnectionDrawer</vh>
<v t="karstenw.20170725110911.4"><vh>__init__</vh></v>
<v t="karstenw.20170725110911.5"><vh>_eval_func</vh></v>
<v t="karstenw.20170725110911.6"><vh>draw</vh></v>
</v>
<v t="karstenw.20170725110911.7"><vh>class JunctionConnectionDrawer</vh>
<v t="karstenw.20170725110911.8"><vh>__init__</vh></v>
<v t="karstenw.20170725110911.9"><vh>_eval_func</vh></v>
<v t="karstenw.20170725110911.10"><vh>draw</vh></v>
<v t="karstenw.20170725110911.11"><vh>_draw</vh></v>
</v>
<v t="karstenw.20170725110911.12"><vh>conndrawer_by_name</vh></v>
</v>
<v t="karstenw.20170725110703.1"><vh>@clean css3colors.py</vh>
<v t="karstenw.20170725110914.1"><vh>Declarations</vh></v>
<v t="karstenw.20170725110914.2"><vh>_parse_hex</vh></v>
<v t="karstenw.20170725110914.3"><vh>_conv_rgb</vh></v>
<v t="karstenw.20170725110914.4"><vh>_conv_percent</vh></v>
<v t="karstenw.20170725110914.5"><vh>_conv_alpha</vh></v>
<v t="karstenw.20170725110914.6"><vh>_conv_hue</vh></v>
<v t="karstenw.20170725110914.7"><vh>color_to_rgba</vh></v>
<v t="karstenw.20170725110914.8"><vh>rgba_to_color</vh></v>
</v>
<v t="karstenw.20170725110730.1"><vh>@clean geom.py</vh>
<v t="karstenw.20170725110917.1"><vh>Declarations</vh></v>
<v t="karstenw.20170725110917.2"><vh>class Vector2</vh>
<v t="karstenw.20170725110917.3"><vh>__init__</vh></v>
<v t="karstenw.20170725110917.4"><vh>__repr__</vh></v>
<v t="karstenw.20170725110917.5"><vh>magnitude</vh></v>
<v t="karstenw.20170725110917.6"><vh>angle</vh></v>
<v t="karstenw.20170725110917.7"><vh>normalize</vh></v>
<v t="karstenw.20170725110917.8"><vh>rotate</vh></v>
<v t="karstenw.20170725110917.9"><vh>__add__</vh></v>
<v t="karstenw.20170725110917.10"><vh>__iadd__</vh></v>
<v t="karstenw.20170725110917.11"><vh>__sub__</vh></v>
<v t="karstenw.20170725110917.12"><vh>__isub__</vh></v>
<v t="karstenw.20170725110917.13"><vh>__mul__</vh></v>
<v t="karstenw.20170725110917.14"><vh>__rmul__</vh></v>
<v t="karstenw.20170725110917.15"><vh>__imul__</vh></v>
<v t="karstenw.20170725110917.16"><vh>__div__</vh></v>
<v t="karstenw.20170725110917.17"><vh>__idiv__</vh></v>
</v>
<v t="karstenw.20170725110917.18"><vh>class Rectangle</vh>
<v t="karstenw.20170725110917.19"><vh>__init__</vh></v>
<v t="karstenw.20170725110917.20"><vh>__repr__</vh></v>
<v t="karstenw.20170725110917.21"><vh>params</vh></v>
<v t="karstenw.20170725110917.22"><vh>points</vh></v>
<v t="karstenw.20170725110917.23"><vh>expand</vh></v>
</v>
</v>
<v t="karstenw.20170725110734.1"><vh>@clean geomutils.py</vh>
<v t="karstenw.20170725110919.1"><vh>Declarations</vh></v>
<v t="karstenw.20170725110919.2"><vh>calc_regular_polygon_points</vh></v>
<v t="karstenw.20170725110919.3"><vh>calc_regular_polygon_intersections</vh></v>
<v t="karstenw.20170725110919.4"><vh>calc_ellipse_intersections</vh></v>
<v t="karstenw.20170725110919.5"><vh>slice_shape</vh></v>
<v t="karstenw.20170725110919.6"><vh>slice_ellipse</vh></v>
<v t="karstenw.20170725110919.7"><vh>arcpath</vh></v>
<v t="karstenw.20170725110919.8"><vh>halfcircle</vh></v>
<v t="karstenw.20170725110919.9"><vh>round_corner</vh></v>
<v t="karstenw.20170725110919.10"><vh>round_poly</vh></v>
<v t="karstenw.20170725110919.11"><vh>rounded_rect</vh></v>
<v t="karstenw.20170725110919.12"><vh>intersect</vh></v>
<v t="karstenw.20170725110919.13"><vh>offset_poly</vh></v>
</v>
<v t="karstenw.20170725110746.1"><vh>@clean hyphenator.py</vh>
<v t="karstenw.20170725110922.1"><vh>Declarations</vh></v>
<v t="karstenw.20170725110922.2"><vh>class Hyphenator</vh>
<v t="karstenw.20170725110922.3"><vh>__init__</vh></v>
<v t="karstenw.20170725110922.4"><vh>_insert_pattern</vh></v>
<v t="karstenw.20170725110922.5"><vh>hyphenate_word</vh></v>
</v>
</v>
<v t="karstenw.20170725110753.1"><vh>@clean layout.py</vh>
<v t="karstenw.20170725110924.1"><vh>Declarations</vh></v>
<v t="karstenw.20170725110924.2"><vh>class Layout</vh>
<v t="karstenw.20170725110924.3"><vh>__init__</vh></v>
<v t="karstenw.20170725110924.4"><vh>_defaults_path</vh></v>
<v t="karstenw.20170725110924.5"><vh>_eval_func</vh></v>
<v t="karstenw.20170725110924.6"><vh>precalc_layout</vh></v>
<v t="karstenw.20170725110924.7"><vh>node_orientation</vh></v>
<v t="karstenw.20170725110924.8"><vh>_splitnodes</vh></v>
<v t="karstenw.20170725110924.9"><vh>calclayout</vh></v>
<v t="karstenw.20170725110924.10"><vh>_getchildren</vh></v>
<v t="karstenw.20170725110924.11"><vh>_calc_child_maxwidth</vh></v>
<v t="karstenw.20170725110924.12"><vh>_calc_x</vh></v>
<v t="karstenw.20170725110924.13"><vh>_calc_y</vh></v>
<v t="karstenw.20170725110924.14"><vh>childrenheight</vh></v>
</v>
<v t="karstenw.20170725110924.15"><vh>layout_by_name</vh></v>
</v>
<v t="karstenw.20170725110759.1"><vh>@clean node.py</vh>
<v t="karstenw.20170725110927.1"><vh>Declarations</vh></v>
<v t="karstenw.20170725110927.2"><vh>class NodeDrawer</vh>
<v t="karstenw.20170725110927.3"><vh>__init__</vh></v>
<v t="karstenw.20170725110927.4"><vh>_defaults_path</vh></v>
<v t="karstenw.20170725110927.5"><vh>_eval_func</vh></v>
<v t="karstenw.20170725110927.6"><vh>precalc_node</vh></v>
<v t="karstenw.20170725110927.7"><vh>connection_point</vh></v>
<v t="karstenw.20170725110927.8"><vh>draw</vh></v>
<v t="karstenw.20170725110927.9"><vh>_draw_gradient_shape</vh></v>
<v t="karstenw.20170725110927.10"><vh>_precalc_text</vh></v>
<v t="karstenw.20170725110927.11"><vh>_calc_shape_path</vh></v>
<v t="karstenw.20170725110927.12"><vh>_drawtext</vh></v>
<v t="karstenw.20170725110927.13"><vh>_center_text_vertically</vh></v>
</v>
<v t="karstenw.20170725110927.14"><vh>class RectNodeDrawer</vh>
<v t="karstenw.20170725110927.15"><vh>__init__</vh></v>
<v t="karstenw.20170725110927.16"><vh>_calc_shape_path</vh></v>
</v>
<v t="karstenw.20170725110927.17"><vh>class BoxNodeDrawer</vh>
<v t="karstenw.20170725110927.18"><vh>__init__</vh></v>
<v t="karstenw.20170725110927.19"><vh>precalc_node</vh></v>
<v t="karstenw.20170725110927.20"><vh>draw</vh></v>
</v>
<v t="karstenw.20170725110927.21"><vh>class LineNodeDrawer</vh>
<v t="karstenw.20170725110927.22"><vh>__init__</vh></v>
<v t="karstenw.20170725110927.23"><vh>precalc_node</vh></v>
<v t="karstenw.20170725110927.24"><vh>draw</vh></v>
</v>
<v t="karstenw.20170725110927.25"><vh>class PolyNodeDrawer</vh>
<v t="karstenw.20170725110927.26"><vh>__init__</vh></v>
<v t="karstenw.20170725110927.27"><vh>precalc_node</vh></v>
<v t="karstenw.20170725110927.28"><vh>_calc_shape_path</vh></v>
</v>
<v t="karstenw.20170725110927.29"><vh>class OvalNodeDrawer</vh>
<v t="karstenw.20170725110927.30"><vh>__init__</vh></v>
<v t="karstenw.20170725110927.31"><vh>_calc_shape_path</vh></v>
</v>
<v t="karstenw.20170725110927.32"><vh>class CapsuleNodeDrawer</vh>
<v t="karstenw.20170725110927.33"><vh>__init__</vh></v>
<v t="karstenw.20170725110927.34"><vh>draw</vh></v>
</v>
<v t="karstenw.20170725110927.35"><vh>nodedrawer_by_name</vh></v>
</v>
<v t="karstenw.20170725110812.1"><vh>@clean ordereddict.py</vh>
<v t="karstenw.20170725110929.1"><vh>Declarations</vh></v>
<v t="karstenw.20170725110929.2"><vh>class OrderedDict</vh>
<v t="karstenw.20170725110929.3"><vh>__init__</vh></v>
<v t="karstenw.20170725110929.4"><vh>__setitem__</vh></v>
<v t="karstenw.20170725110929.5"><vh>__delitem__</vh></v>
<v t="karstenw.20170725110929.6"><vh>__iter__</vh></v>
<v t="karstenw.20170725110929.7"><vh>__reversed__</vh></v>
<v t="karstenw.20170725110929.8"><vh>clear</vh></v>
<v t="karstenw.20170725110929.9"><vh>popitem</vh></v>
<v t="karstenw.20170725110929.10"><vh>keys</vh></v>
<v t="karstenw.20170725110929.11"><vh>values</vh></v>
<v t="karstenw.20170725110929.12"><vh>items</vh></v>
<v t="karstenw.20170725110929.13"><vh>iterkeys</vh></v>
<v t="karstenw.20170725110929.14"><vh>itervalues</vh></v>
<v t="karstenw.20170725110929.15"><vh>iteritems</vh></v>
<v t="karstenw.20170725110929.16"><vh>update</vh></v>
<v t="karstenw.20170725110929.17"><vh>pop</vh></v>
<v t="karstenw.20170725110929.18"><vh>setdefault</vh></v>
<v t="karstenw.20170725110929.19"><vh>__repr__</vh></v>
<v t="karstenw.20170725110929.20"><vh>__reduce__</vh></v>
<v t="karstenw.20170725110929.21"><vh>copy</vh></v>
<v t="karstenw.20170725110929.22"><vh>fromkeys</vh></v>
<v t="karstenw.20170725110929.23"><vh>__eq__</vh></v>
<v t="karstenw.20170725110929.24"><vh>__ne__</vh></v>
<v t="karstenw.20170725110929.25"><vh>viewkeys</vh></v>
<v t="karstenw.20170725110929.26"><vh>viewvalues</vh></v>
<v t="karstenw.20170725110929.27"><vh>viewitems</vh></v>
</v>
</v>
<v t="karstenw.20170725110820.1"><vh>@clean textwrap.py</vh>
<v t="karstenw.20170725110932.1"><vh>Declarations</vh></v>
<v t="karstenw.20170725110932.2"><vh>_calc_inside_rects</vh></v>
<v t="karstenw.20170725110932.3"><vh>_hyphenate_word</vh></v>
<v t="karstenw.20170725110932.4"><vh>_splittext</vh></v>
<v t="karstenw.20170725110932.5"><vh>_wraptext</vh></v>
<v t="karstenw.20170725110932.6"><vh>wrap_rect</vh></v>
<v t="karstenw.20170725110932.7"><vh>wrap_shape</vh></v>
</v>
<v t="karstenw.20170725110846.1"><vh>@clean tree.py</vh>
<v t="karstenw.20170725110934.1"><vh>Declarations</vh></v>
<v t="karstenw.20170725110934.2"><vh>class Direction</vh></v>
<v t="karstenw.20170725110934.3"><vh>opposite_dir</vh></v>
<v t="karstenw.20170725110934.4"><vh>class Node</vh>
<v t="karstenw.20170725110934.5"><vh>__init__</vh></v>
<v t="karstenw.20170725110934.6"><vh>isleaf</vh></v>
<v t="karstenw.20170725110934.7"><vh>isroot</vh></v>
<v t="karstenw.20170725110934.8"><vh>depth</vh></v>
<v t="karstenw.20170725110934.9"><vh>ancestor</vh></v>
<v t="karstenw.20170725110934.10"><vh>direction</vh></v>
<v t="karstenw.20170725110934.11"><vh>getchildren</vh></v>
<v t="karstenw.20170725110934.12"><vh>connection_point</vh></v>
<v t="karstenw.20170725110934.13"><vh>shiftbranch</vh></v>
</v>
<v t="karstenw.20170725110934.14"><vh>class TreeBuilder</vh>
<v t="karstenw.20170725110934.15"><vh>build_tree</vh></v>
<v t="karstenw.20170725110934.16"><vh>_build_tree</vh></v>
</v>
<v t="karstenw.20170725110934.17"><vh>class Tree</vh>
<v t="karstenw.20170725110934.18"><vh>__init__</vh></v>
<v t="karstenw.20170725110934.19"><vh>print_tree</vh></v>
<v t="karstenw.20170725110934.20"><vh>calclayout</vh></v>
<v t="karstenw.20170725110934.21"><vh>shiftnodes</vh></v>
<v t="karstenw.20170725110934.22"><vh>draw</vh></v>
<v t="karstenw.20170725110934.23"><vh>background_color</vh></v>
<v t="karstenw.20170725110934.24"><vh>_assign_drawers</vh></v>
<v t="karstenw.20170725110934.25"><vh>_print_tree</vh></v>
<v t="karstenw.20170725110934.26"><vh>_collect_nodes</vh></v>
<v t="karstenw.20170725110934.27"><vh>_draw_nodes</vh></v>
<v t="karstenw.20170725110934.28"><vh>_draw_connections</vh></v>
<v t="karstenw.20170725110934.29"><vh>_colorize_nodes</vh></v>
<v t="karstenw.20170725110934.30"><vh>_calcbbox</vh></v>
<v t="karstenw.20170725110934.31"><vh>_calcbbox_recurse</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="karstenw.20170725105442.2"></t>
<t tx="karstenw.20170725105509.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170725105526.1">__version__ = '0.1dev'

import os, sys

#from twyg.cairowrapper import context as ctx
from twyg.common import calculate_margins, loadjson

from twyg.config import (NODE_CONFIG, CONNECTION_CONFIG, LAYOUT_CONFIG,
                         COLOR_CONFIG, STYLE, DEFAULT_LEVEL,
                         Level, SectionLevel, ConfigError,
                         get_stylename, createlevel, loadconfig, config_path)

from twyg.layout import layout_by_name
from twyg.tree import Tree

import twyg.colorizer
import twyg.config
import twyg.connection
import twyg.node

# Detect nodebox
try:
    #print "_fullname(_ctx)", repr(_fullname(_ctx))
    #print
    #nodebox = _fullname(_ctx) == 'nodebox.graphics.Context'
    nodebox = 'nodebox.graphics.Context'
except NameError:
    print "NO NODEBOX!"
    nodebox = False


# Determine home directories
import twyg.common

if nodebox:
    import inspect, os

    twyg.common.TWYG_HOME = os.path.dirname(os.path.abspath(
        os.path.join(inspect.getfile(inspect.currentframe()), '..'))
    )

else:
    if 'TWYG_HOME' in os.environ:
        twyg.common.TWYG_HOME = os.environ['TWYG_HOME']
    else:
        twyg.common.TWYG_HOME = os.path.join(os.path.expanduser('~'), '.twyg')


_initialized = False


</t>
<t tx="karstenw.20170725105526.10">def _buildtree(data_fname, config_fname, colorscheme):
    data = loadjson(data_fname)
    config = loadconfig(config_path(config_fname))
    return twyg.buildtree(data, config, colorscheme)


</t>
<t tx="karstenw.20170725105526.11">def buildtree(data, config, colorscheme_path=None):
    """
    # TODO
    Build a `Tree` object from a nested tree data structure according to
    the rules specified in the configuration and apply a colorscheme.

    This method does not perform the actual tree layouting and drawing;
    it stops after creating a ``Tree`` object initialized with the
    correct drawer objects.

    `data`
         Hierarchical tree structure (dicts, lists, TODO)

    `config'
        Tree visualisation configuration.

    `colorscheme_path`
        Colorscheme to use.
    """

    _init()

    # Layout section
    section = LAYOUT_CONFIG
    c = config[section]
    if _has_levels(c):
        # TODO more detailed error message
        raise Exception('Layout section cannot have levels')

    style = _get_style(section, c)
    layout_cls = layout_by_name(style)
    layout = layout_cls(c)

    nodedrawers = _create_drawers(
        config, NODE_CONFIG,
        factory_func=twyg.node.nodedrawer_by_name
    )

    conndrawers = _create_drawers(
        config, CONNECTION_CONFIG,
        factory_func=twyg.connection.conndrawer_by_name
    )

    colorizers = _create_drawers(
        config, COLOR_CONFIG,
        factory_func=twyg.colorizer.colorizer_by_name,
        constr_args=(colorscheme_path,)
    )

    return Tree(layout, nodedrawers, conndrawers, colorizers, data)

</t>
<t tx="karstenw.20170725105526.2">def _fullname(o):
    """ Get the fully qualified class name of an object. """
    module = o.__class__.__module__
    if module is None or module == str.__class__.__module__:
        return o.__class__.__name__
    return module + '.' + o.__class__.__name__


</t>
<t tx="karstenw.20170725105526.3">def _init():
    """
    Autodetect the available drawing backend and initialize the system
    with the correct backend (PyCairo or NodeBox1).
    """
    global _initialized
    if _initialized:
        return

    if nodebox:
        global _ctx
    else:
        from twyg.cairowrapper import context as _ctx

    twyg.common.init(nodebox=nodebox, ctx=_ctx)

    # Inject the drawing context manually into the modules that need
    # access to the drawing functions (we need to it this way to keep
    # the NodeBox1 compatibility).

    twyg.config._ctx = _ctx

    twyg.colorizer._ctx = _ctx
    twyg.common._ctx = _ctx
    twyg.connection._ctx = _ctx
    twyg.node._ctx = _ctx

    _initialized = True


</t>
<t tx="karstenw.20170725105526.4">def _has_levels(section):
    """ Check if a given configuration section has levels or not. """
    # Bit of a hack...
    num_dicts = [x for x in section.values() if type(x) == dict]
    return len(num_dicts) == len(section)


</t>
<t tx="karstenw.20170725105526.5">def _get_style(section, config):
    """
    Get the style name associated with a given configuration
    section.
    """
    style = get_stylename(section, config)
    del config[STYLE]
    return style


</t>
<t tx="karstenw.20170725105526.6">def _create_drawers(config, section, factory_func, constr_args=()):
    """
    Create a list of SectionLevel objects for a given configuration
    section from a full configuration.
    """
    c = config[section]
    level_dict = c if _has_levels(c) else {DEFAULT_LEVEL: c}
    drawers = []

    for levelname, conf in level_dict.iteritems():
        style = _get_style(section + '.' + levelname, conf)
        level = createlevel(levelname, conf)
        drawer_class = factory_func(style)
        drawer = drawer_class(conf, *constr_args)
        drawers.append(SectionLevel(level, drawer))

    return drawers


</t>
<t tx="karstenw.20170725105526.7">def get_scale_factor(dpi, scale):
    return dpi / 72.0 * scale     # 1 point = 1/72 inch


</t>
<t tx="karstenw.20170725105526.8">def generate_output(data_fname, config_fname, out_fname, outformat,
                    colorscheme=None, scale=1.0, margins=['10%', '5%']):
    """
    TODO
    """

    tree = _buildtree(data_fname, config_fname, colorscheme)

    # Temporary context for layout calculations (need an actual graphics
    # context to be able to work with fonts &amp; text extents). Note that
    # 'None' is given for the output filename, so a failed run won't
    # overwrite an already existing file with an empty one. The actual
    # output file will be created later.
    _ctx.initsurface(1, 1, outformat, None, scale)

    width, height = tree.calclayout()

    # Margins can be given as percentages of the total graph size,
    # that's why we have to wait with the margin calculations until the
    # layout is complete
    padtop, padleft, padbottom, padright = calculate_margins(width, height,
                                                             margins)
    width += padleft + padright
    height += padtop + padbottom

    # Center tree
    tree.shiftnodes(padleft, padtop)

    # Create output file
    _ctx.initsurface(width, height, outformat, out_fname, scale)
    _ctx.background(tree.background_color())

    tree.draw()
    _ctx.writesurface()


</t>
<t tx="karstenw.20170725105526.9">def generate_output_nodebox(data_fname, config_fname, colorscheme=None,
                            margins=['10%', '5%']):

    tree = _buildtree(data_fname, config_fname, colorscheme)
    width, height = tree.calclayout()

    padtop, padleft, padbottom, padright = calculate_margins(width, height,
                                                             margins)
    width += padleft + padright
    height += padtop + padbottom

    # Center tree
    tree.shiftnodes(padleft, padtop)

    _ctx.size(width, height)
    _ctx.background(tree.background_color())

    tree.draw()


</t>
<t tx="karstenw.20170725105546.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20170725105558.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170725110620.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170725110631.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170725110641.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170725110659.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170725110703.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170725110730.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170725110734.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170725110746.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170725110753.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170725110759.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170725110812.1">## {{{ http://code.activestate.com/recipes/576693/ (r9)

# Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.
# Passes Python2.7's test suite and incorporates all the latest updates.

@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170725110820.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170725110846.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20170725110856.1">##############################################################################
#                                                                            #
#   NodeBox 1.9.5 -&gt; Pycairo wrapper                                         #
#                                                                            #
##############################################################################

import cairo, colorsys, math


</t>
<t tx="karstenw.20170725110856.10">def _update_hsv(self):
    self.h, self.s, self.v = colorsys.rgb_to_hsv(self.r, self.g, self.b)

</t>
<t tx="karstenw.20170725110856.11">def _update_rgb(self):
    self.r, self.g, self.b = colorsys.hsv_to_rgb(self.h, self.s, self.v)


</t>
<t tx="karstenw.20170725110856.12">def color(*args):
    # Only K(A) &amp; RGB(A) modes are supported, HSB(A) &amp; CMYK(A) are not
    n = len(args)
    if n == 1:
        r = g = b = args[0]
        a = 1.0
    elif n == 2:
        r = g = b = args[0]
        a = args[1]
    elif n == 3:
        r, g, b = args
        a = 1.0
    elif n == 4:
        r, g, b, a = args
    else:
        raise ValueError, "Invalid color value: '%s'" % args

    r = min(max(0.0, r), 1.0)
    g = min(max(0.0, g), 1.0)
    b = min(max(0.0, b), 1.0)
    a = min(max(0.0, a), 1.0)

    return Color(r, g, b, a)


</t>
<t tx="karstenw.20170725110856.13">#=============================================================================#
#=  NODEBOX COMMANDS                                                         =#
#=============================================================================#

class Context(object):

    @others
context = Context()

</t>
<t tx="karstenw.20170725110856.14">def __init__(self):
    self._backgroundcolor = None
    self._fillcolor = None
    self._strokecolor = None
    self._strokewidth = 1.0
    self._autoclosepath = True
    self._fontname = 'Helvetica'
    self._fontsize = 12.0
    self._lineheight = 1.5

    self._shadow = False
    self._shadow_dx = 0
    self._shadow_dy = 0
    self._shadow_radius = 3
    self._shadow_color = color(0, 0, 0, 1)
    self._shadow_blur_passes = 2
    self._bitmap_dpi = 150

</t>
<t tx="karstenw.20170725110856.15"># TODO call on init
def init():
    self.font(self._fontname, self._fontsize)
    self.strokewidth(self._strokewidth)

</t>
<t tx="karstenw.20170725110856.16">def rect(self, x, y, width, height, roundness=0.0, draw=True):
    # Negative width &amp; height behaviour not implemented
    # Formula for rounded rectangle taken from NodeBox 1 source code
    c = self._ctx

    if roundness == 0:
        c.rectangle(x, y, width, height)
    else:
        curve = min(width * roundness, height * roundness)
        xw = x + width
        yh = y + height

        c.move_to(x, y + curve)
        c.curve_to(x, y, x, y, x + curve, y)
        c.line_to(xw - curve, y)
        c.curve_to(xw, y, xw, y, xw, y + curve)
        c.line_to(xw, yh - curve)
        c.curve_to(xw, yh, xw, yh, xw - curve, yh)
        c.line_to(x + curve, yh)
        c.curve_to(x, yh, x, yh, x, yh - curve)
        c.close_path()

    if draw:
        self._draw()
    else:
        path = c.copy_path()
        c.new_path()
        return path

</t>
<t tx="karstenw.20170725110856.17">def oval(self, x, y, width, height, draw=True):
    c = self._ctx
    # Negative width &amp; height behaviour not implemented
    if width == 0 or height == 0:
        return

    cx = x + width / 2.
    cy = y + height / 2.
    r = width / 2.
    yscale = float(height) / width

    c.new_path()
    c.save()
    c.scale(1, yscale)
    c.arc(cx, cy / yscale, r, 0, 2 * math.pi)
    c.restore()

    if draw:
        self._draw()
    else:
        path = c.copy_path()
        c.new_path()
        return path

</t>
<t tx="karstenw.20170725110856.18">def line(self, x1, y1, x2, y2, draw=True):
    c = self._ctx
    c.move_to(x1, y1)
    c.line_to(x2, y2)

    if draw:
        self._draw_stroke()
    else:
        path = c.copy_path()
        c.new_path()
        return path

</t>
<t tx="karstenw.20170725110856.19">def arrow(x, y, width, type, draw=True):
    raise NotImplementedError

</t>
<t tx="karstenw.20170725110856.2">class Color(object):

    @others
</t>
<t tx="karstenw.20170725110856.20">def star(x, y, points=20, outer=100, inner=50, draw=True):
    raise NotImplementedError

</t>
<t tx="karstenw.20170725110856.21">def beginpath(self, x, y):
    self._ctx.move_to(x, y)

</t>
<t tx="karstenw.20170725110856.22">def moveto(self, x, y):
    self._ctx.move_to(x, y)

</t>
<t tx="karstenw.20170725110856.23">def lineto(self, x, y):
    self._ctx.line_to(x, y)

</t>
<t tx="karstenw.20170725110856.24">def curveto(self, x1, y1, x2, y2, x3, y3):
    self._ctx.curve_to(x1, y1, x2, y2, x3, y3)

</t>
<t tx="karstenw.20170725110856.25">def findpath(list, curvature=1.0):
    raise NotImplementedError

</t>
<t tx="karstenw.20170725110856.26">def endpath(self, draw=True):
    if self._autoclosepath:
        self._ctx.close_path()

    if draw:
        self._draw()
    else:
        path = self._ctx.copy_path()
        self._ctx.new_path()
        return path

</t>
<t tx="karstenw.20170725110856.27">def drawpath(self, path):
    self._ctx.append_path(path)
    self._draw()

</t>
<t tx="karstenw.20170725110856.28">def beginclip(self, path):
    self._ctx.save()
    self._ctx.new_path()
    self._ctx.append_path(path)
    self._ctx.clip()

</t>
<t tx="karstenw.20170725110856.29">def endclip(self):
    self._ctx.restore()

</t>
<t tx="karstenw.20170725110856.3">def __init__(self, c1, c2, c3, a, mode='rgb'):
    c1 = min(max(0.0, c1), 1.0)
    c2 = min(max(0.0, c2), 1.0)
    c3 = min(max(0.0, c3), 1.0)
    a  = min(max(0.0,  a), 1.0)

    if mode == 'rgb':
        self.r = c1
        self.g = c2
        self.b = c3
        self.a = a
        self._update_hsv()

    elif mode == 'hsv':
        self.h = c1
        self.s = c2
        self.v = c3
        self.a = a
        self._update_rgb()
    else:
        raise ValueError, 'Invalid color mode: ' + mode

</t>
<t tx="karstenw.20170725110856.30">def autoclosepath(self, close=True):
    self._autoclosepath = close

</t>
<t tx="karstenw.20170725110856.31">def transform(mode):
    raise NotImplementedError

</t>
<t tx="karstenw.20170725110856.32">def translate(self, x, y):
    self._ctx.translate(x, y)

</t>
<t tx="karstenw.20170725110856.33">def rotate(self, degrees=0.0, radians=0.0):
    if degrees != 0:
        radians = degrees * math.pi / 180
    self._ctx.translate(radians)

</t>
<t tx="karstenw.20170725110856.34">def scale(self, x, y=None):
    if not y:
        y = 1.0
    self._ctx.scale(x, y)

</t>
<t tx="karstenw.20170725110856.35">def skew(x, y=None):
    raise NotImplementedError

</t>
<t tx="karstenw.20170725110856.36">def push(self):
    self._ctx.save()

</t>
<t tx="karstenw.20170725110856.37">def pop(self):
    self._ctx.restore()

</t>
<t tx="karstenw.20170725110856.38">def reset(self):
    self._ctx.identity_matrix()

</t>
<t tx="karstenw.20170725110856.39">def outputmode(self, mode):
    # Not implemented; always RGB
    raise NotImplementedError

</t>
<t tx="karstenw.20170725110856.4">def __repr__(self):
    return 'Color(r=%.3f, g=%.3f, b=%.3f, a=%.3f)' % (self.r, self.g, self.b, self.a)

</t>
<t tx="karstenw.20170725110856.40">def colormode(self, mode):
    pass

</t>
<t tx="karstenw.20170725110856.41">def color(self, *args):
    return color(*args)

</t>
<t tx="karstenw.20170725110856.42">def fill(self, *args):
    self._fillcolor = self._make_color_obj(*args)

</t>
<t tx="karstenw.20170725110856.43">def nofill(self):
    self._fillcolor = None

</t>
<t tx="karstenw.20170725110856.44">def stroke(self, *args):
    self._strokecolor = self._make_color_obj(*args)

</t>
<t tx="karstenw.20170725110856.45">def nostroke(self):
    self._strokecolor = None

</t>
<t tx="karstenw.20170725110856.46">def strokewidth(self, width):
    self._ctx.set_line_width(width)

</t>
<t tx="karstenw.20170725110856.47">def background(self, *args):
    # Transparent background
    if len(args) == 1 and args[0] == None:
        return

    col = self._make_color_obj(*args)
    self._backgroundcolor = col

    c = self._ctx
    c.set_source_rgba(*col.rgba())
    c.rectangle(0, 0, self._width, self._height)
    c.fill()

</t>
<t tx="karstenw.20170725110856.48">def font(self, fontname, fontsize=None):
    self._ctx.select_font_face(fontname, cairo.FONT_SLANT_NORMAL,
                               cairo.FONT_WEIGHT_NORMAL)
    self._fontname = fontname

    if fontsize:
        self.fontsize(fontsize)

</t>
<t tx="karstenw.20170725110856.49">def fontsize(self, fontsize):
    self._ctx.set_font_size(fontsize)
    self._fontsize = fontsize

</t>
<t tx="karstenw.20170725110856.5">def copy(self):
    return Color(self.r, self.g, self.b, self.a)

</t>
<t tx="karstenw.20170725110856.50">def text(self, txt, x, y):
    # width, height &amp; outline not implemented
    c = self._ctx
    c.set_source_rgba(*self._fillcolor.rgba())
    c.move_to(x, y)
    c.show_text(txt)

</t>
<t tx="karstenw.20170725110856.51">def textpath(txt, x, y, width=None, height=1000000):
    raise NotImplementedError

</t>
<t tx="karstenw.20170725110856.52">def textwidth(self, txt):
    width, height = self.textmetrics(txt)
    return width

</t>
<t tx="karstenw.20170725110856.53">def textheight(self, txt):
    width, height = self.textmetrics(txt)
    return height

</t>
<t tx="karstenw.20170725110856.54">def textmetrics(self, txt):
    (ascent, descent, height,
     max_x_advance, max_y_advance) = self._ctx.font_extents()
    linewidth = self._ctx.text_extents(txt)[4]
    return linewidth, height + descent

</t>
<t tx="karstenw.20170725110856.55">def lineheight(self, height=None):
    if height:
        self._lineheight = height
    return self._lineheight

</t>
<t tx="karstenw.20170725110856.56">def align(self, align):
    raise NotImplementedError

</t>
<t tx="karstenw.20170725110856.57">def image(path, x, y, width=None, height=None, alpha=1.0, data=None):
    raise NotImplementedError

</t>
<t tx="karstenw.20170725110856.58">def imagesize(path):
    raise NotImplementedError

</t>
<t tx="karstenw.20170725110856.59">def size(w, h):
    raise NotImplementedError

</t>
<t tx="karstenw.20170725110856.6">def rgba(self):
    return (self.r, self.g, self.b, self.a)

</t>
<t tx="karstenw.20170725110856.60">def var(name, type, default, min, max):
    raise NotImplementedError

</t>
<t tx="karstenw.20170725110856.61">def random(v1=None, v2=None):
    raise NotImplementedError

</t>
<t tx="karstenw.20170725110856.62">def choice(list):
    raise NotImplementedError

</t>
<t tx="karstenw.20170725110856.63">def grid(cols, rows, colsize=1, rowsize=1):
    raise NotImplementedError

</t>
<t tx="karstenw.20170725110856.64">def files(path):
    raise NotImplementedError

</t>
<t tx="karstenw.20170725110856.65">def autotext(xml):
    raise NotImplementedError


</t>
<t tx="karstenw.20170725110856.66">def rgba_color(self, c):
    return self.color(*c)

</t>
<t tx="karstenw.20170725110856.67">def gradientfill(self, path, clr1, clr2, dx=0.0, dy=0.0,
                 type='linear',spread=1.0):
    c = self._ctx
    c.append_path(path)
    x1, y1, x2, y2 = c.fill_extents()

    pat = cairo.LinearGradient(0, y1, 0, y2)
    pat.add_color_stop_rgba(1, *clr1.rgba())
    pat.add_color_stop_rgba(0, *clr2.rgba())

    if self._shadow:
        self._draw_shadow()

    c.set_source(pat)
    if self._strokecolor:
        c.fill_preserve()
        c.set_source_rgba(*self._strokecolor.rgba())
        c.stroke()
    else:
        c.fill()

</t>
<t tx="karstenw.20170725110856.68">def shadow(self, dx=0.0, dy=0.0, blur=3.0, clr=color(0, 0, 0, 1)):
    self._shadow_dx = dx
    self._shadow_dy = dy
    self._shadow_radius = blur / 2
    self._shadow_color = clr
    self._shadow = True

</t>
<t tx="karstenw.20170725110856.69">def noshadow(self):
    self._shadow = False

</t>
<t tx="karstenw.20170725110856.7">def darken(self, step=0.1):
    return Color(self.h, self.s, self.v - step, self.a, mode='hsv')

</t>
<t tx="karstenw.20170725110856.70">def initsurface(self, w, h, fmt, fname=None, scale=1.0):
    self._width = w
    self._height = h

    w *= scale
    h *= scale

    if fmt == 'pdf':
        self._surface = cairo.PDFSurface(fname, w, h)
    elif fmt == 'svg':
        self._surface = cairo.SVGSurface(fname, w, h)
    elif fmt == 'png':
        w = int(w + .5)
        h = int(h + .5)
        self._surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, w, h)
    elif fmt == 'ps':
        self._surface = cairo.PSSurface(fname, w, h)
    else:
        raise ValueError, "Invalid output format: '%s'" % (fmt)

    self._format = fmt
    self._filename = fname

    self._ctx = cairo.Context(self._surface)
    self._ctx.scale(scale, scale)

</t>
<t tx="karstenw.20170725110856.71">def writesurface(self):
    if self._format == 'png':
        self._surface.write_to_png(self._filename)
    else:
        self._ctx.show_page()

</t>
<t tx="karstenw.20170725110856.72">def _make_color_obj(self, *args):
    if len(args) == 1 and type(args[0]).__name__ == 'Color':
        return args[0]
    else:
        return self.color(*args)

</t>
<t tx="karstenw.20170725110856.73">def _draw_stroke(self):
    c = self._ctx
    if self._strokecolor:
        c.set_source_rgba(*self._strokecolor.rgba())
        c.stroke()

</t>
<t tx="karstenw.20170725110856.74">def _draw(self):
    c = self._ctx
    if self._fillcolor:
        if self._shadow:
            self._draw_shadow()

        c.set_source_rgba(*self._fillcolor.rgba())
        if self._strokecolor:
            c.fill_preserve()
            c.set_source_rgba(*self._strokecolor.rgba())
            c.stroke()
        else:
            c.fill()
    else:
        self._draw_stroke()

</t>
<t tx="karstenw.20170725110856.75">def _draw_shadow(self):
    c = self._ctx
    img, padding = self._render_bitmap_shadow()
    x1, y1, x2, y2 = c.fill_extents()

    dpi_scale = 72.0 / self._bitmap_dpi

    c.save()
    c.set_source_rgba(*self._shadow_color.rgba())
    c.translate(x1 + self._shadow_dx, y1 + self._shadow_dy)
    c.scale(dpi_scale, dpi_scale)
    c.translate(-padding, -padding)
    c.mask_surface(img, 0, 0)
    c.restore()

</t>
<t tx="karstenw.20170725110856.76">def _render_bitmap_shadow(self):
    # 'Moving average' subpixel resolution box filter implementation
    # based on Ryg's posts on fast blurs:
    #
    # http://fgiesen.wordpress.com/2012/07/30/fast-blurs-1/
    # http://fgiesen.wordpress.com/2012/08/01/fast-blurs-2/
    #
    # Note: Shadows doesn't work properly for SVG output as shadow
    # bitmaps don't get translated correctly but are all drawn at
    # the origin.

    dpi_scale = self._bitmap_dpi / 72.0

    radius = self._shadow_radius * dpi_scale

    # With 3 passes we get a good approximation of Gaussian blur
    # within a 3% error margin (bicubic blur), which is good enough
    # for practical purposes.
    # 1 - box filter
    # 2 - triangle filter
    # 3 - piecewise quadratic filter
    # 4 - piecewise cubic filter
    passes = self._shadow_blur_passes

    # Integer part of radius
    m = int(radius)

    # Fractional part of radius
    alpha = radius - m

    scale = 1.0 / (2 * radius + 1)

    # Calculate the padding required for the blur around the shape's
    # bounding box. As we don't do any boundary checks when applying
    # the filter, negative index values will wrap around to the end
    # of the image buffer. Therefore, we need to make the padding a
    # slightly larger than the blur radius to avoid visible wrapping
    # effects around the edges, hence the 1.5 multiplier.
    padding = int((m+2) * passes * 1.5 + 0.5)

    # Calculate shape extents. x1, y1 will hold the offset from the
    # origin.
    c = self._ctx
    x1, y1, x2, y2 = c.fill_extents()

    # Add some extra padding (3) to the sides
    width = int((x2 - x1) * dpi_scale + padding * 2 + 0.5) + 3
    height = int((y2 - y1) * dpi_scale + padding * 2 + 0.5) + 3

    # As we don't do any boundary checks when applying the filter,
    # the buffer needs to be made N rows larger to prevent index out
    # of range exceptions, where N is the maximum sampling radius
    # (m+2 in this case). The buffer will be in ARGB32 format, so we
    # need 4 bytes per pixel.
    data = bytearray(width * (height + m+2) * 4)

    # Create an image surface backed by our bytebuffer
    img = cairo.ImageSurface.create_for_data(data, cairo.FORMAT_ARGB32,
                                             width, height)
    imgctx = cairo.Context(img)

    # Draw the shape to be blurred offset from the origin, so
    # there's space around it for the blur.
    offsx = int(-x1 * dpi_scale + padding + 0.5)
    offsy = int(-y1 * dpi_scale + padding + 0.5)

    imgctx.translate(offsx, offsy)
    imgctx.scale(dpi_scale, dpi_scale)

    imgctx.append_path(c.copy_path())

    # Draw the shape with full opacity; the alpha value will be used
    # later when we blit the blurred image onto the target surface.
    col = self._shadow_color.copy()
    col.a = 1.0
    imgctx.set_source_rgba(*col.rgba())
    imgctx.fill()

    # Horizontal passes (blur the alpha channel only)
    row = bytearray(width * 4)

    for y in range(0, height):
        for p in range(passes):
            yoffs = y * width * 4 + 3
            sum_ = data[yoffs]

            for x in range(m):
                sum_ += data[yoffs - x*4] + data[yoffs + x*4]

            sum_ += alpha * data[yoffs - m*4] + data[yoffs + m*4]

            for x in range(width):
                a = int(sum_ * scale)
                row[x*4] = a

                a = data[yoffs + (x+m+1)*4]
                b = data[yoffs + (x+m+2)*4]
                sum_ += a + alpha * (b - a)

                a = data[yoffs + (x-m)*4]
                b = data[yoffs + (x-m-1)*4]
                sum_ -= a + alpha * (b - a)

            data[yoffs:yoffs + width*4] = row

    # Vertical passes (blur the alpha channel only)
    col = bytearray(height)

    for x in range(width):
        for p in range(passes):
            xoffs = x*4+3
            sum_ = data[xoffs]

            for y in range(m):
                sum_ += data[xoffs - y*width*4] + data[xoffs + y*width*4]

            sum_ += alpha * data[xoffs - m*width*4] + data[xoffs + m*width*4]

            for y in range(0, height):
                a = int(sum_ * scale)
                col[y] = a

                a = data[xoffs + (y+m+1)*width*4]
                b = data[xoffs + (y+m+2)*width*4]
                sum_ += a + alpha * (b - a)

                a = data[xoffs + (y-m)*width*4]
                b = data[xoffs + (y-m-1)*width*4]
                sum_ -= a + alpha * (b - a)

            for y in range(1, height - 1):
                data[xoffs + y*width*4] = col[y]

    return img, padding


</t>
<t tx="karstenw.20170725110856.8">def lighten(self, step=0.1):
    return Color(self.h, self.s, self.v + step, self.a, mode='hsv')

</t>
<t tx="karstenw.20170725110856.9">def blend(self, clr, factor=0.5):
    r = self.r * (1.0 - factor) + clr.r * factor
    g = self.g * (1.0 - factor) + clr.g * factor
    b = self.b * (1.0 - factor) + clr.b * factor
    a = self.a * (1.0 - factor) + clr.a * factor
    return Color(r, g, b, a)

</t>
<t tx="karstenw.20170725110859.1">import os
import sys
import traceback
from optparse import OptionParser

from twyg import get_scale_factor, generate_output
from twyg.common import validate_margins


</t>
<t tx="karstenw.20170725110859.2">def exit_error(msg):
    print &gt;&gt;sys.stderr, sys.argv[0] + ': ' + msg
    sys.exit(1)


</t>
<t tx="karstenw.20170725110859.3">def main():
    usage = 'Usage: %prog [OPTIONS] DATAFILE OUTFILE'
    parser = OptionParser(usage=usage)
    parser.add_option('-c', '--config',
                      default='default',
                      dest='config', metavar='NAME',
                      help='configuration to use [default: %default]')

    parser.add_option('-o', '--colorscheme',
                      dest='colorscheme', metavar='NAME',
                      help='colorscheme to use')

    parser.add_option('-d', '--dpi',
                      default='72.0', type='float',
                      help=('output resolution (PNG) or shadow rasterisation '
                            'resolution (PDF, PS and SVG) [default: %default]'))

    parser.add_option('-m', '--margin',
                      default='10%,5%',
                      help=('margins in TOP,RIGHT,BOTTOM,LEFT or VERT,HORIZ '
                            'or MARGIN format, either as absolute units '
                            '(points) or percentages [default: %default]'))

    parser.add_option('-v', '--verbose',
                      default=False, action='store_true',
                      help='display stack trace on error')

    parser.add_option('-s', '--scale',
                      default='1.0', type='float',
                      help=('scale factor (multiplier or percentage) '
                          '[default: %default]'))

    options, args = parser.parse_args()

    if len(args) == 0:
        parser.error('input and output files must be specified')
        return 2

    if len(args) == 1:
        parser.error('output file must be specified')
        return 2

    datafile = args[0]
    outfile = args[1]

    ext = os.path.splitext(outfile)[1][1:].lower()
    if ext in ('pdf', 'png', 'ps', 'svg'):
        options.outformat = ext
    else:
        parser.error('invalid output format: %s' % ext)
        return 2

    if options.dpi &lt;= 0:
        parser.error('DPI value must be greater than 0')
        return 2

    if options.scale &lt;= 0:
        parser.error('scale value must be greater than 0')
        return 2

    # Validate margin values
    margins = options.margin.split(',')
    try:
        validate_margins(margins)
    except ValueError, e:
        parser.error(e)
        return 2

    try:
        scale = get_scale_factor(options.dpi, options.scale)

        generate_output(datafile, options.config, outfile, options.outformat,
                        colorscheme=options.colorscheme, scale=scale,
                        margins=margins)

    except Exception, e:
        exit_error(traceback.format_exc() if options.verbose else str(e))

    return 0

</t>
<t tx="karstenw.20170725110903.1">import os

from twyg.common import brightness
from twyg.config import (colors_path, Properties,
                         BooleanProperty, NumberProperty, ColorProperty,
                         ArrayProperty, StringProperty, loadconfig)


</t>
<t tx="karstenw.20170725110903.10">class CycleColorizer(Colorizer):

    @others
</t>
<t tx="karstenw.20170725110903.11">def __init__(self, config, colorscheme_path=None):
    properties = {}

    super(CycleColorizer, self).__init__(
        properties, 'cycle', config,
        colorscheme_path=colorscheme_path)

    self._colorindex = 0

</t>
<t tx="karstenw.20170725110903.12">def _set_basecolor(self, node):
    """
    Set the color of a node by cycling through all available colors.
    Leaves have the same color as their parent.
    """

    C = self._colorscheme_props.eval

    if node.isroot():
        node.basecolor = C('rootColor')
    elif node.isleaf():
        node.basecolor = node.parent.basecolor
    else:
        nodecolors = C('nodeColors')
        node.basecolor = nodecolors[self._colorindex]

        if len(nodecolors) &gt; 1:
            self._colorindex = (self._colorindex + 1) % len(nodecolors)
            if node.parent.basecolor == node.basecolor:
                self.colorize(node)


</t>
<t tx="karstenw.20170725110903.13">class DepthColorizer(Colorizer):

    @others
</t>
<t tx="karstenw.20170725110903.14">def __init__(self, config, colorscheme_path=None):
    properties = {}

    super(DepthColorizer, self).__init__(
        properties, 'depth', config,
        colorscheme_path=colorscheme_path)

</t>
<t tx="karstenw.20170725110903.15">def _set_basecolor(self, node):
    """
    Set the color of a node by cycling through all available colors.
    Leaves have the same color as their parent.
    """

    C = self._colorscheme_props.eval

    if node.isroot():
        node.basecolor = C('rootColor')
    else:
        nodecolors = C('nodeColors')
        node.basecolor = nodecolors[node.depth() % len(nodecolors)]


</t>
<t tx="karstenw.20170725110903.16">class BranchColorizer(Colorizer):

    @others
_colorizer_map = {
    'cycle': CycleColorizer,
    'depth': DepthColorizer,
    'branch': BranchColorizer
}


</t>
<t tx="karstenw.20170725110903.17">def __init__(self, config, colorscheme_path=None):
    properties = {}

    super(BranchColorizer, self).__init__(
        properties, 'branch', config,
        colorscheme_path=colorscheme_path)

    self._colorindex = 0

</t>
<t tx="karstenw.20170725110903.18">def _set_basecolor(self, node):
    """
    Set the color of a node by cycling through all available colors.
    Leaves have the same color as their parent.
    """

    C = self._colorscheme_props.eval

    if node.isroot():
        node.basecolor = C('rootColor')
    elif node.depth() == 1:
        nodecolors = C('nodeColors')
        self._colorindex = (self._colorindex + 1) % len(nodecolors)
        node.basecolor = nodecolors[self._colorindex]
    else:
        node.basecolor = node.parent.basecolor


</t>
<t tx="karstenw.20170725110903.19">def colorizer_by_name(name):
    if name in _colorizer_map:
        return _colorizer_map[name]
    else:
        raise ValueError, 'Unrecognized colorizer name: %s' % name

</t>
<t tx="karstenw.20170725110903.2">class Colorizer(object):

    @others
</t>
<t tx="karstenw.20170725110903.3">def __init__(self, childproperties, defaults, config,
             colorscheme_path=None):

    properties = {
        'colorscheme':            (StringProperty,  {}),
        'fillColor':              (ColorProperty,   {}),
        'strokeColor':            (ColorProperty,   {}),
        'connectionColor':        (ColorProperty,   {}),
        'fontColor':              (ColorProperty,   {}),
        'fontColorAuto':          (BooleanProperty, {}),
        'fontColorAutoDark':      (ColorProperty,   {}),
        'fontColorAutoLight':     (ColorProperty,   {}),
        'fontColorAutoThreshold': (NumberProperty,  {'min': 0.0})
    }

    colorscheme_properties = {
        'backgroundColor': (ColorProperty, {}),
        'rootColor':       (ColorProperty, {}),
        'nodeColors':      (ArrayProperty, {'type': ColorProperty})
    }
    properties.update(childproperties)
    self._props = Properties(properties, self._defaults_path(defaults),
                             config)

    E = self._eval_func()
    if not colorscheme_path:
        colorscheme_path = E('colorscheme')

    colorscheme = loadconfig(colors_path(colorscheme_path), flat=True)

    self._colorscheme_props = Properties(colorscheme_properties,
                                         'colorizer/colorscheme',
                                         colorscheme)

# TODO util function in common?
</t>
<t tx="karstenw.20170725110903.4">def _defaults_path(self, conf):
    return os.path.join('colorizer', conf)

</t>
<t tx="karstenw.20170725110903.5">def _eval_func(self, node=None):
    # TODO duplicate from node.py
    if node:
        vars = {
            'depth':       node.depth(),
            'numChildren': len(node.getchildren()),
            'bgColor':     self.background_color()
        }
    else:
        vars = {}
    return lambda name: self._props.eval(name, node, vars)

</t>
<t tx="karstenw.20170725110903.6">def colorize(self, node):
    C = self._colorscheme_props.eval

    node.bgcolor = self.background_color()
    self._set_basecolor(node)

    E = self._eval_func(node)

    node.fillcolor = E('fillColor')
    node.strokecolor = E('strokeColor')
    node.connectioncolor = E('connectionColor')

    # Determine font color
    if E('fontColorAuto'):
        node.fontcolor = self._calc_auto_textcolor(node)
    else:
        node.fontcolor = E('fontColor')

</t>
<t tx="karstenw.20170725110903.7">def background_color(self):
    C = self._colorscheme_props.eval
    return C('backgroundColor')

</t>
<t tx="karstenw.20170725110903.8">def _calc_auto_textcolor(self, node):
    E = self._eval_func(node)

    text_bgcolor = (node.fillcolor if node.text_has_background
                                   else self.background_color())
    textcolor = node.fillcolor

    if abs(  brightness(text_bgcolor)
           - brightness(textcolor)) &lt; E('fontColorAutoThreshold'):
        textcolor_dark  = E('fontColorAutoDark')
        textcolor_light = E('fontColorAutoLight')

        b = brightness(text_bgcolor)

        if (  abs(b - brightness(textcolor_dark))
            &gt; abs(b - brightness(textcolor_light))):
            textcolor = textcolor_dark
        else:
            textcolor = textcolor_light

    return textcolor

</t>
<t tx="karstenw.20170725110903.9">def _set_basecolor(self, node):
    raise NotImplementedError


</t>
<t tx="karstenw.20170725110905.1">import collections, math

try:
    import json                 # Python 2.6+
except ImportError:
    import simplejson as json   # Python 2.5 &amp; Nodebox 1


</t>
<t tx="karstenw.20170725110905.2">def init(nodebox=False, ctx=None):
    if nodebox:
        # Simulate ximport
        import colors
        colors._ctx = ctx

        # "Injecting extra methods into the NodeBox Context object is
        # quite safe since the NodeBox 1 codebase is essentially frozen,
        # so the likelihood that future updates will break this is very
        # slim."
        #   -- Excerpt from Famous Last Words, vol 42.

        ctx.color = lambda r, g, b, a: colors.rgb(r, g, b, a)
        ctx.gradientfill = colors.gradientfill
        ctx.shadow = colors.shadow
        ctx.noshadow = colors.noshadow


</t>
<t tx="karstenw.20170725110905.3">def validate_margins(margins):
    calculate_margins(0, 0, margins)


</t>
<t tx="karstenw.20170725110905.4">def calculate_margins(width, height, margins):
    def is_percent(v):
        return v[-1] == '%'

    def percent_value(v):
        try:
            val = float(v[:-1])
        except ValueError:
            raise ValueError, 'Invalid percentage margin value: %s' % v
        if val &lt; 0:
            raise (ValueError,
                   'Margin percentage value must be positive: %s' % v)
        elif val &gt; 100:
            raise (ValueError,
                   'Margin percentage value must be less than 100: %s' % v)
        return val

    def value(v):
        try:
            val = float(v)
        except ValueError:
            raise ValueError, 'Invalid margin value: %s' % v
        if val &lt; 0:
            raise ValueError, 'Margin value must be positive: %s' % v
        return val

    if len(margins) == 1:
        top = right = bottom = left = margins[0]

    elif len(margins) == 2:
        top = bottom = margins[0]
        right = left = margins[1]

    elif len(margins) == 4:
        top = margins[0]
        right = margins[1]
        bottom = margins[2]
        left = margins[3]
    else:
        raise ValueError, 'Invalid margin description: %s' % margins

    top_margin = (height * percent_value(top) / 100 if is_percent(top)
                  else value(top))

    right_margin = (width * percent_value(right) / 100 if is_percent(right)
                    else value(right))

    bottom_margin = (height * percent_value(bottom) / 100 if is_percent(bottom)
                     else value(bottom))

    left_margin = (width * percent_value(left) / 100 if is_percent(left)
                   else value(left))

    return top_margin, right_margin, bottom_margin, left_margin


</t>
<t tx="karstenw.20170725110905.5">def brightness(col):
    # Formula from:
    # http://www.nbdtech.com/Blog/archive/2008/04/27/Calculating-the-Perceived-Brightness-of-a-Color.aspx
    return math.sqrt(  .241 * pow(col.r, 2)
                     + .691 * pow(col.g, 2)
                     + .068 * pow(col.b, 2))


</t>
<t tx="karstenw.20170725110905.6">def loadjson(path):
    """ Loads a JSON file. """
    try:
        fp = file(path)
        data = json.load(fp)
        fp.close()
    except Exception, e:
        raise ValueError("Error loading JSON file '%s':\n\t%s" % (path, e))
    return data


###############################################################################

_textwidth_cache = collections.defaultdict(dict)

</t>
<t tx="karstenw.20170725110905.7">def textwidth(ctx, txt, fontname, fontsize):
    """
    Memoized textwidth() function.

    The width of a string returned by textwidth() equals the sum of the
    widths of its constituting characters, so only need to simply cache
    the widths of the individual characters.
    """

    key = fontname + str(fontsize)
    fs = _textwidth_cache[key]
    w = 0

    for c in txt:
        if c not in fs:
            fs[c] = ctx.textwidth(c)
        w += fs[c]

    return w


</t>
<t tx="karstenw.20170725110905.8">def createpath(ctx, segments, close=True):
    """ Create a path object from a list of segment definitions.

    Each element of the list ``segments`` defines a segment of the path.
    If the element is a single object, it defines an endpoint of a
    straight line. If the element is a 2 element list, it defines the
    two endpoints of a straight line in `[p0, p1]` format. If the
    element is a 4 element lists, it  defines a Bezier-path in `[p0, p1,
    p2, p3]` format, where `p0` and `p3` are the two endpoints and `p1`
    and `p2` the two control points. All points objects should have `x`
    and `y` properties. ``close`` controls whether the resulting path
    shall be automatically closed or not.
    """

    ctx.autoclosepath(close)

    s0 = segments[0]
    if type(s0) in (list, tuple):
        ctx.beginpath(s0[0].x, s0[0].y)
    else:
        ctx.beginpath(s0.x, s0.y)

    for s in segments:
        if type(s) in (list, tuple):
            if len(s) == 2:
                ctx.lineto(s[1].x, s[1].y)
            elif len(s) == 4:
                ctx.curveto(s[1].x, s[1].y, s[2].x, s[2].y, s[3].x, s[3].y)
            else:
                raise ValueError, 'Invalid path segment: %s' % s
        else:
            ctx.lineto(s.x, s.y)

    return ctx.endpath(draw=False)

</t>
<t tx="karstenw.20170725110908.1">import math, os, re, sys
import operator as _operator

# TODO what happens in NodeBox?
from pkg_resources import resource_filename

try:
    # Python 2.7+
    from collections import OrderedDict
except ImportError:
    # Python 2.4-2.6 &amp; Nodebox 1
    from twyg.ordereddict import OrderedDict

from twyg.css3colors import color_to_rgba, colornames
from twyg.tree import Direction

import twyg.common


CONF_EXT = '.twg'

DEFAULTS_DIR = 'defaults'
COLORS_DIR   = 'colors'
CONFIGS_DIR  = 'configs'

DEFAULT_LEVEL = '$defaultLevel'


# This is a high-leve description of the config parsing process:
#
# 1.   Load configuration (``loadconfig``)
#
# 1.1  Read in the whole config file and tokenize it line by line using
#      regexps (``_tokenize_file``)
#
# 1.2  Build config data structure by running an FSM paraser on the
#      resulting tokens (``buildconfig``). @copy and @include directives
#      are fully resolved during the parsing process:
#
#      - @copy directives are expanded.
#
#      - If an @include directive is encountered, the referenced config file
#        is loaded and tokenized by ``_tokenize_file`` and then recursively
#        parsed by ``buildconfig``.
#
# 2.   TODO
#


</t>
<t tx="karstenw.20170725110908.10">def loaddefaults(defaults):
    return loadconfig(defaults_path(defaults), flat=True)


</t>
<t tx="karstenw.20170725110908.11">def loadconfig(file, flat=False):
    """ Tokenize a config file.

    If ``flat`` is true, all properties will be placed in a section
    called 'default'. This should only be used when tokenizing config
    defaults that don't contain a section definition.

    # TODO's
    See buildconfig for a detailed description of the returned config
    data structure.
    """

    tokens, cwd = _tokenize_file(file, flat)
    config = buildconfig(tokens, cwd=cwd, prev_configs=[file])
    if flat:
        config = config['default']
    return config


</t>
<t tx="karstenw.20170725110908.12">def find_config(paths, name):
    """ Find a config file.

    ``paths`` contains a list of search paths, including the name of the
    config. The function first tries to fint the config as specified in
    the path, then tries with CONF_EXT extension appended at the end.
    """

    for p in paths:
        if os.path.exists(p):
            return p
        p2 = p + CONF_EXT
        if os.path.exists(p2):
            return p2
    raise ConfigError("Cannot open %s file: '%s'" % (name, p))


</t>
<t tx="karstenw.20170725110908.13">def defaults_path(configname):
    conf = os.path.join(DEFAULTS_DIR, configname)
    home_conf = os.path.join(twyg.common.TWYG_HOME, conf)
    paths = [
        home_conf,
        resource_filename(__name__, conf)
    ]
    return find_config(paths, 'defaults config')


</t>
<t tx="karstenw.20170725110908.14">def colors_path(configname):
    colors_conf = os.path.join(COLORS_DIR, configname)
    home_colors_conf = os.path.join(twyg.common.TWYG_HOME, colors_conf)
    paths = [
        configname,
        home_colors_conf,
        resource_filename(__name__, colors_conf)
    ]
    return find_config(paths, 'colorscheme config')


</t>
<t tx="karstenw.20170725110908.15">def config_path(configname):
    configs_conf = os.path.join(CONFIGS_DIR, configname)
    home_configs_conf = os.path.join(twyg.common.TWYG_HOME, configs_conf)
    paths = [
        configname,
        home_configs_conf,
        resource_filename(__name__, configs_conf)
    ]
    return find_config(paths, 'config')


</t>
<t tx="karstenw.20170725110908.16">def include_path(configname):
    return find_config([configname], 'included config')


##############################################################################
# Pratt expression parser
##############################################################################

# Top-down operator-precedence parser based heavily on Fredrik Lundh's
# excellent article on Pratt parsers:
#
# http://effbot.org/zone/simple-top-down-parsing.htm
#
# Added type checking, function calls and extensive error reporting on
# my own.
#
# Further references:
#
# http://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing/
# http://javascript.crockford.com/tdop/tdop.html

</t>
<t tx="karstenw.20170725110908.17">def parsecolor(mode, *components):
    """ Helper function to parse colors specified by their individual
    component values using the CSS3 color parser.
    """
    s = ', '.join([str(a) for a in components])
    if mode:
        s = mode + '(' + s + ')'
    return _ctx.color(*color_to_rgba(s))


# Functions that are available in a config file
function_table = {
    'abs':      abs,
    'ceil':     math.ceil,
    'floor':    math.floor,
    'log':      math.log,
    'log10':    math.log10,
    'max':      max,
    'min':      min,
    'pow':      pow,
    'round':    round,
    'sqrt':     math.sqrt,

    'rgb':      lambda r, g, b:    parsecolor('rgb',  r, g, b),
    'rgba':     lambda r, g, b, a: parsecolor('rgba', r, g, b, a),
    'hsl':      lambda h, s, l:    parsecolor('hsl',  h, s, l),
    'hsla':     lambda h, s, l, a: parsecolor('hsla', h, s, l, a)
}


variable_table_defaults = {
}

variable_table = {
}

</t>
<t tx="karstenw.20170725110908.18">def init_variable_table_defaults():
    # Make all named CSS3 colors available as color.&lt;colorname&gt; in the
    # config file
    def inject_css3_colors():
        global variable_table_defaults

        class Colors:
            pass

        col = Colors()
        for name in colornames.keys():
            setattr(col, name, parsecolor(None, name))
        variable_table_defaults['color'] = col

    inject_css3_colors()


</t>
<t tx="karstenw.20170725110908.19">class SymbolBase(object):
    id = None
    value = None
    first = second = None

    @others
symbol_table = {}

</t>
<t tx="karstenw.20170725110908.2">class ConfigError(Exception):
    """ Exception for displaying configuration error messages in a
    normalized format.
    """
    @others
##############################################################################
# Tokenizer
##############################################################################

</t>
<t tx="karstenw.20170725110908.20">def nud(self):
    raise ConfigError("Syntax error: '%s'" % self.value, self)

</t>
<t tx="karstenw.20170725110908.21">def led(self, *args):
    raise ConfigError("Syntax error: unknown operator: '%s'"
                      % self.value, self)

</t>
<t tx="karstenw.20170725110908.22">def __repr__(self):
    if self.id == '(operator)':
        out = ["'" + self.value + "'", self.first, self.second]
        out = map(str, filter(None, out))
        return "(" + " ".join(out) + ")"
    else:
        return '(%s %s)' % (self.id, self.value)

</t>
<t tx="karstenw.20170725110908.23">def isoperator(self, op):
    return self.id == '(operator)' and self.value == op


</t>
<t tx="karstenw.20170725110908.24">def symbol(id, value=None, bp=0):
    key = value if value else id
    if key in symbol_table:
        s = symbol_table[key]
    else:
        class s(SymbolBase): pass

        s.__name__ = 'symbol-' + key
        s.id = id
        s.lbp = bp
        s.value = value
        symbol_table[key] = s

    s.lbp = max(bp, s.lbp)
    return s

</t>
<t tx="karstenw.20170725110908.25">def operator(op, bp=None):
    return symbol('(operator)', op, bp)

</t>
<t tx="karstenw.20170725110908.26">def infix(op, bp):
    def led(self, left):
        self.first = left
        self.second = expression(bp)
        return self
    operator(op, bp).led = led

</t>
<t tx="karstenw.20170725110908.27">def prefix(op, bp):
    def nud(self):
        self.first = expression(bp)
        self.second = None
        return self
    operator(op).nud = nud

</t>
<t tx="karstenw.20170725110908.28">def method(s):
    assert issubclass(s, SymbolBase)
    def bind(fn):
        setattr(s, fn.__name__, fn)
    return bind


# Grammar description
infix('+', 10); infix('-', 10)
infix('*', 20); infix('/', 20); infix('%', 20)
prefix('+', 30); prefix('-', 30)
operator('.', 40); operator('[', 40); operator('(', 40)


</t>
<t tx="karstenw.20170725110908.29">@method(symbol('('))
def nud(self):
    expr = expression()
    advance(')')
    return expr

operator(')'); operator(',')

</t>
<t tx="karstenw.20170725110908.3">def __init__(self, msg, token=None, file=None, line=None, col=None):
    self.msg = msg
    if token:
        self.file = token.file
        self.line = token.line
        self.col = token.col
    else:
        self.file = file
        self.line = line
        self.col = col

</t>
<t tx="karstenw.20170725110908.30">@method(symbol('('))
def led(self, left):
    self.first = left
    self.second = []
    if not token.isoperator(')'):
        while 1:
            self.second.append(expression())
            if not token.isoperator(','):
                break
            advance(',')
        advance(')')
    return self

</t>
<t tx="karstenw.20170725110908.31">@method(symbol('.'))
def led(self, left):
    self.first = left
    self.second = token
    advance()
    return self


operator(']')

</t>
<t tx="karstenw.20170725110908.32">@method(symbol('['))
def nud(self):
    self.first = []
    if not token.isoperator(']'):
        while 1:
            if token.isoperator(']'):
                break
            self.first.append(expression())
            if not token.isoperator(','):
                break
            advance(',')
        advance(']')
        return self


symbol('(section)')
symbol('(level)')
symbol('(directive)')
symbol('(newline)')
symbol('(end)')


nud = lambda self: self

symbol('(float)').nud = nud
symbol('(percent)').nud = nud
symbol('(integer)').nud = nud
symbol('(name)').nud = nud
symbol('(hexcolor)').nud = nud
symbol('(string)').nud = nud


# Evaluation rules
opnames = {
    'add': '+',
    'pos': '+',
    'sub': '-',
    'neg': '-',
    'mul': '*',
    'div': '/'
}

</t>
<t tx="karstenw.20170725110908.33">def unaryop(t, op):
    try:
        a = t.first.eval()
        return op(a)
    except TypeError, e:
        raise ConfigError("Cannot use operator '%s' on type '%s'"
                          % (opnames[op.__name__], type(a).__name__), t)

</t>
<t tx="karstenw.20170725110908.34">def binaryop(t, op):
    try:
        a = t.first.eval()
        b = t.second.eval()
        # Ensure that an int/int division always results in a float
        # result
        if type(b) == int:
            b = float(b)
        return op(a, b)
    except TypeError, e:
        raise ConfigError("Cannot use operator '%s' on types '%s' and '%s'"
                          % (opnames[op.__name__], type(a).__name__,
                             type(b).__name__), t)

</t>
<t tx="karstenw.20170725110908.35">@method(symbol('+'))
def eval(self):
    if self.second:
        return binaryop(self, _operator.add)
    else:
        return unaryop(self, _operator.pos)

</t>
<t tx="karstenw.20170725110908.36">@method(symbol('-'))
def eval(self):
    if self.second:
        return binaryop(self, _operator.sub)
    else:
        return unaryop(self, _operator.neg)

symbol('*').eval = lambda self: binaryop(self, _operator.mul)
symbol('/').eval = lambda self: binaryop(self, _operator.div)


</t>
<t tx="karstenw.20170725110908.37">def isfunction(o):
    return type(o).__name__ in ('function', 'instancemethod',
                                'builtin_function_or_method')

</t>
<t tx="karstenw.20170725110908.38">@method(symbol('('))
def eval(self):
    if self.first.isoperator('.'):
        dot_op = self.first
        obj, attr = dot_operator(dot_op)
        if not hasattr(obj, attr):
            raise ConfigError("'%s' has no method named '%s'" %
                              (dot_op.first.value, attr), dot_op.second)
        fn = getattr(obj, attr)
    else:
        fn = self.first.value
        if fn not in function_table:
            raise ConfigError("Function '%s' does not exist" % fn, self.first)
        fn = function_table[fn]
    args = self.second
    a = [x.eval() for x in args]
    try:
        return fn(*a)
    except TypeError, e:
        raise ConfigError(str(e).capitalize(), self)


</t>
<t tx="karstenw.20170725110908.39">@method(symbol('.'))
def eval(self):
    obj, attr = dot_operator(self)
    if not hasattr(obj, attr):
        raise ConfigError("'%s' has no property named '%s'"
                          % (self.first.value, attr), self.second)
    a = getattr(obj, attr)
    if isfunction(a):
        raise ConfigError("'%s' is a method of '%s'; it cannot be used as "
                          'a property ' % (attr, self.first.value),
                          self.second)
    return a


</t>
<t tx="karstenw.20170725110908.4">def __str__(self):
    return ("Error in configuration file '%s' on line %s at column %s: "
            "\n  %s" % (self.file, self.line, self.col, self.msg))


</t>
<t tx="karstenw.20170725110908.40">def dot_operator(t):
    i = t.first.id
    v = t.first.value
    if i == '(name)':
        if v not in variable_table:
            raise ConfigError("Variable '%s' does not exist" % v, t)
        obj = variable_table[v]
    else:
        obj = t.first.eval()
    attr = t.second.value
    return obj, attr


</t>
<t tx="karstenw.20170725110908.41">@method(symbol('['))
def eval(self):
    args = self.first
    a = [x.eval() for x in args]
    return a


symbol('(float)').eval    = lambda self: float(self.value)
symbol('(integer)').eval  = lambda self: int(self.value)
symbol('(percent)').eval  = lambda self: self.value
symbol('(hexcolor)').eval = lambda self: parsecolor(None, self.value)
symbol('(string)').eval   = lambda self: self.value.replace('\\"', '"')


</t>
<t tx="karstenw.20170725110908.42">@method(symbol('(name)'))
def eval(self):
    v = self.value
    if v not in variable_table:
        raise ConfigError("Variable '%s' does not exist" % v, self)
    return variable_table[v]


# Pratt parser
</t>
<t tx="karstenw.20170725110908.43">def nexttoken():
    global token, lasttoken
    t = token
    if t.id != '(end)':
        lasttoken = t
    token = next()
    return t

</t>
<t tx="karstenw.20170725110908.44">def expression(rbp=0):
    global token, lasttoken
    t = nexttoken()
    left = t.nud()
    while rbp &lt; token.lbp:
        t = nexttoken()
        left = t.led(left)
    return left

</t>
<t tx="karstenw.20170725110908.45">def advance(value=None, id='(operator)'):
    global token
    if value and not (token.id == id and token.value == value):
        raise ConfigError("Syntax error: expected '%s'" % value, lasttoken)
    token = next()


</t>
<t tx="karstenw.20170725110908.46">def parse_expr(expr):
    global next, token

    next = (x for x in expr).next
    token = next()
    try:
        e = expression()
    except StopIteration:
        raise ConfigError("Premature end of expression", lasttoken)

    if token.id != '(end)':
        raise ConfigError("Expression should have ended at this point", token)

    return e


</t>
<t tx="karstenw.20170725110908.47">def eval_expr(expr, vars={}):
    global variable_table
    if not variable_table_defaults:
        init_variable_table_defaults()
    variable_table = dict(variable_table_defaults)
    variable_table.update(vars)
    return expr.eval()


##############################################################################
# Levels
##############################################################################

</t>
<t tx="karstenw.20170725110908.48">class Level(object):
    """ Class for holding and evaluating level selector rules. """

    @others
</t>
<t tx="karstenw.20170725110908.49">def __init__(self, levelname, config={}):
    self.levelname = levelname

    # The ordinal numbers of the first four enum values must be
    # identical to those of the Direction enum.
    Level.orientation = ('top', 'right', 'bottom', 'left', 'any')

    properties = {
        'levelDepthMin':       (NumberProperty, {'min': 0}),
        'levelDepthMax':       (NumberProperty, {'min': 0}),
        'levelNumChildrenMin': (NumberProperty, {'min': 0}),
        'levelNumChildrenMax': (NumberProperty, {'min': 0}),
        'levelOrientation':    (EnumProperty,
                                {'values': Level.orientation})
    }

    self._props = Properties(properties, 'level.twg', config,
                             extra_prop_warning=False)
    self._eval()

</t>
<t tx="karstenw.20170725110908.5">class Pattern(object):
    """ Token ID and regexp pattern pair used for tokenization.
    """
    @others
# Tokenization rules used for tokenizing a config file.
# The ordering is important.
rules = [
    Pattern('(whitespace)', r'^([ \t]+)'),
    Pattern('(comment)',    r'^(--.*)'),
    Pattern('(section)',    r'^\[([a-zA-Z]+)\]'),
    Pattern('(level)',      r'^{([a-zA-Z][a-zA-Z0-9_]*)}'),
    Pattern('(directive)',  r'^@([a-zA-Z]+)'),
    Pattern('(float)',      r'^([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)'),
    Pattern('(percent)',    r'^([0-9][0-9]*%)'),
    Pattern('(integer)',    r'^([0-9][0-9]*)'),
    Pattern('(operator)',   r'^(\+|-|\*|/|\^|\(|\)|\[|\]|\.|,)'),
    Pattern('(name)',       r'^([a-zA-Z][a-zA-Z0-9_]*)'),
    Pattern('(hexcolor)',   r'^(#[a-zA-Z0-9]+)'),
    Pattern('(string)',     r'^"([^"\\]*(?:\\.[^"\\]*)*)"')
]


</t>
<t tx="karstenw.20170725110908.50">def __repr__(self):
    return self.levelname

</t>
<t tx="karstenw.20170725110908.51">def _eval(self):
    E = self._props.eval

    self.depth_min       = E('levelDepthMin')
    self.depth_max       = E('levelDepthMax')
    self.numchildren_min = E('levelNumChildrenMin')
    self.numchildren_max = E('levelNumChildrenMax')

    o = E('levelOrientation')
    if o == 'any':
        self.orientation = -1
    else:
        self.orientation = Level.orientation.index(o)

</t>
<t tx="karstenw.20170725110908.52">def selects(self, node, layout):
    """ Check if the this level's selector rules select a given
    node.

    The layout object must be passed to determine the orientation of
    the node in certain layouts.
    """

    depth = node.depth()
    numchildren = len(node.getchildren())
    o = layout.node_orientation(node)

    ok = (    depth &gt;= self.depth_min
          and depth &lt;= self.depth_max
          and numchildren &gt;= self.numchildren_min
          and numchildren &lt;= self.numchildren_max)

    # -1 stands for 'any' orientation, which means the orientation
    # can be any valid value, so we don't need to do the orientation
    # filtering
    if self.orientation &gt;= 0:
        ok = ok and self.orientation

    return ok


</t>
<t tx="karstenw.20170725110908.53">def createlevel(levelname, config):
    """ Create Level object from a config and then deletes all level
    related properties.
    """
    level = Level(levelname, config)
    for k in level._props._properties.keys():
        if k in config:
            del config[k]
    return level


</t>
<t tx="karstenw.20170725110908.54">class SectionLevel(object):
    """ Placeholder to keep level descriptions and drawer objects
    together. """

    @others
STYLE             = 'style'
LAYOUT_CONFIG     = 'layout'
NODE_CONFIG       = 'node'
CONNECTION_CONFIG = 'connection'
COLOR_CONFIG      = 'color'


##############################################################################
# Properties
##############################################################################

</t>
<t tx="karstenw.20170725110908.55">def __init__(self, level, drawer):
    self.level = level
    self.drawer = drawer

</t>
<t tx="karstenw.20170725110908.56">def __repr__(self):
    return '{%s}: %s' % (self.level, self.drawer)


</t>
<t tx="karstenw.20170725110908.57">class Property(object):
    @others
</t>
<t tx="karstenw.20170725110908.58">def __init__(self, name):
    self.name = name

</t>
<t tx="karstenw.20170725110908.59">def eval(self, vars):
    self.value = eval_expr(self.expr, vars)
    self._validate()
    return self.value


</t>
<t tx="karstenw.20170725110908.6">def __init__(self, id, pattern):
    self.id = id
    self.pattern = pattern

</t>
<t tx="karstenw.20170725110908.60">class StringProperty(Property):
    @others
</t>
<t tx="karstenw.20170725110908.61">def _validate(self):
    if type(self.value) not in (str, unicode):
        raise ConfigError("Property '%s' must evaluate to a string"
                          % self.name, self.expr[0])


</t>
<t tx="karstenw.20170725110908.62">class NumberProperty(Property):
    @others
</t>
<t tx="karstenw.20170725110908.63">def __init__(self, name, min=None, max=None):
    super(NumberProperty, self).__init__(name)
    self.min = min
    self.max = max

</t>
<t tx="karstenw.20170725110908.64">def _validate(self):
    if type(self.value) not in (int, float):
        raise ConfigError("Property '%s' must evaluate to a number"
                          % self.name, self.expr)

    if self.min and self.value &lt; self.min:
        raise ConfigError(
            "Number property '%s' must have a value greater "
            "than %s" % (self.name, self.min), self.expr)

    if self.max and self.value &gt; self.max:
        raise ConfigError("Number property '%s' must have a value less "
                          "than %s" % (self.name, self.max), self.expr)


</t>
<t tx="karstenw.20170725110908.65">class ColorProperty(Property):
    @others
</t>
<t tx="karstenw.20170725110908.66">def _validate(self):
    if type(self.value).__name__ != 'Color':
        raise ConfigError("Property '%s' must evaluate to a color"
                          % self.name, self.expr)


</t>
<t tx="karstenw.20170725110908.67">class EnumProperty(Property):
    @others
</t>
<t tx="karstenw.20170725110908.68">def __init__(self, name, values):
    super(EnumProperty, self).__init__(name)
    self.values = values

</t>
<t tx="karstenw.20170725110908.69">def eval(self, vars):
    enumvars = {}
    for value, name in enumerate(self.values):
        enumvars[name] = value
    vars.update(enumvars)
    n = eval_expr(self.expr, vars)

    if type(n) not in (int, float):
        raise ConfigError(
            ("Enum property '%s' must evaluate to a numeric value"
             % self.name), self.expr)

    n = int(round(n))
    if n &lt; 0 or n &gt;= len(self.values):
        raise ConfigError(
            ("Enum property '%s' evaluated to an invalid "
             "numeric value: %s" % (self.name, n)), self.expr)

    self.value = self.values[n]
    return self.value


</t>
<t tx="karstenw.20170725110908.7">def tokenize(config, file=None, flat=False):
    """ Convert a configuration into a list of tokens that can then be
    parsed further.
    """

    lines = config.split('\n');

    def linenum(line_nr, flat):
        return line_nr if flat else line_nr + 1

    tokens = []

    for line_nr, line in enumerate(lines):
        line = line.strip()
        if not line:
            sym = symbol('(newline)')
            tokens.append(sym())
            continue
        col = 1

        while line:
            found = False
            for r in rules:
                m = re.match(r.pattern, line)
                if m:
                    val = m.group(1)
                    id = r.id
                    if id != '(whitespace)' and id != '(comment)':
                        if id == '(operator)':
                            sym = symbol_table.get(val)
                            if not sym:
                                raise ConfigError(
                                    "Syntax error: unknown operator: '%s'"
                                    % val, file=file,
                                    line=linenum(line_nr, flat), col=col)
                        else:
                            sym = symbol_table[id]

                        s = sym()
                        s.value = val
                        s.file = file
                        s.line = linenum(line_nr, flat)
                        s.col = col
                        tokens.append(s)

                    end = m.end(0)
                    line = line[end:]
                    col += end
                    found = True
                    break

            if not found:
                raise ConfigError("Syntax error",
                                  file=file, line=linenum(line_nr, flat),
                                  col=col)

        sym = symbol('(newline)')
        tokens.append(sym())

    return tokens


##############################################################################
# Config level FSM parser
##############################################################################

</t>
<t tx="karstenw.20170725110908.70">class BooleanProperty(Property):
    @others
</t>
<t tx="karstenw.20170725110908.71">def eval(self, vars):
    vars = {'no': 0, 'off': 0, 'false': 0, 'yes': 1, 'on': 1, 'true': 1}
    n = eval_expr(self.expr, vars)

    if type(n) not in (int, float):
        raise ConfigError(
            ("Boolean property '%s' must evaluate to a numeric value"
             % self.name), self.expr)

    self.value = True if n &gt; 0.0 else False
    return self.value


</t>
<t tx="karstenw.20170725110908.72">class ArrayProperty(Property):
    @others
</t>
<t tx="karstenw.20170725110908.73">def __init__(self, name, type):
    super(ArrayProperty, self).__init__(name)
    self.type = type

</t>
<t tx="karstenw.20170725110908.74">def _validate(self):
    # TODO array element type validation
    if type(self.value) != list:
        raise ValueError


</t>
<t tx="karstenw.20170725110908.75">class Properties(object):
    """ Class for managing configuration properties. """

    @others
#            print '&gt;&gt;&gt;', name, ':', e
            prop.expr = e
            prop.name = name

        if extra_prop_warning:
            self._warn_extra_props(config)

    def _warn_extra_props(self, config):
        extra_props = set(config.keys()) - set(self._properties.keys())
        for p in extra_props:
            token = config[p][0]
            #TODO make displaying warnings optional? print to stdout?
            print &gt;&gt;sys.stderr, (
                "Warning: Unknown property '%s' in configuration "
                "file '%s' on line %s" % (p, token.file, token.line))

    def eval(self, name, scope=None, vars={}):
        """ Evaluate the value of a property.

        ``name`` is the name of the property, ``scope`` the object in
        whose context the property is to be evaluated and ``vars``
        contains a dict of variable name and value pairs that will be
        injected into the evaluation scope.
        """

        if name not in self._properties:
            # TODO more detailed error message
            raise AttributeError("Property '%s' does not exist" % name)

        p = self._properties[name]
        if scope:
            for propname, varname in scope.property_mappings.iteritems():
                if hasattr(scope, propname):
                    vars[varname] = getattr(scope, propname)
                # TODO triggered by 'basecolor' -- why?
#                else:
#                    raise ConfigError("Variable '%s' is not evaluated "
#                                      "at this point" % (varname))

        return p.eval(vars)


##############################################################################
# Utils
##############################################################################

</t>
<t tx="karstenw.20170725110908.76">def __init__(self, properties, defaults, config, extra_prop_warning=True):
    """
    Load and parse the default config file ``default`` and merge it
    with the configuration ``config`` (defaults will be
    overwritten).

    The ``properties`` dict contains the list of allowed properties
    where the key is the name of the property and the value a
    two-element tuple of which the first element is the class of the
    property and the second element the property's extra parameters
    (note that some property types have mandatory extra parameters,
    e.g. ArrayProperty). For example:

    {
        'fontName':  (StringProperty, {}),
        'fontSizes': (ArrayProperty,  {'type': NumberProperty})
    }

    Warn on property names that are not listed in the ``properties``
    dict if ``extra_prop_warning`` is True.
    """

    c = loaddefaults(defaults)
    c.update(config)
    config = c

    # Build properties dictionary
    self._properties = {}
    for name, prop_params in properties.iteritems():
        # The first parameter is the property class, the second the
        # optional constructor parameters
        prop_class, opts = prop_params
        self._properties[name] = prop_class(name, **opts)

    for name, prop in self._properties.iteritems():
        if name not in config:
            raise ConfigError("Missing property: '%s'" % name)
        e = parse_expr(config[name])
</t>
<t tx="karstenw.20170725110908.77">def format_paramvalue_error(configname, paramname, value, correct_type):
    msg = ("Invalid %s parameter value: %s: %s ('%s', should be '%s')"
           % (configname, paramname, value, correct_type))
    return msg


</t>
<t tx="karstenw.20170725110908.78">def get_stylename(configname, config):
    if STYLE not in config:
        raise ConfigError, ("Style must be specified in '%s'" % (configname))

    expr = config[STYLE]
    if len(expr) == 2 and expr[0].id == '(name)' and expr[1].id == '(end)':
        stylename = expr[0].value
    else:
        raise ConfigError("Invalid style name", expr[0])

    if not (type(stylename) == str or type(stylename) == unicode):
        raise ConfigError, format_paramvalue_error(configname, STYLE,
                                                   stylename, str)
    return stylename

</t>
<t tx="karstenw.20170725110908.8">def buildconfig(tokens, cwd=None, state='start', config=None, curr=None,
                curr_section=None, curr_level=None, section_props=False,
                prev_configs=[]):

    """ Build the final config dict from the results of the config file
    tokenization step.

    The implementation is a simple FSM parser with some internal state.
    Most of the complexity comes from the error handling and the
    building of meaningful error messages.

    @copy directives are fully expanded. If an @include directive is
    encountered, tokenize the included config file and recursively call
    buildconfig on the result.

    Below is a simple config file and the corresponding data structure
    as built by this function. Note that the tokenization step is not
    handled by this function.


    [connection]
        style                   junction
        linewidth               3
        cornerRadius            10
        cornerStyle             rounded

    [node]
      {normal}
        style                   rect
        strokeWidth             3
        cornerRadius            40

      {root}
        @copy normal
        levelDepthMax           0
        cornerRadius            80

      {leaf}
        @copy normal
        levelNumChildrenMax     0
        cornerRadius            1

    -----------------------------------------------------------------

    {
        'connection': OrderedDict([
            ('style',          [((name) junction), ((end) None)]),
            ('linewidth',      [((integer) 3), ((end) None)]),
            ('cornerRadius',   [((integer) 10), ((end) None)]),
            ('cornerStyle',    [((name) rounded), ((end) None)])
        ),

        'node': OrderedDict([
            ('normal', {
                'style':         [((name) rect), ((end) None)],
                'strokeWidth':   [((integer) 3), ((end) None)],
                'cornerRadius':  [((integer) 40), ((end) None)]
            }),
            ('root', {
                'style':         [((name) rect), ((end) None)],
                'strokeWidth':   [((integer) 3), ((end) None)],
                'levelDepthMax': [((integer) 0), ((end) None)],
                'cornerRadius':  [((integer) 80), ((end) None)]
            }),
            ('leaf', {
                'style':               [((name) rect), ((end) None)],
                'strokeWidth':         [((integer) 3), ((end) None)],
                'levelNumChildrenMax': [((integer) 0), ((end) None)],
                'cornerRadius':        [((integer) 1), ((end) None)]
            })
        ])
    }
    """

    def isliteral(id):
        return id in ('(operator)', '(float)', '(percent)', '(integer)',
                      '(name)', '(hexcolor)', '(string)')

    # TODO Python bug ???
    if not config:
        config = dict()

    for t in tokens:
        if state == 'start':
            if t.id == '(newline)':
                pass
            elif t.id == '(section)':
                state = 'section'
                curr_section = t.value
                # The order of the levels within a section must be
                # retained
                curr = config[curr_section] = OrderedDict()
                curr_level = None
                section_props = False
            else:
                raise ConfigError('Configuration must start with a '
                                  'section definition', t)

        elif state == 'section':
            if t.id == '(newline)':
                state = 'in_section'
            else:
                raise ConfigError("Section definition '%s' must be followed "
                                  'by a newline' % curr_section, t)

        elif state == 'in_section':
            if t.id == '(newline)':
                pass
            elif t.id == '(name)':
                state = 'property'
                name = t.value
                value = []
                if not curr_level:
                    section_props = True

            elif t.id == '(section)':
                section = t.value
                if section in config:
                    raise ConfigError('Duplicate section definition '
                                      "'%s'" % section, t)
                state = 'section'
                curr_section = section
                # The order of the levels within a section must be
                # retained
                curr = config[curr_section] = OrderedDict()
                curr_level = None
                section_props = False

            elif t.id == '(level)':
                level = t.value
                if section_props:
                    raise ConfigError("Invalid level definition '%s' in "
                                      "section '%s':\n"
                                      "\tlevel definitions are "
                                      "not allowed after section level "
                                      "properties"
                                      % (level, curr_section), t)

                if level in config[curr_section]:
                    raise ConfigError("Duplicate level name '%s' in "
                                      "section '%s'"
                                      % (level, curr_section), t)
                state = 'level'
                curr_level = level
                curr = config[curr_section][curr_level] = {}

            elif t.id == '(directive)':
                d = t.value
                if d not in ('include', 'copy'):
                    raise ConfigError("Invalid directive: '%s'" % d, t)
                state = 'directive'
                name = t.value
                value = []
            else:
                raise ConfigError('Property name, level definition or '
                                  'directive expected', t)

        elif state == 'level':
            if t.id == '(newline)':
                state = 'in_section'
            else:
                raise ConfigError("Level definition '%s' in section '%s' "
                                  'must be followed by a newline'
                                  % (curr_level, curr_section), t)

        elif state == 'directive':
            if t.id == '(newline)':
                if not value:
                    p = prevtoken
                    raise ConfigError("Missing parameter for directive '%s'"
                                      % name, p)
                state = 'in_section'
                param = ''.join([v.value for v in value])

                if name == 'include':
                    try:
                        configpath = include_path(os.path.join(cwd, param))

                        if configpath in prev_configs:
                            raise ConfigError(
                                "Error while processing '%s' directive:\n"
                                "\tCircular reference detected when "
                                "attempting to include '%s'"
                                % (name, configpath), prevtoken)

                        tokens, cwd = _tokenize_file(configpath, flat=False)
                    except IOError, e:
                        raise ConfigError(
                            "Error while processing '%s' directive:\n"
                            "\t%s: '%s'" % (name, e.strerror, e.filename),
                            prevtoken)

                    prev_configs.append(configpath)
                    buildconfig(tokens, cwd, state, config, curr,
                                curr_section, curr_level, section_props,
                                prev_configs)

                elif name == 'copy':
                    level = param
                    if level not in config[curr_section]:
                        t = prevtoken
                        raise ConfigError(
                                "Error while processing '%s' directive:\n"
                                "\tLevel '%s' does not exist in section '%s'"
                                % (name, level, curr_section), t)

                    curr.update(config[curr_section][level])

            elif isliteral(t.id):
                value.append(t)
            else:
                raise ConfigError('Invalid directive syntax', t)

        elif state == 'property':
            if t.id == '(newline)':
                raise ConfigError("Missing property expressions for property "
                                  "'%s'" % name, prevtoken)
            if t.isoperator('['):
                state = 'array'
                value.append(t)
            elif isliteral(t.id):
                state = 'in_property'
                value.append(t)
            else:
                raise ConfigError("Property expressions cannot start with "
                                  "'%s'" % t.value, t)

        elif state == 'in_property':
            if isliteral(t.id):
                value.append(t)
            elif t.id == '(newline)':
                state = 'in_section'
                sym = symbol('(end)')
                value.append(sym())
                curr[name] = value
            else:
                raise ConfigError("Syntax error in property expressions '%s'"
                                  % name, t)

        elif state == 'array':
            if t.id == '(newline)':
                pass
            elif t.isoperator('['):
                raise ConfigError('Arrays cannot be nested', t)
            elif t.isoperator(']'):
                state = 'end_array'
                value.append(t)
            elif isliteral(t.id):
                value.append(t)
            else:
                raise ConfigError("Syntax error in property expressions '%s'"
                                  % name, t)

        elif state == 'end_array':
            if t.id == '(newline)':
                state = 'in_section'
                sym = symbol('(end)')
                value.append(sym())
                curr[name] = value
            else:
                raise ConfigError("End of array symbol ']' must be followed"
                                  'by a newline', t)

        prevtoken = t

    return config


</t>
<t tx="karstenw.20170725110908.9">def _tokenize_file(file, flat=False):
    """ Tokenize a config file.

    Returns the list of tokens and the directory the config file resides
    in (this will be used for processing the @include directives).
    """
    f = open(file)
    config = f.read()
    if flat:
        config = '[default]\n' + config
    tokens = tokenize(config, file, flat=flat)
    cwd = os.path.dirname(file)
    return tokens, cwd


</t>
<t tx="karstenw.20170725110911.1">import os

from twyg.common import createpath
from twyg.config import (Properties, NumberProperty,
                         EnumProperty, ColorProperty)

from twyg.geom import Vector2
from twyg.geomutils import arcpath
from twyg.tree import Direction, opposite_dir


# TODO util function in common?
</t>
<t tx="karstenw.20170725110911.10">def draw(self, node):
    if node.isroot():
        self._draw(node, Direction.Left)
        self._draw(node, Direction.Right)
    else:
        self._draw(node)

</t>
<t tx="karstenw.20170725110911.11">def _draw(self, node, direction=None):
    """
    Draw a curved connection between a node and its child nodes.
    """

    E = self._eval_func(node)

    children = node.getchildren(direction)
    if not children:
        return

    linewidth = E('lineWidth')

    _ctx.autoclosepath(True)
    _ctx.stroke(node.connectioncolor)
    _ctx.fill(node.connectioncolor)
    _ctx.strokewidth(linewidth)

    firstchild = children[0]
    lastchild = children[-1]

    direction = firstchild.direction()
    opp_direction = opposite_dir(direction)
    x1, y1 = node.connection_point(direction)
    xfirst, yfirst = firstchild.connection_point(opp_direction)

    # Special case: draw straight line if there's only one child
    if len(children) == 1:
        _ctx.line(x1, y1, xfirst, yfirst)
        return

    # Calculate junction point position
    jx = x1 + (xfirst - x1) * E('junctionXFactor')
    jy = y1

    # Draw line from parent node to junction point
    _ctx.line(x1, y1, jx, jy)

    # Limit first &amp; last corner radius to the available area
    ylast = lastchild.connection_point(opp_direction)[1]
    ysecond = children[1].connection_point(opp_direction)[1]
    ypenultimate = children[-2].connection_point(opp_direction)[1]

    # Starting corner radius
    cornerPad = E('cornerPad')
    r = min(E('cornerRadius'), abs(jx - xfirst) - cornerPad)
    r = max(r, 0)

    # Adjusted first (top) corner radius
    r1 = min(r, abs(yfirst - jy) - cornerPad)
    r1 = max(r1, 0)
    if ysecond &lt; jy:
        r1 = min(r, abs(yfirst - ysecond) - cornerPad)
        r1 = max(r1, 0)

    # Adjusted last (bottom) corner radius
    r2 = min(r, abs(ylast - jy) - cornerPad)
    r2 = max(r2, 0)
    if ypenultimate &gt; jy:
        r2 = min(r, abs(ylast - ypenultimate) - cornerPad)
        r2 = max(r2, 0)

    # Draw main branch as a single path to ensure line continuity
    p1 = Vector2(jx, yfirst + r1)
    p2 = Vector2(jx, ylast - r2)
    segments = [[p1, p2]]

    corner_style = E('cornerStyle')

    for i, child in enumerate(children):
        direction = child.direction()
        opp_direction = opposite_dir(direction)

        x2, y2 = child.connection_point(opp_direction)
        if direction == Direction.Left:
            x2 -= linewidth / 2
        elif direction == Direction.Right:
            x2 += linewidth / 2

        # Draw corners
        if direction == Direction.Left:
            a1 = 90
            da = -90
            dx1 = r1 * 2
            dx2 = r2 * 2
        else:
            a1 = da = 90
            dx1 = dx2 = 0

        x1 = jx
        if child is firstchild:
            x1 += -r1 if direction == Direction.Left else r1

            if (corner_style == 'square' or abs(y2 - jy) &lt; .001):
                p1 = Vector2(jx, y2)
                p2 = Vector2(jx, y2 + r1)
                segments.insert(0, [p1, p2])

                p1 = Vector2(x1, y2)
                p2 = Vector2(jx, y2)
                segments.insert(0, [p1, p2])

            elif corner_style == 'beveled':
                p1 = Vector2(x1, y2)
                p2 = Vector2(jx, y2 + r1)
                segments.insert(0, [p1, p2])

            elif corner_style == 'rounded':
                arc = arcpath(jx - dx1, y2, r1 * 2, r1 * 2, a1, da)
                segments = arc + segments

            p1 = Vector2(x2, y2)
            p2 = Vector2(x1, y2)
            segments.insert(0, [p1, p2])

        elif child is lastchild:
            x1 += -r2 if direction == Direction.Left else r2

            if (corner_style == 'square' or abs(y2 - jy) &lt; .001):
                p1 = Vector2(jx, y2 - r2)
                p2 = Vector2(jx, y2)
                segments.append([p1, p2])

                p1 = Vector2(jx, y2)
                p2 = Vector2(x1, y2)
                segments.append([p1, p2])

            elif corner_style == 'beveled':
                p1 = Vector2(jx, y2 - r2)
                p2 = Vector2(x1, y2)
                segments.append([p1, p2])

            elif corner_style == 'rounded':
                arc = arcpath(jx - dx2, y2 - r2 * 2, r2 * 2, r2 * 2,
                              a1 + da, da)
                segments = segments + arc

            p1 = Vector2(x1, y2)
            p2 = Vector2(x2, y2)
            segments.append([p1, p2])

        else:
            _ctx.line(x1, y2, x2, y2)

    # Draw main branch path
    _ctx.nofill()

    path = createpath(_ctx, segments, close=False)
    _ctx.drawpath(path)

    # Draw junction point
    style = E('junctionStyle')
    if style == 'none':
        return

    r = E('junctionRadius')
    r2 = r / 2.

    _ctx.fill(E('junctionFillColor'))
    _ctx.stroke(E('junctionStrokeColor'))
    _ctx.strokewidth(E('junctionStrokeWidth'))

    if style == 'square':
        _ctx.rect(jx - r2, jy - r2, r, r)

    elif style == 'disc':
        _ctx.oval(jx - r2, jy - r2, r, r)

    elif style == 'diamond':
        _ctx.beginpath(jx, jy - r2)
        _ctx.lineto(jx + r2, jy)
        _ctx.lineto(jx, jy + r2)
        _ctx.lineto(jx - r2, jy)
        _ctx.lineto(jx, jy - r2)
        _ctx.endpath()

    # Draw junction sign
    sign = E('junctionSign')
    if sign == 'none':
        return

    _ctx.stroke(E('junctionSignColor'))

    d = E('junctionSignSize') / 2.
    _ctx.strokewidth(E('junctionSignStrokeWidth'))

    if sign in ('minus', 'plus'):
        _ctx.line(jx - d, jy, jx + d, jy)

    if sign == 'plus':
        _ctx.line(jx, jy - d, jx, jy + d)


</t>
<t tx="karstenw.20170725110911.12">def conndrawer_by_name(name):
    if name in _conndrawer_map:
        return _conndrawer_map[name]
    else:
        raise ValueError, 'Unrecognized connection drawer name: %s' % name

</t>
<t tx="karstenw.20170725110911.2">def defaults_path(conf):
    return os.path.join('connection', conf)


</t>
<t tx="karstenw.20170725110911.3">class CurveConnectionDrawer(object):

    @others
</t>
<t tx="karstenw.20170725110911.4">def __init__(self, config={}):
    properties = {
        'nodeLineWidthStart': (NumberProperty, {'min': 0.0}),
        'nodeLineWidthEnd':   (NumberProperty, {'min': 0.0}),
        'nodeCx1Factor':      (NumberProperty, {}),
        'nodeCx2Factor':      (NumberProperty, {}),
        'nodeCy1Factor':      (NumberProperty, {}),
        'nodeCy2Factor':      (NumberProperty, {})
    }

    self._props = Properties(properties, defaults_path('curve'), config)

</t>
<t tx="karstenw.20170725110911.5">def _eval_func(self, node):
    return lambda name: self._props.eval(name, node)

</t>
<t tx="karstenw.20170725110911.6">def draw(self, node):
    """
    Draw a curved connection between a node and its child nodes.
    """

    E = self._eval_func(node)

    if node.isleaf():
        return

    _ctx.autoclosepath(True)
    _ctx.stroke(node.connectioncolor)
    _ctx.fill(node.connectioncolor)

    children = node.children

    for child in children:
        linewidth = E('nodeLineWidthEnd')

        _ctx.strokewidth(linewidth)

        direction = child.direction()
        opp_direction = opposite_dir(direction)

        x1, y1 = node.connection_point(direction)
        x2, y2 = child.connection_point(opp_direction)

        if direction == Direction.Left:
            x2 -= linewidth / 2
        elif direction == Direction.Right:
            x2 += linewidth / 2

        if len(children) == 1:
            _ctx.line(x1, y1, x2, y2)
        else:
            cx1 = (x2 - x1) * E('nodeCx1Factor')
            cx2 = (x2 - x1) * E('nodeCx2Factor')

            cy1 = (y2 - y1) * E('nodeCy1Factor')
            cy2 = (y2 - y1) * E('nodeCy2Factor')

            p1x = x1 + cx1
            p1y = y1 + cy1
            p2x = x2 - cx2
            p2y = y2 - cy2

            startwidth = E('nodeLineWidthStart') - 1
            sw = startwidth / 2.

            _ctx.beginpath(x1, y1 - sw)
            _ctx.curveto(p1x, p1y, p2x, p2y, x2, y2)
            _ctx.curveto(p2x, p2y, p1x, p1y, x1, y1 + sw)
            _ctx.endpath()


</t>
<t tx="karstenw.20170725110911.7">class JunctionConnectionDrawer(object):

    @others
_conndrawer_map = {
    'curve':    CurveConnectionDrawer,
    'junction': JunctionConnectionDrawer
}


</t>
<t tx="karstenw.20170725110911.8">def __init__(self, config={}):
    corner_styles = ('square', 'beveled', 'rounded')
    junction_styles = ('none', 'square', 'disc', 'diamond')
    junction_sign = ('none', 'plus', 'minus')

    properties = {
        'lineWidth':        (NumberProperty, {'min': 0.0}),
        'junctionXFactor':  (NumberProperty, {}),

        'cornerStyle':      (EnumProperty, {'values': corner_styles}),
        'cornerRadius':     (NumberProperty, {'min': 0.0}),
        'cornerPad':        (NumberProperty, {'min': 0.0}),

        'junctionStyle':    (EnumProperty,{'values': junction_styles}),

        'junctionRadius':       (NumberProperty, {'min': 0.0}),
        'junctionFillColor':    (ColorProperty,  {}),
        'junctionStrokeWidth':  (NumberProperty, {'min': 0.0}),
        'junctionStrokeColor':  (ColorProperty,  {}),

        'junctionSign':             (EnumProperty,
                                    {'values': junction_sign}),

        'junctionSignSize':         (NumberProperty, {'min': 0.0}),
        'junctionSignStrokeWidth':  (NumberProperty, {'min': 0.0}),
        'junctionSignColor':        (ColorProperty,  {})
    }

    self._props = Properties(properties, defaults_path('junction'),
                             config)

</t>
<t tx="karstenw.20170725110911.9">def _eval_func(self, node):
    return lambda name: self._props.eval(name, node)

</t>
<t tx="karstenw.20170725110914.1">import re, colorsys


# SVG 1.0 color keyword names
# ---------------------------
# Adapted from http://en.wikipedia.org/wiki/Web_colors#X11_color_names
# See also http://www.w3.org/TR/SVG/types.html#ColorKeywords

colornames = {
    # Pink colors
    'pink':                 (255, 192, 203),
    'lightpink':            (255, 182, 193),
    'hotpink':              (255, 105, 180),
    'deeppink':             (255,  20, 147),
    'palevioletred':        (219, 112, 147),
    'mediumvioletred':      (199,  21, 133),

    # Red colors
    'lightsalmon':          (255, 160, 122),
    'salmon':               (250, 128, 114),
    'darksalmon':           (233, 150, 122),
    'lightcoral':           (240, 128, 128),
    'indianred':            (205,  92,  92),
    'crimson':              (220,  20,  60),
    'firebrick':            (178,  34,  34),
    'darkred':              (139,   0,   0),
    'red':                  (255,   0,   0),

    # Orange colors
    'orangered':            (255,  69,   0),
    'tomato':               (255,  99,  71),
    'coral':                (255, 127,  80),
    'darkorange':           (255, 140,   0),
    'orange':               (255, 165,   0),
    'gold':                 (255, 215,   0),

    # Yellow colors
    'yellow':               (255, 255,   0),
    'lightyellow':          (255, 255, 224),
    'lemonchiffon':         (255, 250, 205),
    'lightgoldenrodyellow': (250, 250, 210),
    'papayawhip':           (255, 239, 213),
    'moccasin':             (255, 228, 181),
    'peachpuff':            (255, 218, 185),
    'palegoldenrod':        (238, 232, 170),
    'khaki':                (240, 230, 140),
    'darkkhaki':            (189, 183, 107),

    # Brown colors
    'cornsilk':             (255, 248, 220),
    'blanchedalmond':       (255, 235, 205),
    'bisque':               (255, 228, 196),
    'navajowhite':          (255, 222, 173),
    'wheat':                (245, 222, 179),
    'burlywood':            (222, 184, 135),
    'tan':                  (210, 180, 140),
    'rosybrown':            (188, 143, 143),
    'sandybrown':           (244, 164,  96),
    'goldenrod':            (218, 165,  32),
    'darkgoldenrod':        (184, 134,  11),
    'peru':                 (205, 133,  63),
    'chocolate':            (210, 105,  30),
    'saddlebrown':          (139,  69,  19),
    'sienna':               (160,  82,  45),
    'brown':                (165,  42,  42),
    'maroon':               (128,   0,   0),

    # Green colors
    'darkolivegreen':       ( 85, 107,  47),
    'olive':                (128, 128,   0),
    'olivedrab':            (107, 142,  35),
    'yellowgreen':          (154, 205,  50),
    'limegreen':            ( 50, 205,  50),
    'lime':                 (  0, 255,   0),
    'lawngreen':            (124, 252,   0),
    'chartreuse':           (127, 255,   0),
    'greenyellow':          (173, 255,  47),
    'springgreen':          (  0, 255, 127),
    'mediumspringgreen':    (  0, 250, 154),
    'lightgreen':           (144, 238, 144),
    'palegreen':            (152, 251, 152),
    'darkseagreen':         (143, 188, 143),
    'mediumseagreen':       ( 60, 179, 113),
    'seagreen':             ( 46, 139,  87),
    'forestgreen':          ( 34, 139,  34),
    'green':                (  0, 128,   0),
    'darkgreen':            (  0, 100,   0),

    # Cyan colors
    'mediumaquamarine':     (102, 205, 170),
    'aqua':                 (  0, 255, 255),
    'cyan':                 (  0, 255, 255),
    'lightcyan':            (224, 255, 255),
    'paleturquoise':        (175, 238, 238),
    'aquamarine':           (127, 255, 212),
    'turquoise':            ( 64, 224, 208),
    'mediumturquoise':      ( 72, 209, 204),
    'darkturquoise':        (  0, 206, 209),
    'lightseagreen':        ( 32, 178, 170),
    'cadetblue':            ( 95, 158, 160),
    'darkcyan':             (  0, 139, 139),
    'teal':                 (  0, 128, 128),

    # Blue colors
    'lightsteelblue':       (176, 196, 222),
    'powderblue':           (176, 224, 230),
    'lightblue':            (173, 216, 230),
    'skyblue':              (135, 206, 235),
    'lightskyblue':         (135, 206, 250),
    'deepskyblue':          (  0, 191, 255),
    'dodgerblue':           ( 30, 144, 255),
    'cornflowerblue':       (100, 149, 237),
    'steelblue':            ( 70, 130, 180),
    'royalblue':            ( 65, 105, 225),
    'blue':                 (  0,   0, 255),
    'mediumblue':           (  0,   0, 205),
    'darkblue':             (  0,   0, 139),
    'navy':                 (  0,   0, 128),
    'midnightblue':         ( 25,  25, 112),

    # Purple colors
    'lavender':             (230, 230, 250),
    'thistle':              (216, 191, 216),
    'plum':                 (221, 160, 221),
    'violet':               (238, 130, 238),
    'orchid':               (218, 112, 214),
    'fuchsia':              (255,   0, 255),
    'magenta':              (255,   0, 255),
    'mediumorchid':         (186,  85, 211),
    'mediumpurple':         (147, 112, 219),
    'blueviolet':           (138,  43, 226),
    'darkviolet':           (148,   0, 211),
    'darkorchid':           (153,  50, 204),
    'darkmagenta':          (139,   0, 139),
    'purple':               (128,   0, 128),
    'indigo':               ( 75,   0, 130),
    'darkslateblue':        ( 72,  61, 139),
    'slateblue':            (106,  90, 205),
    'mediumslateblue':      (123, 104, 238),

    # White/Gray/Black colors
    'white':                (255, 255, 255),
    'snow':                 (255, 250, 250),
    'honeydew':             (240, 255, 240),
    'mintcream':            (245, 255, 250),
    'azure':                (240, 255, 255),
    'aliceblue':            (240, 248, 255),
    'ghostwhite':           (248, 248, 255),
    'whitesmoke':           (245, 245, 245),
    'seashell':             (255, 245, 238),
    'beige':                (245, 245, 220),
    'oldlace':              (253, 245, 230),
    'floralwhite':          (255, 250, 240),
    'ivory':                (255, 255, 240),
    'antiquewhite':         (250, 235, 215),
    'linen':                (250, 240, 230),
    'lavenderblush':        (255, 240, 245),
    'mistyrose':            (255, 228, 225),
    'gainsboro':            (220, 220, 220),
    'lightgray':            (211, 211, 211),
    'silver':               (192, 192, 192),
    'darkgray':             (169, 169, 169),
    'gray':                 (128, 128, 128),
    'dimgray':              (105, 105, 105),
    'lightslategray':       (119, 136, 153),
    'slategray':            (112, 128, 144),
    'darkslategray':        ( 47,  79,  79),
    'black':                (  0,   0,   0)
}


# Precompile regular expressions for rgb(a) &amp; hsl(a) format matching
i = '\s*([-+]?\d+)\s*'       # int
p = '\s*([-+]?\d+)\%\s*'     # percent
f = '\s*([-+]?\d*\.?\d+)\s*' # float

_re_rgb    = re.compile('rgb\(%s,%s,%s\)'     % (i, i, i))
_re_rgb_p  = re.compile('rgb\(%s,%s,%s\)'     % (p, p, p))
_re_rgba   = re.compile('rgba\(%s,%s,%s,%s\)' % (i, i, i, f))
_re_rgba_p = re.compile('rgba\(%s,%s,%s,%s\)' % (p, p, p, f))
_re_hsl    = re.compile('hsl\(%s,%s,%s\)'     % (i, p, p))
_re_hsla   = re.compile('hsla\(%s,%s,%s,%s\)' % (i, p, p, f))

del i, p, f


</t>
<t tx="karstenw.20170725110914.2">def _parse_hex(col):
    if len(col) == 0:
        raise ValueError
    if col[0] == '#':
        col = col[1:]

    if len(col) == 3:
        r = int(col[0], 16) / 15.
        g = int(col[1], 16) / 15.
        b = int(col[2], 16) / 15.
        return r, g, b

    elif len(col) == 6:
        r = int(col[0:2], 16) / 255.
        g = int(col[2:4], 16) / 255.
        b = int(col[4:6], 16) / 255.
        return r, g, b
    else:
        raise ValueError


</t>
<t tx="karstenw.20170725110914.3">def _conv_rgb(c):
    return min(max(0, float(c)), 255) / 255.


</t>
<t tx="karstenw.20170725110914.4">def _conv_percent(p):
    return min(max(0, float(p)), 100) / 100.


</t>
<t tx="karstenw.20170725110914.5">def _conv_alpha(a):
    return min(max(0, float(a)), 1)


</t>
<t tx="karstenw.20170725110914.6">def _conv_hue(h):
    return float(h) / 360


</t>
<t tx="karstenw.20170725110914.7">def color_to_rgba(col):
    # Convert to string to handle hex colors consisting of decimal
    # digits only correctly
    col = str(col).strip()
    a = 1.0

    if col in colornames:
        r, g, b = colornames[col]
        return r / 255., g / 255., b / 255., a

    try:
        r, g, b = _parse_hex(col)
        return r, g, b, a
    except ValueError:
        pass

    # rgb(r, g, b)
    m = _re_rgb.match(col)
    if m:
        r, g, b =  m.groups()
        r = _conv_rgb(r)
        g = _conv_rgb(g)
        b = _conv_rgb(b)
        return r, g, b, a

    # rgb(r%, g%, b%)
    m = _re_rgb_p.match(col)
    if m:
        r, g, b =  m.groups()
        r = _conv_percent(r)
        g = _conv_percent(g)
        b = _conv_percent(b)
        return r, g, b, a

    # rgba(r, g, b, a)
    m = _re_rgba.match(col)
    if m:
        r, g, b, a =  m.groups()
        r = _conv_rgb(r)
        g = _conv_rgb(g)
        b = _conv_rgb(b)
        a = _conv_alpha(a)
        return r, g, b, a

    # rgba(r%, g%, b%, a)
    m = _re_rgba_p.match(col)
    if m:
        r, g, b, a =  m.groups()
        r = _conv_percent(r)
        g = _conv_percent(g)
        b = _conv_percent(b)
        a = _conv_alpha(a)
        return r, g, b, a

    # hsl(h, s, l)
    m = _re_hsl.match(col)
    if m:
        h, s, l =  m.groups()
        h = _conv_hue(h)
        s = _conv_percent(s)
        l = _conv_percent(l)
        r, g, b = colorsys.hls_to_rgb(h, l, s)
        return r, g, b, a

    # hsla(h, s, l, a)
    m = _re_hsla.match(col)
    if m:
        h, s, l, a =  m.groups()
        h = _conv_hue(h)
        s = _conv_percent(s)
        l = _conv_percent(l)
        a = _conv_alpha(a)
        r, g, b = colorsys.hls_to_rgb(h, l, s)
        return r, g, b, a

    raise ValueError, ('Invalid color: %s' % col)


</t>
<t tx="karstenw.20170725110914.8">def rgba_to_color(r, g, b, a, format='rgba'):
    r = min(max(r, 0), 1)
    g = min(max(g, 0), 1)
    b = min(max(b, 0), 1)
    a = min(max(a, 0), 1)

    if format == 'hex':
        return '#%02x%02x%02x' % (r * 255 + .5, g * 255 + .5, b * 255 + .5)

    if format == 'rgb':
        return 'rgb(%.0f, %.0f, %.0f)' % (r * 255, g * 255, b * 255)

    if format == 'rgba':
        return 'rgba(%.0f, %.0f, %.0f, %.3f)' % (r * 255, g * 255, b * 255, a)

    if format == 'rgb_p':
        return 'rgb(%.0f%%, %.0f%%, %.0f%%)' % (r * 100, g * 100, b * 100)

    if format == 'rgba_p':
        return ('rgba(%.0f%%, %.0f%%, %.0f%%, %.3f)'
                % (r * 100, g * 100, b * 100, a))

    if format == 'hsl':
        h, l, s = colorsys.rgb_to_hls(r, g, b)
        return 'hsl(%.0f, %.0f%%, %.0f%%)' % (h * 360, s * 100, l * 100)

    if format == 'hsla':
        h, l, s = colorsys.rgb_to_hls(r, g, b)
        return ('hsla(%.0f, %.0f%%, %.0f%%, %.3f)'
                % (h * 360, s * 100, l * 100, a))

    raise ValueError, 'Invalid color format: %s' % format

</t>
<t tx="karstenw.20170725110917.1">import math


</t>
<t tx="karstenw.20170725110917.10">def __iadd__(self, s):
    self.x += s.x
    self.y += s.y
    return self

</t>
<t tx="karstenw.20170725110917.11">def __sub__(self, s):
    return Vector2(self.x - s.x, self.y - s.y)

</t>
<t tx="karstenw.20170725110917.12">def __isub__(self, s):
    self.x -= s.x
    self.y -= s.y
    return self

</t>
<t tx="karstenw.20170725110917.13">def __mul__(self, s):
    return Vector2(self.x * s, self.y * s)

</t>
<t tx="karstenw.20170725110917.14">def __rmul__(self, s):
    return Vector2(self.x * s, self.y * s)

</t>
<t tx="karstenw.20170725110917.15">def __imul__(self, s):
    self.x *= s
    self.y *= s
    return self

</t>
<t tx="karstenw.20170725110917.16">def __div__(self, s):
    return Vector2(self.x / s, self.y / s)

</t>
<t tx="karstenw.20170725110917.17">def __idiv__(self, s):
    self.x /= s
    self.y /= s
    return self


</t>
<t tx="karstenw.20170725110917.18">class Rectangle(object):
    @others
</t>
<t tx="karstenw.20170725110917.19">def __init__(self, x, y, w, h):
    self.x = x
    self.y = y
    self.w = w
    self.h = h

</t>
<t tx="karstenw.20170725110917.2">class Vector2(object):
    """ Class representing two-dimensional vectors.

    The coordinate system used has the following properties:
        - the origo (0,0) is located in the top left corner
        - the positive x direction is from left to right
        - the positive y direction is from top to bottom
        - positive rotation is counter-clockwise
    """
    @others
</t>
<t tx="karstenw.20170725110917.20">def __repr__(self):
    return '(x=%s, y=%s, w=%s, h=%s)' % (self.x, self.y, self.w, self.h)

</t>
<t tx="karstenw.20170725110917.21">def params(self):
    return self.x, self.y, self.w, self.h

</t>
<t tx="karstenw.20170725110917.22">def points(self):
    return [Point2D(self.x,          self.y),
            Point2D(self.x + self.w, self.y),
            Point2D(self.x + self.w, self.y + self.h),
            Point2D(self.x,          self.y + self.h)]

</t>
<t tx="karstenw.20170725110917.23">def expand(self, rect):
    r1x1 = self.x
    r1y1 = self.y
    r1x2 = r1x1 + self.w
    r1y2 = r1y1 + self.h

    r2x1 = rect.x
    r2y1 = rect.y
    r2x2 = r2x1 + rect.w
    r2y2 = r2y1 + rect.h

    x1 = min(r1x1, r2x1)
    y1 = min(r1y1, r2y1)
    x2 = max(r1x2, r2x2)
    y2 = max(r1y2, r2y2)

    self.x = x1
    self.y = y1
    self.w = x2 - x1
    self.h = y2 - y1

</t>
<t tx="karstenw.20170725110917.3">def __init__(self, *args, **kwargs):
    if args:
        if isinstance(args[0], Vector2):
            self.x = float(args[0].x)
            self.y = float(args[0].y)
            return
        elif len(args) &lt; 2:
            raise ValueError, "Must specify 'x' and 'y' of new vector"
        self.x = float(args[0])
        self.y = float(args[1])
    else:
        if not ('m' in kwargs and 'angle' in kwargs):
            raise ValueError, "Must specify 'm' and 'angle' of new vector"
        m = kwargs['m']
        a = -kwargs['angle']
        self.x = m * math.cos(a)
        self.y = m * math.sin(a)

</t>
<t tx="karstenw.20170725110917.4">def __repr__(self):
    return '(%s, %s)' % (self.x, self.y)

</t>
<t tx="karstenw.20170725110917.5">def magnitude(self):
    return math.sqrt(self.x * self.x + self.y * self.y)

m = property(magnitude)

</t>
<t tx="karstenw.20170725110917.6">def angle(self):
    a = -math.atan2(self.y, self.x)
    if a &lt; 0:
        a += math.pi * 2
    return a

a = property(angle)

</t>
<t tx="karstenw.20170725110917.7">def normalize(self):
    m = self.magnitude()
    if m != 0:
        self.x /= m
        self.y /= m
    return self

</t>
<t tx="karstenw.20170725110917.8">def rotate(self, angle):
    angle = -angle
    cos = math.cos(angle)
    sin = math.sin(angle)
    x = self.x * cos - self.y * sin
    y = self.x * sin + self.y * cos
    self.x = x
    self.y = y
    return self

</t>
<t tx="karstenw.20170725110917.9">def __add__(self, s):
    return Vector2(self.x + s.x, self.y + s.y)

</t>
<t tx="karstenw.20170725110919.1">import math

from twyg.geom import Vector2


</t>
<t tx="karstenw.20170725110919.10">def round_poly(points, r, close=True):
    """ Round a polygon defined by connecting segments by a specified
    radius.
    """

    # Handle degenerate cases
    if len(points) &lt;= 1:
        return None
    if len(points) == 2:
        p0 = points[0]
        p1 = points[1]
        return [[p0, p1]]

    # Calculate corner arcs
    # TODO make a copy of points before appending
    arcs = []
    if close:
        points.append(points[0])
        points.append(points[1])

    for i in range(len(points) - 2):
        a = round_corner(points[i], points[i + 1], points[i + 2], r)
        if a:
            arcs.append(a)

    # Build full Bezier-path using the arcs and connect arc endpoints
    # with straight lines.
    if close:
        arcs.append(arcs[0])

    path = []
    if not close:
        p0 = points[0]
        p1 = arcs[0][0][0]
        path.append([p0, p1])

    for i in range(len(arcs) - 1):
        p0 = arcs[i][-1][-1]
        p1 = arcs[i + 1][0][0]
        path += arcs[i]
        path.append([p0, p1])

    path += arcs[-1]

    if not close:
        p0 = arcs[-1][-1][-1]
        p1 = points[-1]
        path.append([p0, p1])

    return path


</t>
<t tx="karstenw.20170725110919.11">def rounded_rect(x, y, w, h, r):
    points = [Vector2(x, y), Vector2(x + w, y),
              Vector2(x + w, y + h), Vector2(x, y + h)]

    return round_poly(points, r)


</t>
<t tx="karstenw.20170725110919.12">def intersect(p1, p2, p3, p4):
    c = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x)

    # The two lines are parallel
    if abs(c) &lt; 1e-15:
        return None

    a = p1.x * p2.y - p1.y * p2.x
    b = p3.x * p4.y - p3.y * p4.x

    x = (a * (p3.x - p4.x) - (p1.x - p2.x) * b) / c
    y = (a * (p3.y - p4.y) - (p1.y - p2.y) * b) / c

    return Vector2(x, y)


</t>
<t tx="karstenw.20170725110919.13">def offset_poly(points, d, close=True):
    """ Offset polygon defined by ``points`` by amount ``d``.

    Works correctly only for small offsets and convex or "not too
    concave" polygons.
    """
    # Handle degenerate cases
    if len(points) &lt;= 1:
        return points

    points.append(points[0])

    lines = []
    for i in range(len(points) - 1):
        p1 = points[i]
        p2 = points[i + 1]

        # Calculate normal
        n = (p2 - p1).normalize().rotate(math.pi / 2)
        shift = n * d
        lines.append([p1 + shift, p2 + shift])

    points.pop()
    lines.append(lines[0])

    offs = []
    for i in range(len(lines) - 1):
        l1 = lines[i]
        l2 = lines[i + 1]
        offs.append(intersect(l1[0], l1[1], l2[0], l2[1]))

    offs.insert(0, offs.pop())
    return offs

</t>
<t tx="karstenw.20170725110919.2">def calc_regular_polygon_points(cx, cy, r, numsides, rotation=0):
    """ Calculates the vertices of a regular n-sided polygon. """

    points = []
    a = 2 * math.pi / numsides
    sa = math.radians(rotation)

    for i in range(numsides + 1):
        x = cx + r * math.cos(sa + a * i)
        y = cy - r * math.sin(sa + a * i)
        points.append(Vector2(x, y))

    return points


</t>
<t tx="karstenw.20170725110919.3">def calc_regular_polygon_intersections(w, ystep, **kwargs):
    h = w
    r =  w / 2.
    cx = r
    cy = r
    numsides = kwargs['numSides']
    rotation = kwargs['rotation']

    points = calc_regular_polygon_points(cx, cy, r, numsides, rotation)
    points = slice_shape(points, 0, h, ystep)

    return points, w, h


</t>
<t tx="karstenw.20170725110919.4">def calc_ellipse_intersections(w, ystep, **kwargs):
    aspectratio = kwargs['aspectRatio']
    maxwidth = kwargs['maxWidth']

    h = w / float(aspectratio)
    if ystep &gt; h:
        s = 1 + ystep / h
        h *= s
        w *= s

    w = min(w, maxwidth)

    points = slice_ellipse(0, 0, w, h, ystep, rfactor=1.0)
    return points, w, h


</t>
<t tx="karstenw.20170725110919.5">def slice_shape(points, y, h, ystep):
    """
    Calculate the intersections of a convex shape and a set of
    equidistant horizontal lines.

    `points`
       points defining the shape segments
    `y`
       topmost (lowest value) y coordinate of the original shape
    `h`
       height of the original shape
    `ystep`
        vertical distance between horizontal lines

    Only point-pairs are returned, single-point intersections are
    omitted (e.g. when a horizontal line goes exactly through a single
    vertex).

    The point-pairs are returned in a 3-dimensional array:

        points = [[l1p1, l2p2], [l2p1, l2p2], ... [lnp1, lnp2]]

    The points have the following properties:

        lnp1.y  = lnp2.y
        lnp1.x &lt;= lnp2.x
        lnpm.y  &lt; l(n + 1)pm.y
    """
    # Close the shape if the shape is already closed that doesn't
    # affect the algorithm
    points.append(points[0])

    numlines = (int) (float(h) / ystep)

    # Special case when ystep &gt; h / 2
    if numlines == 1:
        numlines = 2

    # Center lines to the vertical center of the shape
    y = y + (h - (numlines - 1) * ystep) / 2.

    # Iterate through all horizontal lines (starting from the lowest y
    # coordinate) and calculate the two intersection points of each line
    # with the shape segments (some lines may result in zero or one
    # intersections, these will be omitted).

    intersections = []

    for l in range(numlines):
        pointpair = []

        for i in range(len(points) - 1):
            p1 = points[i]
            p2 = points[i + 1]

            if p1.y &gt; p2.y:
                p1, p2 = p2, p1

            if y &gt;= p1.y and y &lt; p2.y:
                # Special case for p1.x = p2.x (vertical line)
                dx = p2.x - p1.x + 1e-5

                # Calculate the intersection of a horizontal line and a
                # single shape segment
                dy = p2.y - p1.y
                m =  dy / dx
                x =  p1.x + 1 / m * (y - p1.y)

                pointpair.append(Vector2(x, y))

                # There should be two (or zero) intersections for each
                # horizontal line
                if len(pointpair) == 2:
                    if pointpair[0].x &gt; pointpair[1].x:
                        pointpair[0], pointpair[1] = pointpair[1], pointpair[0]

                    intersections.append(pointpair)
                    break
        y += ystep

    return intersections


</t>
<t tx="karstenw.20170725110919.6">def slice_ellipse(x, y, w, h, ystep, rfactor=1.0):
    """
    Calculate the intersections of an ellipse (or two elliptical arcs
    horizontally symmetrical to the center point) and a set of
    equidistant horizontal lines.

    ``x, y, w, h``
        Bounding box of the ellipse.
    ``ystep``
        Vertical distance between horizontal lines.
    ``rfactor``
        If ``rfactor`` equals 1.0, a normal ellipse is used. If
        ``rfactor`` is greater than 1.0, two elliptical arcs
        horizontally symmetrical to the center point will be calculated
        (rfactor sets the 'flatness' of the arcs).

    The function returns the intersection point-pairs in the same format
    as ``slice_shape``.
    """

    if ystep &gt;= h:
        return []

    points = []

    # Store original x center for the final mirroring step
    cxo = x + w / 2.

    # Calculate the "ovalness" of the ellipse and adjust center point
    xscale = float(w) / h
    x += h * xscale / 2.

    # If rfactor &gt; 1, not a full half-arc will be used but only a
    # smaller symmetrical segment of it.  This is accomplished by
    # scaling the original radius up then adjusting the location of the
    # center point.
    r = h / 2.
    cx = x + r * (rfactor - 1)
    cy = y + r
    r *= rfactor

    # Special case when ystep &gt; circle radius
    numlines = (int) (float(h) / ystep)
    if numlines == 1:
        numlines = 2

    # Adjust the x coords of the points so that the top and bottommost
    # points of the arc are always in the same position, regardless of
    # the rfactor
    xcorr = x - (cx - r * xscale) - w / 2.

    # Center points vertically
    py = y + (h - (numlines - 1) * ystep) / 2.

    while numlines:
        px = cx - math.sqrt(r * r - pow(py - cy, 2)) * xscale + xcorr
        points.append(Vector2(px, py))
        py += ystep
        numlines -= 1

    # Mirror points on the y axis and return point-pair arrays for each
    # line
    return [[p, Vector2(2 * cxo - p.x, p.y)] for p in points]


</t>
<t tx="karstenw.20170725110919.7">def arcpath(x, y, w, h, a1, da):
    #TODO insert formula reference 
    def _calc_arc_segment(cx, cy, x1, y1, x4, y4):
        ax = x1 - cx
        ay = y1 - cy
        bx = x4 - cx
        by = y4 - cy
        q1 = ax * ax + ay * ay
        q2 = q1 + ax * bx + ay * by

        d = ax * by - ay * bx
        if d == 0:
            d = 1e-15
        k2 = 1.3333333333 * (math.sqrt(2 * q1 * q2) - q2) / d

        x2 = cx + ax - k2 * ay
        y2 = cy + ay + k2 * ax
        x3 = cx + bx + k2 * by
        y3 = cy + by - k2 * bx

        return [Vector2(x1, y1), Vector2(x2, y2),
                Vector2(x3, y3), Vector2(x4, y4)]

    def _quad_startpoint(cx, cy, r, quad):
        """
        Quads:
        0: top right (0 - 90)
        1: top left (90 - 180)
        2: bottom left (180 - 270)
        3: bottom right (270 - 360)
        """
        quad %= 4
        if quad == 0:
            x1 = cx + r
            y1 = cy
        elif quad == 1:
            x1 = cx
            y1 = cy - r
        elif quad == 2:
            x1 = cx - r
            y1 = cy
        elif quad == 3:
            x1 = cx
            y1 = cy + r
        return [x1, y1]


    if da == 0 or w == 0 or h == 0:
        return []

    cx = x + w / 2.
    cy = y + h / 2.
    r = w / 2.

    a1 %= 360
    da = max(min(da, 360), -360)
    a2 = a1 + da

    quadstart =  (int) (math.floor(a1 / 90.))
    quadend = (int) (math.floor(a2 / 90.))

    a1 = math.radians(a1)
    a2 = math.radians(a2)

    a1x = cx + r * math.cos(a1)
    a1y = cy - r * math.sin(a1)
    a2x = cx + r * math.cos(a2)
    a2y = cy - r * math.sin(a2)

    points = []

    if quadstart == quadend:
        points.append(_calc_arc_segment(cx, cy, a1x, a1y, a2x, a2y))

    elif abs(quadstart - quadend) == 1:
        p = _quad_startpoint(cx, cy, r, quadend if da &gt; 0 else quadstart)
        points.append(_calc_arc_segment(cx, cy, a1x, a1y, p[0], p[1]))
        points.append(_calc_arc_segment(cx, cy, p[0], p[1], a2x, a2y))

    else:
        if da &gt; 0:
            quadstart += 1
            d = 1
        else:
            quadend += 1
            d = -1

        p = _quad_startpoint(cx, cy, r, quadstart)
        points.append(_calc_arc_segment(cx, cy, a1x, a1y, p[0], p[1]))

        quad = quadstart
        while quad != quadend:
            p1 = _quad_startpoint(cx, cy, r, quad)
            p2 = _quad_startpoint(cx, cy, r, quad + d)
            points.append(_calc_arc_segment(cx, cy, p1[0], p1[1],
                                                    p2[0], p2[1]))
            quad += d

        p = _quad_startpoint(cx, cy, r, quadend)
        points.append(_calc_arc_segment(cx, cy, p[0], p[1], a2x, a2y))

    return points


</t>
<t tx="karstenw.20170725110919.8">def halfcircle(cx, y1, y2, rfactor, dir, y):
    dir = -dir
    dy = float(y2 - y1)
    r = dy / 2
    cy = (y1 + y2) / 2.
    r *= rfactor
    xcorr = dir * math.sqrt(r * r - pow(y1 - cy, 2))
    return cx - dir * math.sqrt(r * r - pow(y - cy, 2)) + xcorr


</t>
<t tx="karstenw.20170725110919.9">def round_corner(p1, p2, p3, r):
    """ Calculate the Bezier-path segments defining a circular rounded
    corner of radius ``r`` of the two straight line segments `(p1,p2)`
    and `(p2,p3)`.

    Fit a circle of radius ``r`` into the triangle defined by points
    ``p1``, ``p2`` and ``p3`` so that segments `(p1,p2)` and `(p3,p2)`
    are tangents to the circle, then return the Bezier-path of the arc
    segment of radius ``r`` between points ``p1`` and ``p3``, facing
    ``p1``.
    """

    # Optimization for the 90 degree case when the two segments are
    # parallel to the axes (~2.3x speedup). This is used frequently for
    # drawing rounded rectangles.
    d = 1e-5
    s1_horiz = abs(p1.y - p2.y) &lt; d
    s2_horiz = abs(p2.y - p3.y) &lt; d
    s1_vert = abs(p1.x - p2.x) &lt; d
    s2_vert = abs(p2.x - p3.x) &lt; d

    # Handle 0, 180 degree and single point cases
    if (s1_horiz and s2_horiz) or (s1_vert and s2_vert):
        return []

    if (s1_vert and s2_horiz) or (s1_horiz or s2_vert):
        if s1_horiz:
            dx = p2.x &gt; p1.x
            dy = p3.y &gt; p2.y
        else:
            dx = p3.x &gt; p2.x
            dy = p2.y &gt; p1.y

        # the conditions calculating the arc's angles can be derived
        # from the following table:
        #
        #  dx   dy   sa   da s1_horiz quadrant
        # --- ---- ---- ---- -------- --------
        #   1    1   90  -90   1         1
        #   0    1    0  -90   0         4
        #   0    0  270  -90   1         3
        #   1    0  180  -90   0         2
        #   0    0    0   90   0         1
        #   1    0  270   90   1         4
        #   1    1  180   90   0         3
        #   0    1   90   90   1         2
        if (   (dx == dy) and s1_horiz
            or (dx != dy) and not s1_horiz):
            da = -90
        else:
            da = 90

        if s1_horiz:
            sa = 90 if dy else 270
        else:
            sa = 180 if dx else 0

        # Determine which quadrant should the arc be drawn in
        q = sa
        if da &lt; 0:
            q -= 90
            if q &lt; 0:
                q += 360

        r *= 2
        x = p2.x
        y = p2.y
        if q == 0:
            x -= r
        elif q == 180:
            y -= r
        elif q == 270:
            x -= r
            y -= r

        return arcpath(x, y, r, r, sa, da)

    # General case (we've already handles the 0 and 180 degree cases)
    a1 = (p1 - p2).a
    a2 = (p3 - p2).a
    ang = a2 - a1

    if ang &gt; math.pi:
        ang -= 2 * math.pi
    elif ang &lt; -math.pi:
        ang += 2 * math.pi

    # Length of the segment between p2 and the center of the circle
    aa = r / math.sin(ang / 2)

    # Calculate the center point of the circle
    c = Vector2(m=abs(aa), angle=a1 + ang / 2) + p2

    # Distance from p2 to the tangent points
    dd = r / math.tan(ang / 2)

    # Tangent point of segments p1, p2
    p = Vector2(m=abs(dd), angle=a1) + p2

    # Tangent point of segments p3, p2
    q = Vector2(m=abs(dd), angle=a2) + p2

    # Calculate a third point on the circle halfway between the two
    # tangent points. This will be on the arc segment that should be
    # drawn, which is needed to be able to determine the correct
    # direction of the arc.
    m = Vector2(m=abs(aa) - r, angle=a1 + ang / 2) + p2

    # Calculate the positions of points p, q and m on the circle
    # expressed as angles from the positive X axis.
    start_a = (p - c).a
    mid_a = (m - c).a
    end_a = (q - c).a

    # Start angle of the arc segment
    sa = start_a

    # Adjust arc length so the arc will always be drawn correctly in the
    # corner of the triangle.
    if start_a &lt; mid_a &lt; end_a or start_a &gt; mid_a &gt; end_a:
        da = end_a - start_a
    else:
        if start_a &lt; end_a:
            da = -(start_a + 2 * math.pi - end_a)
        else:
            da = end_a + 2 * math.pi - start_a

    # Calculate Bezier points of the arc
    return arcpath(c.x - r, c.y - r, 2 * r, 2 * r,
                   math.degrees(sa), math.degrees(da))


</t>
<t tx="karstenw.20170725110922.1">""" Hyphenation, using Frank Liang's algorithm.

    This module provides a single function to hyphenate words.  hyphenate_word takes
    a string (the word), and returns a list of parts that can be separated by hyphens.

    &gt;&gt;&gt; hyphenate_word("hyphenation")
    ['hy', 'phen', 'ation']
    &gt;&gt;&gt; hyphenate_word("supercalifragilisticexpialidocious")
    ['su', 'per', 'cal', 'ifrag', 'ilis', 'tic', 'ex', 'pi', 'ali', 'do', 'cious']
    &gt;&gt;&gt; hyphenate_word("project")
    ['project']
    
    Ned Batchelder, July 2007.
    This Python code is in the public domain.
"""

import re

__version__ = '1.0.20070709'

</t>
<t tx="karstenw.20170725110922.2">class Hyphenator:
    @others
patterns = (
# Knuth and Liang's original hyphenation patterns from classic TeX.
# In the public domain.
"""
.ach4 .ad4der .af1t .al3t .am5at .an5c .ang4 .ani5m .ant4 .an3te .anti5s .ar5s
.ar4tie .ar4ty .as3c .as1p .as1s .aster5 .atom5 .au1d .av4i .awn4 .ba4g .ba5na
.bas4e .ber4 .be5ra .be3sm .be5sto .bri2 .but4ti .cam4pe .can5c .capa5b .car5ol
.ca4t .ce4la .ch4 .chill5i .ci2 .cit5r .co3e .co4r .cor5ner .de4moi .de3o .de3ra
.de3ri .des4c .dictio5 .do4t .du4c .dumb5 .earth5 .eas3i .eb4 .eer4 .eg2 .el5d
.el3em .enam3 .en3g .en3s .eq5ui5t .er4ri .es3 .eu3 .eye5 .fes3 .for5mer .ga2
.ge2 .gen3t4 .ge5og .gi5a .gi4b .go4r .hand5i .han5k .he2 .hero5i .hes3 .het3
.hi3b .hi3er .hon5ey .hon3o .hov5 .id4l .idol3 .im3m .im5pin .in1 .in3ci .ine2
.in2k .in3s .ir5r .is4i .ju3r .la4cy .la4m .lat5er .lath5 .le2 .leg5e .len4
.lep5 .lev1 .li4g .lig5a .li2n .li3o .li4t .mag5a5 .mal5o .man5a .mar5ti .me2
.mer3c .me5ter .mis1 .mist5i .mon3e .mo3ro .mu5ta .muta5b .ni4c .od2 .odd5
.of5te .or5ato .or3c .or1d .or3t .os3 .os4tl .oth3 .out3 .ped5al .pe5te .pe5tit
.pi4e .pio5n .pi2t .pre3m .ra4c .ran4t .ratio5na .ree2 .re5mit .res2 .re5stat
.ri4g .rit5u .ro4q .ros5t .row5d .ru4d .sci3e .self5 .sell5 .se2n .se5rie .sh2
.si2 .sing4 .st4 .sta5bl .sy2 .ta4 .te4 .ten5an .th2 .ti2 .til4 .tim5o5 .ting4
.tin5k .ton4a .to4p .top5i .tou5s .trib5ut .un1a .un3ce .under5 .un1e .un5k
.un5o .un3u .up3 .ure3 .us5a .ven4de .ve5ra .wil5i .ye4 4ab. a5bal a5ban abe2
ab5erd abi5a ab5it5ab ab5lat ab5o5liz 4abr ab5rog ab3ul a4car ac5ard ac5aro
a5ceou ac1er a5chet 4a2ci a3cie ac1in a3cio ac5rob act5if ac3ul ac4um a2d ad4din
ad5er. 2adi a3dia ad3ica adi4er a3dio a3dit a5diu ad4le ad3ow ad5ran ad4su 4adu
a3duc ad5um ae4r aeri4e a2f aff4 a4gab aga4n ag5ell age4o 4ageu ag1i 4ag4l ag1n
a2go 3agog ag3oni a5guer ag5ul a4gy a3ha a3he ah4l a3ho ai2 a5ia a3ic. ai5ly
a4i4n ain5in ain5o ait5en a1j ak1en al5ab al3ad a4lar 4aldi 2ale al3end a4lenti
a5le5o al1i al4ia. ali4e al5lev 4allic 4alm a5log. a4ly. 4alys 5a5lyst 5alyt
3alyz 4ama am5ab am3ag ama5ra am5asc a4matis a4m5ato am5era am3ic am5if am5ily
am1in ami4no a2mo a5mon amor5i amp5en a2n an3age 3analy a3nar an3arc anar4i
a3nati 4and ande4s an3dis an1dl an4dow a5nee a3nen an5est. a3neu 2ang ang5ie
an1gl a4n1ic a3nies an3i3f an4ime a5nimi a5nine an3io a3nip an3ish an3it a3niu
an4kli 5anniz ano4 an5ot anoth5 an2sa an4sco an4sn an2sp ans3po an4st an4sur
antal4 an4tie 4anto an2tr an4tw an3ua an3ul a5nur 4ao apar4 ap5at ap5ero a3pher
4aphi a4pilla ap5illar ap3in ap3ita a3pitu a2pl apoc5 ap5ola apor5i apos3t
aps5es a3pu aque5 2a2r ar3act a5rade ar5adis ar3al a5ramete aran4g ara3p ar4at
a5ratio ar5ativ a5rau ar5av4 araw4 arbal4 ar4chan ar5dine ar4dr ar5eas a3ree
ar3ent a5ress ar4fi ar4fl ar1i ar5ial ar3ian a3riet ar4im ar5inat ar3io ar2iz
ar2mi ar5o5d a5roni a3roo ar2p ar3q arre4 ar4sa ar2sh 4as. as4ab as3ant ashi4
a5sia. a3sib a3sic 5a5si4t ask3i as4l a4soc as5ph as4sh as3ten as1tr asur5a a2ta
at3abl at5ac at3alo at5ap ate5c at5ech at3ego at3en. at3era ater5n a5terna
at3est at5ev 4ath ath5em a5then at4ho ath5om 4ati. a5tia at5i5b at1ic at3if
ation5ar at3itu a4tog a2tom at5omiz a4top a4tos a1tr at5rop at4sk at4tag at5te
at4th a2tu at5ua at5ue at3ul at3ura a2ty au4b augh3 au3gu au4l2 aun5d au3r
au5sib aut5en au1th a2va av3ag a5van ave4no av3era av5ern av5ery av1i avi4er
av3ig av5oc a1vor 3away aw3i aw4ly aws4 ax4ic ax4id ay5al aye4 ays4 azi4er azz5i
5ba. bad5ger ba4ge bal1a ban5dag ban4e ban3i barbi5 bari4a bas4si 1bat ba4z 2b1b
b2be b3ber bbi4na 4b1d 4be. beak4 beat3 4be2d be3da be3de be3di be3gi be5gu 1bel
be1li be3lo 4be5m be5nig be5nu 4bes4 be3sp be5str 3bet bet5iz be5tr be3tw be3w
be5yo 2bf 4b3h bi2b bi4d 3bie bi5en bi4er 2b3if 1bil bi3liz bina5r4 bin4d bi5net
bi3ogr bi5ou bi2t 3bi3tio bi3tr 3bit5ua b5itz b1j bk4 b2l2 blath5 b4le. blen4
5blesp b3lis b4lo blun4t 4b1m 4b3n bne5g 3bod bod3i bo4e bol3ic bom4bi bon4a
bon5at 3boo 5bor. 4b1ora bor5d 5bore 5bori 5bos4 b5ota both5 bo4to bound3 4bp
4brit broth3 2b5s2 bsor4 2bt bt4l b4to b3tr buf4fer bu4ga bu3li bumi4 bu4n
bunt4i bu3re bus5ie buss4e 5bust 4buta 3butio b5uto b1v 4b5w 5by. bys4 1ca
cab3in ca1bl cach4 ca5den 4cag4 2c5ah ca3lat cal4la call5in 4calo can5d can4e
can4ic can5is can3iz can4ty cany4 ca5per car5om cast5er cas5tig 4casy ca4th
4cativ cav5al c3c ccha5 cci4a ccompa5 ccon4 ccou3t 2ce. 4ced. 4ceden 3cei 5cel.
3cell 1cen 3cenc 2cen4e 4ceni 3cent 3cep ce5ram 4cesa 3cessi ces5si5b ces5t cet4
c5e4ta cew4 2ch 4ch. 4ch3ab 5chanic ch5a5nis che2 cheap3 4ched che5lo 3chemi
ch5ene ch3er. ch3ers 4ch1in 5chine. ch5iness 5chini 5chio 3chit chi2z 3cho2
ch4ti 1ci 3cia ci2a5b cia5r ci5c 4cier 5cific. 4cii ci4la 3cili 2cim 2cin c4ina
3cinat cin3em c1ing c5ing. 5cino cion4 4cipe ci3ph 4cipic 4cista 4cisti 2c1it
cit3iz 5ciz ck1 ck3i 1c4l4 4clar c5laratio 5clare cle4m 4clic clim4 cly4 c5n 1co
co5ag coe2 2cog co4gr coi4 co3inc col5i 5colo col3or com5er con4a c4one con3g
con5t co3pa cop3ic co4pl 4corb coro3n cos4e cov1 cove4 cow5a coz5e co5zi c1q
cras5t 5crat. 5cratic cre3at 5cred 4c3reta cre4v cri2 cri5f c4rin cris4 5criti
cro4pl crop5o cros4e cru4d 4c3s2 2c1t cta4b ct5ang c5tant c2te c3ter c4ticu
ctim3i ctu4r c4tw cud5 c4uf c4ui cu5ity 5culi cul4tis 3cultu cu2ma c3ume cu4mi
3cun cu3pi cu5py cur5a4b cu5ria 1cus cuss4i 3c4ut cu4tie 4c5utiv 4cutr 1cy cze4
1d2a 5da. 2d3a4b dach4 4daf 2dag da2m2 dan3g dard5 dark5 4dary 3dat 4dativ 4dato
5dav4 dav5e 5day d1b d5c d1d4 2de. deaf5 deb5it de4bon decan4 de4cil de5com
2d1ed 4dee. de5if deli4e del5i5q de5lo d4em 5dem. 3demic dem5ic. de5mil de4mons
demor5 1den de4nar de3no denti5f de3nu de1p de3pa depi4 de2pu d3eq d4erh 5derm
dern5iz der5s des2 d2es. de1sc de2s5o des3ti de3str de4su de1t de2to de1v dev3il
4dey 4d1f d4ga d3ge4t dg1i d2gy d1h2 5di. 1d4i3a dia5b di4cam d4ice 3dict 3did
5di3en d1if di3ge di4lato d1in 1dina 3dine. 5dini di5niz 1dio dio5g di4pl dir2
di1re dirt5i dis1 5disi d4is3t d2iti 1di1v d1j d5k2 4d5la 3dle. 3dled 3dles.
4dless 2d3lo 4d5lu 2dly d1m 4d1n4 1do 3do. do5de 5doe 2d5of d4og do4la doli4
do5lor dom5iz do3nat doni4 doo3d dop4p d4or 3dos 4d5out do4v 3dox d1p 1dr
drag5on 4drai dre4 drea5r 5dren dri4b dril4 dro4p 4drow 5drupli 4dry 2d1s2 ds4p
d4sw d4sy d2th 1du d1u1a du2c d1uca duc5er 4duct. 4ducts du5el du4g d3ule dum4be
du4n 4dup du4pe d1v d1w d2y 5dyn dy4se dys5p e1a4b e3act ead1 ead5ie ea4ge
ea5ger ea4l eal5er eal3ou eam3er e5and ear3a ear4c ear5es ear4ic ear4il ear5k
ear2t eart3e ea5sp e3ass east3 ea2t eat5en eath3i e5atif e4a3tu ea2v eav3en
eav5i eav5o 2e1b e4bel. e4bels e4ben e4bit e3br e4cad ecan5c ecca5 e1ce ec5essa
ec2i e4cib ec5ificat ec5ifie ec5ify ec3im eci4t e5cite e4clam e4clus e2col
e4comm e4compe e4conc e2cor ec3ora eco5ro e1cr e4crem ec4tan ec4te e1cu e4cul
ec3ula 2e2da 4ed3d e4d1er ede4s 4edi e3dia ed3ib ed3ica ed3im ed1it edi5z 4edo
e4dol edon2 e4dri e4dul ed5ulo ee2c eed3i ee2f eel3i ee4ly ee2m ee4na ee4p1
ee2s4 eest4 ee4ty e5ex e1f e4f3ere 1eff e4fic 5efici efil4 e3fine ef5i5nite
3efit efor5es e4fuse. 4egal eger4 eg5ib eg4ic eg5ing e5git5 eg5n e4go. e4gos
eg1ul e5gur 5egy e1h4 eher4 ei2 e5ic ei5d eig2 ei5gl e3imb e3inf e1ing e5inst
eir4d eit3e ei3th e5ity e1j e4jud ej5udi eki4n ek4la e1la e4la. e4lac elan4d
el5ativ e4law elaxa4 e3lea el5ebra 5elec e4led el3ega e5len e4l1er e1les el2f
el2i e3libe e4l5ic. el3ica e3lier el5igib e5lim e4l3ing e3lio e2lis el5ish
e3liv3 4ella el4lab ello4 e5loc el5og el3op. el2sh el4ta e5lud el5ug e4mac e4mag
e5man em5ana em5b e1me e2mel e4met em3ica emi4e em5igra em1in2 em5ine em3i3ni
e4mis em5ish e5miss em3iz 5emniz emo4g emoni5o em3pi e4mul em5ula emu3n e3my
en5amo e4nant ench4er en3dic e5nea e5nee en3em en5ero en5esi en5est en3etr e3new
en5ics e5nie e5nil e3nio en3ish en3it e5niu 5eniz 4enn 4eno eno4g e4nos en3ov
en4sw ent5age 4enthes en3ua en5uf e3ny. 4en3z e5of eo2g e4oi4 e3ol eop3ar e1or
eo3re eo5rol eos4 e4ot eo4to e5out e5ow e2pa e3pai ep5anc e5pel e3pent ep5etitio
ephe4 e4pli e1po e4prec ep5reca e4pred ep3reh e3pro e4prob ep4sh ep5ti5b e4put
ep5uta e1q equi3l e4q3ui3s er1a era4b 4erand er3ar 4erati. 2erb er4bl er3ch
er4che 2ere. e3real ere5co ere3in er5el. er3emo er5ena er5ence 4erene er3ent
ere4q er5ess er3est eret4 er1h er1i e1ria4 5erick e3rien eri4er er3ine e1rio
4erit er4iu eri4v e4riva er3m4 er4nis 4ernit 5erniz er3no 2ero er5ob e5roc ero4r
er1ou er1s er3set ert3er 4ertl er3tw 4eru eru4t 5erwau e1s4a e4sage. e4sages
es2c e2sca es5can e3scr es5cu e1s2e e2sec es5ecr es5enc e4sert. e4serts e4serva
4esh e3sha esh5en e1si e2sic e2sid es5iden es5igna e2s5im es4i4n esis4te esi4u
e5skin es4mi e2sol es3olu e2son es5ona e1sp es3per es5pira es4pre 2ess es4si4b
estan4 es3tig es5tim 4es2to e3ston 2estr e5stro estruc5 e2sur es5urr es4w eta4b
eten4d e3teo ethod3 et1ic e5tide etin4 eti4no e5tir e5titio et5itiv 4etn et5ona
e3tra e3tre et3ric et5rif et3rog et5ros et3ua et5ym et5z 4eu e5un e3up eu3ro
eus4 eute4 euti5l eu5tr eva2p5 e2vas ev5ast e5vea ev3ell evel3o e5veng even4i
ev1er e5verb e1vi ev3id evi4l e4vin evi4v e5voc e5vu e1wa e4wag e5wee e3wh ewil5
ew3ing e3wit 1exp 5eyc 5eye. eys4 1fa fa3bl fab3r fa4ce 4fag fain4 fall5e 4fa4ma
fam5is 5far far5th fa3ta fa3the 4fato fault5 4f5b 4fd 4fe. feas4 feath3 fe4b
4feca 5fect 2fed fe3li fe4mo fen2d fend5e fer1 5ferr fev4 4f1f f4fes f4fie
f5fin. f2f5is f4fly f2fy 4fh 1fi fi3a 2f3ic. 4f3ical f3ican 4ficate f3icen
fi3cer fic4i 5ficia 5ficie 4fics fi3cu fi5del fight5 fil5i fill5in 4fily 2fin
5fina fin2d5 fi2ne f1in3g fin4n fis4ti f4l2 f5less flin4 flo3re f2ly5 4fm 4fn
1fo 5fon fon4de fon4t fo2r fo5rat for5ay fore5t for4i fort5a fos5 4f5p fra4t
f5rea fres5c fri2 fril4 frol5 2f3s 2ft f4to f2ty 3fu fu5el 4fug fu4min fu5ne
fu3ri fusi4 fus4s 4futa 1fy 1ga gaf4 5gal. 3gali ga3lo 2gam ga5met g5amo gan5is
ga3niz gani5za 4gano gar5n4 gass4 gath3 4gativ 4gaz g3b gd4 2ge. 2ged geez4
gel4in ge5lis ge5liz 4gely 1gen ge4nat ge5niz 4geno 4geny 1geo ge3om g4ery 5gesi
geth5 4geto ge4ty ge4v 4g1g2 g2ge g3ger gglu5 ggo4 gh3in gh5out gh4to 5gi. 1gi4a
gia5r g1ic 5gicia g4ico gien5 5gies. gil4 g3imen 3g4in. gin5ge 5g4ins 5gio 3gir
gir4l g3isl gi4u 5giv 3giz gl2 gla4 glad5i 5glas 1gle gli4b g3lig 3glo glo3r g1m
g4my gn4a g4na. gnet4t g1ni g2nin g4nio g1no g4non 1go 3go. gob5 5goe 3g4o4g
go3is gon2 4g3o3na gondo5 go3ni 5goo go5riz gor5ou 5gos. gov1 g3p 1gr 4grada
g4rai gran2 5graph. g5rapher 5graphic 4graphy 4gray gre4n 4gress. 4grit g4ro
gruf4 gs2 g5ste gth3 gu4a 3guard 2gue 5gui5t 3gun 3gus 4gu4t g3w 1gy 2g5y3n
gy5ra h3ab4l hach4 hae4m hae4t h5agu ha3la hala3m ha4m han4ci han4cy 5hand.
han4g hang5er hang5o h5a5niz han4k han4te hap3l hap5t ha3ran ha5ras har2d hard3e
har4le harp5en har5ter has5s haun4 5haz haz3a h1b 1head 3hear he4can h5ecat h4ed
he5do5 he3l4i hel4lis hel4ly h5elo hem4p he2n hena4 hen5at heo5r hep5 h4era
hera3p her4ba here5a h3ern h5erou h3ery h1es he2s5p he4t het4ed heu4 h1f h1h
hi5an hi4co high5 h4il2 himer4 h4ina hion4e hi4p hir4l hi3ro hir4p hir4r his3el
his4s hith5er hi2v 4hk 4h1l4 hlan4 h2lo hlo3ri 4h1m hmet4 2h1n h5odiz h5ods ho4g
hoge4 hol5ar 3hol4e ho4ma home3 hon4a ho5ny 3hood hoon4 hor5at ho5ris hort3e
ho5ru hos4e ho5sen hos1p 1hous house3 hov5el 4h5p 4hr4 hree5 hro5niz hro3po
4h1s2 h4sh h4tar ht1en ht5es h4ty hu4g hu4min hun5ke hun4t hus3t4 hu4t h1w
h4wart hy3pe hy3ph hy2s 2i1a i2al iam4 iam5ete i2an 4ianc ian3i 4ian4t ia5pe
iass4 i4ativ ia4tric i4atu ibe4 ib3era ib5ert ib5ia ib3in ib5it. ib5ite i1bl
ib3li i5bo i1br i2b5ri i5bun 4icam 5icap 4icar i4car. i4cara icas5 i4cay iccu4
4iceo 4ich 2ici i5cid ic5ina i2cip ic3ipa i4cly i2c5oc 4i1cr 5icra i4cry ic4te
ictu2 ic4t3ua ic3ula ic4um ic5uo i3cur 2id i4dai id5anc id5d ide3al ide4s i2di
id5ian idi4ar i5die id3io idi5ou id1it id5iu i3dle i4dom id3ow i4dr i2du id5uo
2ie4 ied4e 5ie5ga ield3 ien5a4 ien4e i5enn i3enti i1er. i3esc i1est i3et 4if.
if5ero iff5en if4fr 4ific. i3fie i3fl 4ift 2ig iga5b ig3era ight3i 4igi i3gib
ig3il ig3in ig3it i4g4l i2go ig3or ig5ot i5gre igu5i ig1ur i3h 4i5i4 i3j 4ik
i1la il3a4b i4lade i2l5am ila5ra i3leg il1er ilev4 il5f il1i il3ia il2ib il3io
il4ist 2ilit il2iz ill5ab 4iln il3oq il4ty il5ur il3v i4mag im3age ima5ry
imenta5r 4imet im1i im5ida imi5le i5mini 4imit im4ni i3mon i2mu im3ula 2in.
i4n3au 4inav incel4 in3cer 4ind in5dling 2ine i3nee iner4ar i5ness 4inga 4inge
in5gen 4ingi in5gling 4ingo 4ingu 2ini i5ni. i4nia in3io in1is i5nite. 5initio
in3ity 4ink 4inl 2inn 2i1no i4no4c ino4s i4not 2ins in3se insur5a 2int. 2in4th
in1u i5nus 4iny 2io 4io. ioge4 io2gr i1ol io4m ion3at ion4ery ion3i io5ph ior3i
i4os io5th i5oti io4to i4our 2ip ipe4 iphras4 ip3i ip4ic ip4re4 ip3ul i3qua
iq5uef iq3uid iq3ui3t 4ir i1ra ira4b i4rac ird5e ire4de i4ref i4rel4 i4res ir5gi
ir1i iri5de ir4is iri3tu 5i5r2iz ir4min iro4g 5iron. ir5ul 2is. is5ag is3ar
isas5 2is1c is3ch 4ise is3er 3isf is5han is3hon ish5op is3ib isi4d i5sis is5itiv
4is4k islan4 4isms i2so iso5mer is1p is2pi is4py 4is1s is4sal issen4 is4ses
is4ta. is1te is1ti ist4ly 4istral i2su is5us 4ita. ita4bi i4tag 4ita5m i3tan
i3tat 2ite it3era i5teri it4es 2ith i1ti 4itia 4i2tic it3ica 5i5tick it3ig
it5ill i2tim 2itio 4itis i4tism i2t5o5m 4iton i4tram it5ry 4itt it3uat i5tud
it3ul 4itz. i1u 2iv iv3ell iv3en. i4v3er. i4vers. iv5il. iv5io iv1it i5vore
iv3o3ro i4v3ot 4i5w ix4o 4iy 4izar izi4 5izont 5ja jac4q ja4p 1je jer5s 4jestie
4jesty jew3 jo4p 5judg 3ka. k3ab k5ag kais4 kal4 k1b k2ed 1kee ke4g ke5li k3en4d
k1er kes4 k3est. ke4ty k3f kh4 k1i 5ki. 5k2ic k4ill kilo5 k4im k4in. kin4de
k5iness kin4g ki4p kis4 k5ish kk4 k1l 4kley 4kly k1m k5nes 1k2no ko5r kosh4 k3ou
kro5n 4k1s2 k4sc ks4l k4sy k5t k1w lab3ic l4abo laci4 l4ade la3dy lag4n lam3o
3land lan4dl lan5et lan4te lar4g lar3i las4e la5tan 4lateli 4lativ 4lav la4v4a
2l1b lbin4 4l1c2 lce4 l3ci 2ld l2de ld4ere ld4eri ldi4 ld5is l3dr l4dri le2a
le4bi left5 5leg. 5legg le4mat lem5atic 4len. 3lenc 5lene. 1lent le3ph le4pr
lera5b ler4e 3lerg 3l4eri l4ero les2 le5sco 5lesq 3less 5less. l3eva lev4er.
lev4era lev4ers 3ley 4leye 2lf l5fr 4l1g4 l5ga lgar3 l4ges lgo3 2l3h li4ag li2am
liar5iz li4as li4ato li5bi 5licio li4cor 4lics 4lict. l4icu l3icy l3ida lid5er
3lidi lif3er l4iff li4fl 5ligate 3ligh li4gra 3lik 4l4i4l lim4bl lim3i li4mo
l4im4p l4ina 1l4ine lin3ea lin3i link5er li5og 4l4iq lis4p l1it l2it. 5litica
l5i5tics liv3er l1iz 4lj lka3 l3kal lka4t l1l l4law l2le l5lea l3lec l3leg l3lel
l3le4n l3le4t ll2i l2lin4 l5lina ll4o lloqui5 ll5out l5low 2lm l5met lm3ing
l4mod lmon4 2l1n2 3lo. lob5al lo4ci 4lof 3logic l5ogo 3logu lom3er 5long lon4i
l3o3niz lood5 5lope. lop3i l3opm lora4 lo4rato lo5rie lor5ou 5los. los5et
5losophiz 5losophy los4t lo4ta loun5d 2lout 4lov 2lp lpa5b l3pha l5phi lp5ing
l3pit l4pl l5pr 4l1r 2l1s2 l4sc l2se l4sie 4lt lt5ag ltane5 l1te lten4 ltera4
lth3i l5ties. ltis4 l1tr ltu2 ltur3a lu5a lu3br luch4 lu3ci lu3en luf4 lu5id
lu4ma 5lumi l5umn. 5lumnia lu3o luo3r 4lup luss4 lus3te 1lut l5ven l5vet4 2l1w
1ly 4lya 4lyb ly5me ly3no 2lys4 l5yse 1ma 2mab ma2ca ma5chine ma4cl mag5in 5magn
2mah maid5 4mald ma3lig ma5lin mal4li mal4ty 5mania man5is man3iz 4map ma5rine.
ma5riz mar4ly mar3v ma5sce mas4e mas1t 5mate math3 ma3tis 4matiza 4m1b mba4t5
m5bil m4b3ing mbi4v 4m5c 4me. 2med 4med. 5media me3die m5e5dy me2g mel5on mel4t
me2m mem1o3 1men men4a men5ac men4de 4mene men4i mens4 mensu5 3ment men4te me5on
m5ersa 2mes 3mesti me4ta met3al me1te me5thi m4etr 5metric me5trie me3try me4v
4m1f 2mh 5mi. mi3a mid4a mid4g mig4 3milia m5i5lie m4ill min4a 3mind m5inee
m4ingl min5gli m5ingly min4t m4inu miot4 m2is mis4er. mis5l mis4ti m5istry 4mith
m2iz 4mk 4m1l m1m mma5ry 4m1n mn4a m4nin mn4o 1mo 4mocr 5mocratiz mo2d1 mo4go
mois2 moi5se 4mok mo5lest mo3me mon5et mon5ge moni3a mon4ism mon4ist mo3niz
monol4 mo3ny. mo2r 4mora. mos2 mo5sey mo3sp moth3 m5ouf 3mous mo2v 4m1p mpara5
mpa5rab mpar5i m3pet mphas4 m2pi mpi4a mp5ies m4p1in m5pir mp5is mpo3ri mpos5ite
m4pous mpov5 mp4tr m2py 4m3r 4m1s2 m4sh m5si 4mt 1mu mula5r4 5mult multi3 3mum
mun2 4mup mu4u 4mw 1na 2n1a2b n4abu 4nac. na4ca n5act nag5er. nak4 na4li na5lia
4nalt na5mit n2an nanci4 nan4it nank4 nar3c 4nare nar3i nar4l n5arm n4as nas4c
nas5ti n2at na3tal nato5miz n2au nau3se 3naut nav4e 4n1b4 ncar5 n4ces. n3cha
n5cheo n5chil n3chis nc1in nc4it ncour5a n1cr n1cu n4dai n5dan n1de nd5est.
ndi4b n5d2if n1dit n3diz n5duc ndu4r nd2we 2ne. n3ear ne2b neb3u ne2c 5neck 2ned
ne4gat neg5ativ 5nege ne4la nel5iz ne5mi ne4mo 1nen 4nene 3neo ne4po ne2q n1er
nera5b n4erar n2ere n4er5i ner4r 1nes 2nes. 4nesp 2nest 4nesw 3netic ne4v n5eve
ne4w n3f n4gab n3gel nge4n4e n5gere n3geri ng5ha n3gib ng1in n5git n4gla ngov4
ng5sh n1gu n4gum n2gy 4n1h4 nha4 nhab3 nhe4 3n4ia ni3an ni4ap ni3ba ni4bl ni4d
ni5di ni4er ni2fi ni5ficat n5igr nik4 n1im ni3miz n1in 5nine. nin4g ni4o 5nis.
nis4ta n2it n4ith 3nitio n3itor ni3tr n1j 4nk2 n5kero n3ket nk3in n1kl 4n1l n5m
nme4 nmet4 4n1n2 nne4 nni3al nni4v nob4l no3ble n5ocl 4n3o2d 3noe 4nog noge4
nois5i no5l4i 5nologis 3nomic n5o5miz no4mo no3my no4n non4ag non5i n5oniz 4nop
5nop5o5li nor5ab no4rary 4nosc nos4e nos5t no5ta 1nou 3noun nov3el3 nowl3 n1p4
npi4 npre4c n1q n1r nru4 2n1s2 ns5ab nsati4 ns4c n2se n4s3es nsid1 nsig4 n2sl
ns3m n4soc ns4pe n5spi nsta5bl n1t nta4b nter3s nt2i n5tib nti4er nti2f n3tine
n4t3ing nti4p ntrol5li nt4s ntu3me nu1a nu4d nu5en nuf4fe n3uin 3nu3it n4um
nu1me n5umi 3nu4n n3uo nu3tr n1v2 n1w4 nym4 nyp4 4nz n3za 4oa oad3 o5a5les oard3
oas4e oast5e oat5i ob3a3b o5bar obe4l o1bi o2bin ob5ing o3br ob3ul o1ce och4
o3chet ocif3 o4cil o4clam o4cod oc3rac oc5ratiz ocre3 5ocrit octor5a oc3ula
o5cure od5ded od3ic odi3o o2do4 odor3 od5uct. od5ucts o4el o5eng o3er oe4ta o3ev
o2fi of5ite ofit4t o2g5a5r og5ativ o4gato o1ge o5gene o5geo o4ger o3gie 1o1gis
og3it o4gl o5g2ly 3ogniz o4gro ogu5i 1ogy 2ogyn o1h2 ohab5 oi2 oic3es oi3der
oiff4 oig4 oi5let o3ing oint5er o5ism oi5son oist5en oi3ter o5j 2ok o3ken ok5ie
o1la o4lan olass4 ol2d old1e ol3er o3lesc o3let ol4fi ol2i o3lia o3lice ol5id.
o3li4f o5lil ol3ing o5lio o5lis. ol3ish o5lite o5litio o5liv olli4e ol5ogiz
olo4r ol5pl ol2t ol3ub ol3ume ol3un o5lus ol2v o2ly om5ah oma5l om5atiz om2be
om4bl o2me om3ena om5erse o4met om5etry o3mia om3ic. om3ica o5mid om1in o5mini
5ommend omo4ge o4mon om3pi ompro5 o2n on1a on4ac o3nan on1c 3oncil 2ond on5do
o3nen on5est on4gu on1ic o3nio on1is o5niu on3key on4odi on3omy on3s onspi4
onspir5a onsu4 onten4 on3t4i ontif5 on5um onva5 oo2 ood5e ood5i oo4k oop3i o3ord
oost5 o2pa ope5d op1er 3opera 4operag 2oph o5phan o5pher op3ing o3pit o5pon
o4posi o1pr op1u opy5 o1q o1ra o5ra. o4r3ag or5aliz or5ange ore5a o5real or3ei
ore5sh or5est. orew4 or4gu 4o5ria or3ica o5ril or1in o1rio or3ity o3riu or2mi
orn2e o5rof or3oug or5pe 3orrh or4se ors5en orst4 or3thi or3thy or4ty o5rum o1ry
os3al os2c os4ce o3scop 4oscopi o5scr os4i4e os5itiv os3ito os3ity osi4u os4l
o2so os4pa os4po os2ta o5stati os5til os5tit o4tan otele4g ot3er. ot5ers o4tes
4oth oth5esi oth3i4 ot3ic. ot5ica o3tice o3tif o3tis oto5s ou2 ou3bl ouch5i
ou5et ou4l ounc5er oun2d ou5v ov4en over4ne over3s ov4ert o3vis oviti4 o5v4ol
ow3der ow3el ow5est ow1i own5i o4wo oy1a 1pa pa4ca pa4ce pac4t p4ad 5pagan
p3agat p4ai pain4 p4al pan4a pan3el pan4ty pa3ny pa1p pa4pu para5bl par5age
par5di 3pare par5el p4a4ri par4is pa2te pa5ter 5pathic pa5thy pa4tric pav4 3pay
4p1b pd4 4pe. 3pe4a pear4l pe2c 2p2ed 3pede 3pedi pedia4 ped4ic p4ee pee4d pek4
pe4la peli4e pe4nan p4enc pen4th pe5on p4era. pera5bl p4erag p4eri peri5st
per4mal perme5 p4ern per3o per3ti pe5ru per1v pe2t pe5ten pe5tiz 4pf 4pg 4ph.
phar5i phe3no ph4er ph4es. ph1ic 5phie ph5ing 5phisti 3phiz ph2l 3phob 3phone
5phoni pho4r 4phs ph3t 5phu 1phy pi3a pian4 pi4cie pi4cy p4id p5ida pi3de 5pidi
3piec pi3en pi4grap pi3lo pi2n p4in. pind4 p4ino 3pi1o pion4 p3ith pi5tha pi2tu
2p3k2 1p2l2 3plan plas5t pli3a pli5er 4plig pli4n ploi4 plu4m plum4b 4p1m 2p3n
po4c 5pod. po5em po3et5 5po4g poin2 5point poly5t po4ni po4p 1p4or po4ry 1pos
pos1s p4ot po4ta 5poun 4p1p ppa5ra p2pe p4ped p5pel p3pen p3per p3pet ppo5site
pr2 pray4e 5preci pre5co pre3em pref5ac pre4la pre3r p3rese 3press pre5ten pre3v
5pri4e prin4t3 pri4s pris3o p3roca prof5it pro3l pros3e pro1t 2p1s2 p2se ps4h
p4sib 2p1t pt5a4b p2te p2th pti3m ptu4r p4tw pub3 pue4 puf4 pul3c pu4m pu2n
pur4r 5pus pu2t 5pute put3er pu3tr put4ted put4tin p3w qu2 qua5v 2que. 3quer
3quet 2rab ra3bi rach4e r5acl raf5fi raf4t r2ai ra4lo ram3et r2ami rane5o ran4ge
r4ani ra5no rap3er 3raphy rar5c rare4 rar5ef 4raril r2as ration4 rau4t ra5vai
rav3el ra5zie r1b r4bab r4bag rbi2 rbi4f r2bin r5bine rb5ing. rb4o r1c r2ce
rcen4 r3cha rch4er r4ci4b rc4it rcum3 r4dal rd2i rdi4a rdi4er rdin4 rd3ing 2re.
re1al re3an re5arr 5reav re4aw r5ebrat rec5oll rec5ompe re4cre 2r2ed re1de
re3dis red5it re4fac re2fe re5fer. re3fi re4fy reg3is re5it re1li re5lu r4en4ta
ren4te re1o re5pin re4posi re1pu r1er4 r4eri rero4 re5ru r4es. re4spi ress5ib
res2t re5stal re3str re4ter re4ti4z re3tri reu2 re5uti rev2 re4val rev3el
r5ev5er. re5vers re5vert re5vil rev5olu re4wh r1f rfu4 r4fy rg2 rg3er r3get
r3gic rgi4n rg3ing r5gis r5git r1gl rgo4n r3gu rh4 4rh. 4rhal ri3a ria4b ri4ag
r4ib rib3a ric5as r4ice 4rici 5ricid ri4cie r4ico rid5er ri3enc ri3ent ri1er
ri5et rig5an 5rigi ril3iz 5riman rim5i 3rimo rim4pe r2ina 5rina. rin4d rin4e
rin4g ri1o 5riph riph5e ri2pl rip5lic r4iq r2is r4is. ris4c r3ish ris4p ri3ta3b
r5ited. rit5er. rit5ers rit3ic ri2tu rit5ur riv5el riv3et riv3i r3j r3ket rk4le
rk4lin r1l rle4 r2led r4lig r4lis rl5ish r3lo4 r1m rma5c r2me r3men rm5ers
rm3ing r4ming. r4mio r3mit r4my r4nar r3nel r4ner r5net r3ney r5nic r1nis4 r3nit
r3niv rno4 r4nou r3nu rob3l r2oc ro3cr ro4e ro1fe ro5fil rok2 ro5ker 5role.
rom5ete rom4i rom4p ron4al ron4e ro5n4is ron4ta 1room 5root ro3pel rop3ic ror3i
ro5ro ros5per ros4s ro4the ro4ty ro4va rov5el rox5 r1p r4pea r5pent rp5er. r3pet
rp4h4 rp3ing r3po r1r4 rre4c rre4f r4reo rre4st rri4o rri4v rron4 rros4 rrys4
4rs2 r1sa rsa5ti rs4c r2se r3sec rse4cr rs5er. rs3es rse5v2 r1sh r5sha r1si
r4si4b rson3 r1sp r5sw rtach4 r4tag r3teb rten4d rte5o r1ti rt5ib rti4d r4tier
r3tig rtil3i rtil4l r4tily r4tist r4tiv r3tri rtroph4 rt4sh ru3a ru3e4l ru3en
ru4gl ru3in rum3pl ru2n runk5 run4ty r5usc ruti5n rv4e rvel4i r3ven rv5er.
r5vest r3vey r3vic rvi4v r3vo r1w ry4c 5rynge ry3t sa2 2s1ab 5sack sac3ri s3act
5sai salar4 sal4m sa5lo sal4t 3sanc san4de s1ap sa5ta 5sa3tio sat3u sau4 sa5vor
5saw 4s5b scan4t5 sca4p scav5 s4ced 4scei s4ces sch2 s4cho 3s4cie 5scin4d scle5
s4cli scof4 4scopy scour5a s1cu 4s5d 4se. se4a seas4 sea5w se2c3o 3sect 4s4ed
se4d4e s5edl se2g seg3r 5sei se1le 5self 5selv 4seme se4mol sen5at 4senc sen4d
s5ened sen5g s5enin 4sentd 4sentl sep3a3 4s1er. s4erl ser4o 4servo s1e4s se5sh
ses5t 5se5um 5sev sev3en sew4i 5sex 4s3f 2s3g s2h 2sh. sh1er 5shev sh1in sh3io
3ship shiv5 sho4 sh5old shon3 shor4 short5 4shw si1b s5icc 3side. 5sides 5sidi
si5diz 4signa sil4e 4sily 2s1in s2ina 5sine. s3ing 1sio 5sion sion5a si2r sir5a
1sis 3sitio 5siu 1siv 5siz sk2 4ske s3ket sk5ine sk5ing s1l2 s3lat s2le slith5
2s1m s3ma small3 sman3 smel4 s5men 5smith smol5d4 s1n4 1so so4ce soft3 so4lab
sol3d2 so3lic 5solv 3som 3s4on. sona4 son4g s4op 5sophic s5ophiz s5ophy sor5c
sor5d 4sov so5vi 2spa 5spai spa4n spen4d 2s5peo 2sper s2phe 3spher spho5 spil4
sp5ing 4spio s4ply s4pon spor4 4spot squal4l s1r 2ss s1sa ssas3 s2s5c s3sel
s5seng s4ses. s5set s1si s4sie ssi4er ss5ily s4sl ss4li s4sn sspend4 ss2t ssur5a
ss5w 2st. s2tag s2tal stam4i 5stand s4ta4p 5stat. s4ted stern5i s5tero ste2w
stew5a s3the st2i s4ti. s5tia s1tic 5stick s4tie s3tif st3ing 5stir s1tle 5stock
stom3a 5stone s4top 3store st4r s4trad 5stratu s4tray s4trid 4stry 4st3w s2ty
1su su1al su4b3 su2g3 su5is suit3 s4ul su2m sum3i su2n su2r 4sv sw2 4swo s4y
4syc 3syl syn5o sy5rin 1ta 3ta. 2tab ta5bles 5taboliz 4taci ta5do 4taf4 tai5lo
ta2l ta5la tal5en tal3i 4talk tal4lis ta5log ta5mo tan4de tanta3 ta5per ta5pl
tar4a 4tarc 4tare ta3riz tas4e ta5sy 4tatic ta4tur taun4 tav4 2taw tax4is 2t1b
4tc t4ch tch5et 4t1d 4te. tead4i 4teat tece4 5tect 2t1ed te5di 1tee teg4 te5ger
te5gi 3tel. teli4 5tels te2ma2 tem3at 3tenan 3tenc 3tend 4tenes 1tent ten4tag
1teo te4p te5pe ter3c 5ter3d 1teri ter5ies ter3is teri5za 5ternit ter5v 4tes.
4tess t3ess. teth5e 3teu 3tex 4tey 2t1f 4t1g 2th. than4 th2e 4thea th3eas the5at
the3is 3thet th5ic. th5ica 4thil 5think 4thl th5ode 5thodic 4thoo thor5it
tho5riz 2ths 1tia ti4ab ti4ato 2ti2b 4tick t4ico t4ic1u 5tidi 3tien tif2 ti5fy
2tig 5tigu till5in 1tim 4timp tim5ul 2t1in t2ina 3tine. 3tini 1tio ti5oc tion5ee
5tiq ti3sa 3tise tis4m ti5so tis4p 5tistica ti3tl ti4u 1tiv tiv4a 1tiz ti3za
ti3zen 2tl t5la tlan4 3tle. 3tled 3tles. t5let. t5lo 4t1m tme4 2t1n2 1to to3b
to5crat 4todo 2tof to2gr to5ic to2ma tom4b to3my ton4ali to3nat 4tono 4tony
to2ra to3rie tor5iz tos2 5tour 4tout to3war 4t1p 1tra tra3b tra5ch traci4
trac4it trac4te tras4 tra5ven trav5es5 tre5f tre4m trem5i 5tria tri5ces 5tricia
4trics 2trim tri4v tro5mi tron5i 4trony tro5phe tro3sp tro3v tru5i trus4 4t1s2
t4sc tsh4 t4sw 4t3t2 t4tes t5to ttu4 1tu tu1a tu3ar tu4bi tud2 4tue 4tuf4 5tu3i
3tum tu4nis 2t3up. 3ture 5turi tur3is tur5o tu5ry 3tus 4tv tw4 4t1wa twis4 4two
1ty 4tya 2tyl type3 ty5ph 4tz tz4e 4uab uac4 ua5na uan4i uar5ant uar2d uar3i
uar3t u1at uav4 ub4e u4bel u3ber u4bero u1b4i u4b5ing u3ble. u3ca uci4b uc4it
ucle3 u3cr u3cu u4cy ud5d ud3er ud5est udev4 u1dic ud3ied ud3ies ud5is u5dit
u4don ud4si u4du u4ene uens4 uen4te uer4il 3ufa u3fl ugh3en ug5in 2ui2 uil5iz
ui4n u1ing uir4m uita4 uiv3 uiv4er. u5j 4uk u1la ula5b u5lati ulch4 5ulche
ul3der ul4e u1len ul4gi ul2i u5lia ul3ing ul5ish ul4lar ul4li4b ul4lis 4ul3m
u1l4o 4uls uls5es ul1ti ultra3 4ultu u3lu ul5ul ul5v um5ab um4bi um4bly u1mi
u4m3ing umor5o um2p unat4 u2ne un4er u1ni un4im u2nin un5ish uni3v un3s4 un4sw
unt3ab un4ter. un4tes unu4 un5y un5z u4ors u5os u1ou u1pe uper5s u5pia up3ing
u3pl up3p upport5 upt5ib uptu4 u1ra 4ura. u4rag u4ras ur4be urc4 ur1d ure5at
ur4fer ur4fr u3rif uri4fic ur1in u3rio u1rit ur3iz ur2l url5ing. ur4no uros4
ur4pe ur4pi urs5er ur5tes ur3the urti4 ur4tie u3ru 2us u5sad u5san us4ap usc2
us3ci use5a u5sia u3sic us4lin us1p us5sl us5tere us1tr u2su usur4 uta4b u3tat
4ute. 4utel 4uten uten4i 4u1t2i uti5liz u3tine ut3ing ution5a u4tis 5u5tiz u4t1l
ut5of uto5g uto5matic u5ton u4tou uts4 u3u uu4m u1v2 uxu3 uz4e 1va 5va. 2v1a4b
vac5il vac3u vag4 va4ge va5lie val5o val1u va5mo va5niz va5pi var5ied 3vat 4ve.
4ved veg3 v3el. vel3li ve4lo v4ely ven3om v5enue v4erd 5vere. v4erel v3eren
ver5enc v4eres ver3ie vermi4n 3verse ver3th v4e2s 4ves. ves4te ve4te vet3er
ve4ty vi5ali 5vian 5vide. 5vided 4v3iden 5vides 5vidi v3if vi5gn vik4 2vil
5vilit v3i3liz v1in 4vi4na v2inc vin5d 4ving vio3l v3io4r vi1ou vi4p vi5ro
vis3it vi3so vi3su 4viti vit3r 4vity 3viv 5vo. voi4 3vok vo4la v5ole 5volt 3volv
vom5i vor5ab vori4 vo4ry vo4ta 4votee 4vv4 v4y w5abl 2wac wa5ger wag5o wait5
w5al. wam4 war4t was4t wa1te wa5ver w1b wea5rie weath3 wed4n weet3 wee5v wel4l
w1er west3 w3ev whi4 wi2 wil2 will5in win4de win4g wir4 3wise with3 wiz5 w4k
wl4es wl3in w4no 1wo2 wom1 wo5ven w5p wra4 wri4 writa4 w3sh ws4l ws4pe w5s4t 4wt
wy4 x1a xac5e x4ago xam3 x4ap xas5 x3c2 x1e xe4cuto x2ed xer4i xe5ro x1h xhi2
xhil5 xhu4 x3i xi5a xi5c xi5di x4ime xi5miz x3o x4ob x3p xpan4d xpecto5 xpe3d
x1t2 x3ti x1u xu3a xx4 y5ac 3yar4 y5at y1b y1c y2ce yc5er y3ch ych4e ycom4 ycot4
y1d y5ee y1er y4erf yes4 ye4t y5gi 4y3h y1i y3la ylla5bl y3lo y5lu ymbol5 yme4
ympa3 yn3chr yn5d yn5g yn5ic 5ynx y1o4 yo5d y4o5g yom4 yo5net y4ons y4os y4ped
yper5 yp3i y3po y4poc yp2ta y5pu yra5m yr5ia y3ro yr4r ys4c y3s2e ys3ica ys3io
3ysis y4so yss4 ys1t ys3ta ysur4 y3thin yt3ic y1w za1 z5a2b zar2 4zb 2ze ze4n
ze4p z1er ze3ro zet4 2z1i z4il z4is 5zl 4zm 1zo zo4m zo5ol zte4 4z1z2 z4zy
"""
# Extra patterns, from ushyphmax.tex, dated 2005-05-30.
# Copyright (C) 1990, 2004, 2005 Gerard D.C. Kuiken.
# Copying and distribution of this file, with or without modification,
# are permitted in any medium without royalty provided the copyright
# notice and this notice are preserved.
#
# These patterns are based on the Hyphenation Exception Log
# published in TUGboat, Volume 10 (1989), No. 3, pp. 337-341,
# and a large number of incorrectly hyphenated words not yet published.
"""
.con5gr .de5riva .dri5v4 .eth1y6l1 .eu4ler .ev2 .ever5si5b .ga4s1om1 .ge4ome
.ge5ot1 .he3mo1 .he3p6a .he3roe .in5u2t .kil2n3i .ko6r1te1 .le6ices .me4ga1l
.met4ala .mim5i2c1 .mi1s4ers .ne6o3f .noe1th .non1e2m .poly1s .post1am .pre1am
.rav5en1o .semi5 .sem4ic .semid6 .semip4 .semir4 .sem6is4 .semiv4 .sph6in1
.spin1o .ta5pes1tr .te3legr .to6pog .to2q .un3at5t .un5err5 .vi2c3ar .we2b1l
.re1e4c a5bolic a2cabl af6fish am1en3ta5b anal6ys ano5a2c ans5gr ans3v anti1d
an3ti1n2 anti1re a4pe5able ar3che5t ar2range as5ymptot ath3er1o1s at6tes.
augh4tl au5li5f av3iou back2er. ba6r1onie ba1thy bbi4t be2vie bi5d2if bil2lab
bio5m bi1orb bio1rh b1i3tive blan2d1 blin2d1 blon2d2 bor1no5 bo2t1u1l brus4q
bus6i2er bus6i2es buss4ing but2ed. but4ted cad5e1m cat1a1s2 4chs. chs3hu chie5vo
cig3a3r cin2q cle4ar co6ph1o3n cous2ti cri3tie croc1o1d cro5e2co c2tro3me6c
1cu2r1ance 2d3alone data1b dd5a5b d2d5ib de4als. de5clar1 de2c5lina de3fin3iti
de2mos des3ic de2tic dic1aid dif5fra 3di1methy di2ren di2rer 2d1lead 2d1li2e
3do5word dren1a5l drif2t1a d1ri3pleg5 drom3e5d d3tab du2al. du1op1o1l ea4n3ies
e3chas edg1l ed1uling eli2t1is e1loa en1dix eo3grap 1e6p3i3neph1 e2r3i4an.
e3spac6i eth1y6l1ene 5eu2clid1 feb1rua fermi1o 3fich fit5ted. fla1g6el flow2er.
3fluor gen2cy. ge3o1d ght1we g1lead get2ic. 4g1lish 5glo5bin 1g2nac gnet1ism
gno5mo g2n1or. g2noresp 2g1o4n3i1za graph5er. griev1 g1utan hair1s ha2p3ar5r
hatch1 hex2a3 hite3sid h3i5pel1a4 hnau3z ho6r1ic. h2t1eou hypo1tha id4ios
ifac1et ign4it ignit1er i4jk im3ped3a infra1s2 i5nitely. irre6v3oc i1tesima
ith5i2l itin5er5ar janu3a japan1e2s je1re1m 1ke6ling 1ki5netic 1kovian k3sha
la4c3i5e lai6n3ess lar5ce1n l3chai l3chil6d1 lead6er. lea4s1a 1lec3ta6b
le3g6en2dre 1le1noid lith1o5g ll1fl l2l3ish l5mo3nell lo1bot1o1 lo2ges. load4ed.
load6er. l3tea lth5i2ly lue1p 1lunk3er 1lum5bia. 3lyg1a1mi ly5styr ma1la1p m2an.
man3u1sc mar1gin1 medi2c med3i3cin medio6c1 me3gran3 m2en. 3mi3da5b 3milita
mil2l1ag mil5li5li mi6n3is. mi1n2ut1er mi1n2ut1est m3ma1b 5maph1ro1 5moc1ra1t
mo5e2las mol1e5c mon4ey1l mono3ch mo4no1en moro6n5is mono1s6 moth4et2 m1ou3sin
m5shack2 mu2dro mul2ti5u n3ar4chs. n3ch2es1t ne3back 2ne1ski n1dieck nd3thr
nfi6n3ites 4n5i4an. nge5nes ng1ho ng1spr nk3rup n5less 5noc3er1os nom1a6l
nom5e1no n1o1mist non1eq non1i4so 5nop1oly. no1vemb ns5ceiv ns4moo ntre1p
obli2g1 o3chas odel3li odit1ic oerst2 oke1st o3les3ter oli3gop1o1 o1lo3n4om
o3mecha6 onom1ic o3norma o3no2t1o3n o3nou op1ism. or4tho3ni4t orth1ri or5tively
o4s3pher o5test1er o5tes3tor oth3e1o1s ou3ba3do o6v3i4an. oxi6d1ic pal6mat
parag6ra4 par4a1le param4 para3me pee2v1 phi2l3ant phi5lat1e3l pi2c1a3d pli2c1ab
pli5nar poin3ca 1pole. poly1e po3lyph1ono 1prema3c pre1neu pres2pli pro2cess
proc3i3ty. pro2g1e 3pseu2d pseu3d6o3d2 pseu3d6o3f2 pto3mat4 p5trol3 pu5bes5c
quain2t1e qu6a3si3 quasir6 quasis6 quin5tes5s qui3v4ar r1abolic 3rab1o1loi
ra3chu r3a3dig radi1o6g r2amen 3ra4m5e1triz ra3mou ra5n2has ra1or r3bin1ge
re2c3i1pr rec5t6ang re4t1ribu r3ial. riv1o1l 6rk. rk1ho r1krau 6rks. r5le5qu
ro1bot1 ro5e2las ro5epide1 ro3mesh ro1tron r3pau5li rse1rad1i r1thou r1treu
r1veil rz1sc sales3c sales5w 5sa3par5il sca6p1er sca2t1ol s4chitz schro1ding1
1sci2utt scrap4er. scy4th1 sem1a1ph se3mes1t se1mi6t5ic sep3temb shoe1st sid2ed.
side5st side5sw si5resid sky1sc 3slova1kia 3s2og1a1my so2lute 3s2pace 1s2pacin
spe3cio spher1o spi2c1il spokes5w sports3c sports3w s3qui3to s2s1a3chu1 ss3hat
s2s3i4an. s5sign5a3b 1s2tamp s2t1ant5shi star3tli sta1ti st5b 1stor1ab strat1a1g
strib5ut st5scr stu1pi4d1 styl1is su2per1e6 1sync 1syth3i2 swimm6 5tab1o1lism
ta3gon. talk1a5 t1a1min t6ap6ath 5tar2rh tch1c tch3i1er t1cr teach4er. tele2g
tele1r6o 3ter1gei ter2ic. t3ess2es tha4l1am tho3don th1o5gen1i tho1k2er thy4l1an
thy3sc 2t3i4an. ti2n3o1m t1li2er tolo2gy tot3ic trai3tor1 tra1vers travers3a3b
treach1e tr4ial. 3tro1le1um trof4ic. tro3fit tro1p2is 3trop1o5les 3trop1o5lis
t1ro1pol3it tsch3ie ttrib1ut1 turn3ar t1wh ty2p5al ua3drati uad1ratu u5do3ny
uea1m u2r1al. uri4al. us2er. v1ativ v1oir5du1 va6guer vaude3v 1verely. v1er1eig
ves1tite vi1vip3a3r voice1p waste3w6a2 wave1g4 w3c week1n wide5sp wo4k1en
wrap3aro writ6er. x1q xquis3 y5che3d ym5e5try y1stro yes5ter1y z3ian. z3o1phr
z2z3w
""")

exceptions = """
as-so-ciate as-so-ciates dec-li-na-tion oblig-a-tory phil-an-thropic present
presents project projects reci-procity re-cog-ni-zance ref-or-ma-tion
ret-ri-bu-tion ta-ble
"""

hyphenator = Hyphenator(patterns, exceptions)
hyphenate_word = hyphenator.hyphenate_word

del patterns
del exceptions

if __name__ == '__main__':
    import sys
    if len(sys.argv) &gt; 1:
        for word in sys.argv[1:]:
            print '-'.join(hyphenate_word(word))
    else:
        import doctest
        doctest.testmod(verbose=True)

</t>
<t tx="karstenw.20170725110922.3">def __init__(self, patterns, exceptions=''):
    self.tree = {}
    for pattern in patterns.split():
        self._insert_pattern(pattern)

    self.exceptions = {}
    for ex in exceptions.split():
        # Convert the hyphenated pattern into a point array for use later.
        self.exceptions[ex.replace('-', '')] = [0] + [ int(h == '-') for h in re.split(r"[a-z]", ex) ]

</t>
<t tx="karstenw.20170725110922.4">def _insert_pattern(self, pattern):
    # Convert the a pattern like 'a1bc3d4' into a string of chars 'abcd'
    # and a list of points [ 1, 0, 3, 4 ].
    chars = re.sub('[0-9]', '', pattern)
    points = [ int(d or 0) for d in re.split("[.a-z]", pattern) ]

    # Insert the pattern into the tree.  Each character finds a dict
    # another level down in the tree, and leaf nodes have the list of
    # points.
    t = self.tree
    for c in chars:
        if c not in t:
            t[c] = {}
        t = t[c]
    t[None] = points

</t>
<t tx="karstenw.20170725110922.5">def hyphenate_word(self, word):
    """ Given a word, returns a list of pieces, broken at the possible
        hyphenation points.
    """
    # Short words aren't hyphenated.
    if len(word) &lt;= 4:
        return [word]
    # If the word is an exception, get the stored points.
    if word.lower() in self.exceptions:
        points = self.exceptions[word.lower()]
    else:
        work = '.' + word.lower() + '.'
        points = [0] * (len(work)+1)
        for i in range(len(work)):
            t = self.tree
            for c in work[i:]:
                if c in t:
                    t = t[c]
                    if None in t:
                        p = t[None]
                        for j in range(len(p)):
                            points[i+j] = max(points[i+j], p[j])
                else:
                    break
        # No hyphens in the first two chars or the last two.
        points[1] = points[2] = points[-2] = points[-3] = 0

    # Examine the points to build the pieces list.
    pieces = ['']
    for c, p in zip(word, points[2:]):
        pieces[-1] += c
        if p % 2:
            pieces.append('')
    return pieces

</t>
<t tx="karstenw.20170725110924.1">import math, os, sys

from twyg.config import Properties, NumberProperty, BooleanProperty

from twyg.tree import Direction, opposite_dir
from twyg.geomutils import halfcircle


</t>
<t tx="karstenw.20170725110924.10">def _getchildren(self, node, direction):
    if node.isroot():
        return (self._leftnodes if direction == Direction.Left
                else self._rightnodes)
    return node.children

</t>
<t tx="karstenw.20170725110924.11">def _calc_child_maxwidth(self, node, direction):
    for child in self._getchildren(node, direction):
        self._calc_child_maxwidth(child, direction)

    p = node.parent
    if not p:
        return
    if not hasattr(p, 'child_bboxwidth_max'):
        p.child_bboxwidth_max = node.bboxwidth
    else:
        p.child_bboxwidth_max = max(p.child_bboxwidth_max, node.bboxwidth)

</t>
<t tx="karstenw.20170725110924.12">def _calc_x(self, node, direction, x):
    E = self._eval_func(node, direction)

    children = self._getchildren(node, direction)

    xpad = E('rootPadX') if node.isroot() else E('nodePadX')

    if E('sameWidthSiblings'):
        if not node.isroot() and not node.isleaf():
            maxwidth = node.parent.child_bboxwidth_max
        else:
            maxwidth = node.bboxwidth
    else:
        maxwidth = node.bboxwidth

    xoffs = 0
    if not node.isroot():
        siblings = self._getchildren(node.parent, direction)
        if len(siblings) &gt;= E('radialMinNodes'):
            _dir = -1 if direction == Direction.Left else 1
            xoffs = halfcircle(0, siblings[0].y, siblings[-1].y,
                               E('radialFactor'), _dir, node.y)

    if direction == Direction.Left:
        width = node.bboxwidth
        x += xoffs - width
        node.x = x
        x -= xpad + maxwidth - width
    else:
        x += xoffs
        node.x = x
        x += maxwidth + xpad

    for child in children:
        self._calc_x(child, direction, x)

</t>
<t tx="karstenw.20170725110924.13">def _calc_y(self, node, direction):
    E = self._eval_func(node)

    # Initialise branch bounding box
    node._branch_bboxtop = node.y
    node._branch_bboxbottom = node.y + node.bboxheight

    node_pady = E('nodePadY')

    if node.isleaf():
        # Set the position of a leaf node node a calculate the y
        # position for the next leaf. Because of the way we traverse
        # the tree, all leaf nodes are positioned consecutively on
        # the y axis, separated by the node and branch paddings.
        node.y = self._leaf_y
        self._leaf_y += node.bboxheight + node_pady
        self._branch_pad = False
    else:
        # Depth-first traversal: we are going to calculate the
        # layout starting from the leaf nodes, progressing upwards
        # in the tree, and from top to bottom (from lower to higher
        # y coordinates) in terms of vertical positioning
        children = self._getchildren(node, direction)
        if not children:
            return

        branch_pad_y = E('branchPadY')

        if not self._branch_pad:
            self._leaf_y += branch_pad_y - node_pady
            self._branch_pad = True

        for child in children:
            self._calc_y(child, direction)

        if not self._branch_pad:
            self._leaf_y += branch_pad_y - node_pady
            self._branch_pad = True

        # At this point the whole subtree under 'node' has been
        # positioned correctly. The only remainig thing is to
        # calculate the y position of 'node' (the parent).
        node_dir = direction
        child_dir = opposite_dir(node_dir)

        # Calculate the y coord of the connection point for the
        # children
        firstchild = children[0]
        lastchild = children[-1]

        child_conn_ytop = firstchild.connection_point(child_dir)[1]
        child_conn_ybottom = lastchild.connection_point(child_dir)[1]

        # The actual connection point will be in between 
        child_conn_y = (child_conn_ytop
                       + (child_conn_ybottom - child_conn_ytop)
                       * E('verticalAlignFactor'))

        # Snap parent connection position to children connection
        # positions vertically
        if E('snapParentToChildren'):
            children_conn_y = [c.connection_point(child_dir)[1]
                               for c in children]

            # Enable snapping to half-positions 50% inbetween two
            # child connections
            if E('snapToHalfPositions'):
                l = []
                for i in range(len(children_conn_y) - 1):
                    y1 = children_conn_y[i]
                    y2 = children_conn_y[i + 1]
                    l.append(y1)
                    l.append((y1 + y2) / 2.)

                l.append(children_conn_y[-1])
                children_conn_y = l

            # Get closest connection point index
            d = [abs(child_conn_y - y) for y in children_conn_y]
            closest = d.index(min(d))

            child_conn_y = children_conn_y[closest]

        # Calculate the y offset of the parent node in relation to
        # it's connection point
        node_conn_y = node.connection_point(node_dir)[1]
        node_yoffs = node_conn_y - node.y

        # Calculate the top and bottom y coords of the parent
        node_ytop = child_conn_y - node_yoffs
        node_ybottom = child_conn_y + (node.bboxheight - node_yoffs)

        # Set the position of the parent node
        node.y = node_ytop

        # Calculate the top and bottom y coords of the children
        children_ytop = firstchild.y
        children_ybottom = lastchild.y + lastchild.bboxheight

        # If the parent extends above the topmost child node, shift
        # the whole branch downwards by the same amount 
        dy_top = children_ytop - node_ytop

        if dy_top &gt; 0:
            if node.isroot():
                node.y += dy_top
                for n in self._getchildren(node, direction):
                    n.shiftbranch(0, dy_top)
            else:
                node.shiftbranch(0, dy_top)
        else:
            dy_top = 0

        # If the parent extends below the bottommost child node,
        # offset the y start the next leaf node by the same amount
        if node_ybottom &gt; children_ybottom:
            y = node_ybottom + branch_pad_y
            if y &gt; self._leaf_y:
                self._leaf_y = y

        # Adjust y coordinates if the branch has been shifted
        # downwards
        self._leaf_y += dy_top

        node_ytop += dy_top
        node_ybottom += dy_top
        children_bboxtop = firstchild._branch_bboxtop + dy_top
        children_bboxbottom = lastchild._branch_bboxbottom + dy_top

        # Calculate the bounding box of the branch
        node._branch_bboxtop = min(children_bboxtop, node_ytop)
        node._branch_bboxbottom = max(children_bboxbottom, node_ybottom)

</t>
<t tx="karstenw.20170725110924.14">def childrenheight(self, node, direction):
    # direction is None for leaf nodes
    if direction == None:
        return 0

    children = self._getchildren(node, direction)
    if not children or node.isleaf():
        return 0

    firstchild = children[0]
    lastchild = children[-1]

    child_dir = opposite_dir(direction)
    child_conn_ytop = firstchild.connection_point(child_dir)[1]
    child_conn_ybottom = lastchild.connection_point(child_dir)[1]

    return child_conn_ybottom - child_conn_ytop


</t>
<t tx="karstenw.20170725110924.15">def layout_by_name(name):
    if name in _layout_map:
        return _layout_map[name]
    else:
        raise ValueError, 'Unrecognized layout name: %s' % name

</t>
<t tx="karstenw.20170725110924.2">class Layout(object):

    @others
_layout_map = {
    'layout': Layout
}


</t>
<t tx="karstenw.20170725110924.3">def __init__(self, config):
    properties = {
        'horizontalBalance':       (NumberProperty,  {}),
        'verticalAlignFactor':     (NumberProperty,  {'min': 0.0,
                                                      'max': 1.0}),
        'rootPadX':                (NumberProperty,  {}),
        'nodePadX':                (NumberProperty,  {}),
        'nodePadY':                (NumberProperty,  {}),
        'branchPadY':              (NumberProperty,  {}),
        'sameWidthSiblings':       (BooleanProperty, {}),
        'snapParentToChildren':    (BooleanProperty, {}),
        'snapToHalfPositions':     (BooleanProperty, {}),
        'radialMinNodes':          (NumberProperty,  {'min': 0.0}),
        'radialFactor':            (NumberProperty,  {})
    }

    self._props = Properties(properties, self._defaults_path('layout'),
                             config)

    self._leftnodes = ()
    self._rightnodes = ()

# TODO util function in common?
</t>
<t tx="karstenw.20170725110924.4">def _defaults_path(self, conf):
    return os.path.join('layout', conf)

</t>
<t tx="karstenw.20170725110924.5">def _eval_func(self, node=None, direction=None):
    if node:
        vars = {
            'childrenHeight': self.childrenheight(node, direction)
        }
    else:
        vars = {}
    return lambda name: self._props.eval(name, node, vars)

</t>
<t tx="karstenw.20170725110924.6">def precalc_layout(self, root):
    self.root = root
    self._splitnodes()

</t>
<t tx="karstenw.20170725110924.7">def node_orientation(self, node):
    if node.isroot():
        return None
    elif node.ancestor(-1) in self._leftnodes:
        return Direction.Left
    elif node.ancestor(-1) in self._rightnodes:
        return Direction.Right

</t>
<t tx="karstenw.20170725110924.8">def _splitnodes(self):
    """
    Split the first level nodes into left and right directed nodes.
    """

    E = self._eval_func()

    children = self.root.children
    n = int((len(children) + 1) * E('horizontalBalance'))

    self._leftnodes = children[:n]
    self._rightnodes = children[n:]

</t>
<t tx="karstenw.20170725110924.9">def calclayout(self, root):
    self.root = root

    # Vertical layout
    self._leaf_y = 0
    self._branch_pad = False
    self._calc_y(self.root, Direction.Left)

    oy = self.root.y

    self._leaf_y = 0
    self._branch_pad = False
    self._calc_y(self.root, Direction.Right)

    dy = oy - self.root.y

    # Align right side to the left
    self.root.y += dy
    for node in self._rightnodes:
        node.shiftbranch(0, dy)

    # Horizontal layout
    self._calc_child_maxwidth(self.root, Direction.Left)
    self._calc_child_maxwidth(self.root, Direction.Right)
    self._calc_x(self.root, Direction.Left, 0)
    self._calc_x(self.root, Direction.Right, self.root.x)

</t>
<t tx="karstenw.20170725110927.1">import math, os

from twyg.common import textwidth, createpath, brightness
from twyg.config import (Properties, StringProperty, NumberProperty,
                         ColorProperty, EnumProperty, BooleanProperty,
                         ArrayProperty)

from twyg.geom import Vector2
import twyg.geomutils as geom
import twyg.textwrap as textwrap
from twyg.tree import Direction


LEFT = 'left'
RIGHT = 'right'
CENTER = 'center'
JUSTIFY = 'justify'

DEBUG = False


</t>
<t tx="karstenw.20170725110927.10">def _precalc_text(self, node):
    E = self._eval_func(node)
    node.fontname       = E('fontName')
    node.lineheight     = E('lineHeight')
    node.max_text_width = E('maxTextWidth')
    node.hyphenate      = E('hyphenate')

    _ctx.font(node.fontname, node.fontsize)
    _ctx.lineheight(node.lineheight)

    lineheight = node.lineheight * node.fontsize
    textwidth_func = lambda(txt): textwidth(_ctx, txt,
                                            node.fontname, node.fontsize)

    if self._wraprect:
        (node._textlines, node._textlinewidths, node._textrects,
         node.textwidth,
         node.textheight) = textwrap.wrap_rect(node.label, lineheight,
                                               textwidth_func,
                                               node.max_text_width)
    else:
        (node._textlines, node._textlinewidths, node._textrects,
         node.textwidth,
         node.textheight) = textwrap.wrap_shape(node.label, lineheight,
                                                textwidth_func,
                                                self._shapefunc,
                                                hyphenate=node.hyphenate,
                                                **self._shapefunc_args)

</t>
<t tx="karstenw.20170725110927.11">def _calc_shape_path(self, node):
    raise NotImplementedError

</t>
<t tx="karstenw.20170725110927.12">def _drawtext(self, node, xoffs, yoffs):
    E = self._eval_func(node)

    if not node._textrects:
        return

    # Text alignment
    alignment = LEFT
    text_align = E('textAlign')
    if   text_align == 'right':   alignment = RIGHT
    elif text_align == 'center':  alignment = CENTER
    elif text_align == 'justify': alignment = JUSTIFY
    elif text_align == 'auto':
        if node.isroot():
            alignment = CENTER
        else:
            alignment = (RIGHT if node.direction() == Direction.Left
                         else LEFT)

    # Draw text
    baseline_corr = E('textBaselineCorrection')

    _ctx.font(node.fontname, node.fontsize)
    _ctx.lineheight(node.lineheight)

    justify_min_lines = E('justifyMinLines')
    ystep = node._textrects[0].h

    nonblank_lines = 0
    for l in node._textlines:
        if l:
            nonblank_lines += 1

    if nonblank_lines &lt;= justify_min_lines:
        self._center_text_vertically(node)

    baseline_offs = node.fontsize * baseline_corr
    lineheight_offs = -(node.lineheight - 1) / 2 * node.fontsize

    if alignment == JUSTIFY and nonblank_lines &lt;= justify_min_lines:
        alignment = CENTER

    if alignment == JUSTIFY:
        spacewidth = textwidth(_ctx, ' ', node.fontname, node.fontsize)

        for i, l in enumerate(node._textlines):
            x, y, w, h = node._textrects[i].params()
            x += xoffs
            y += yoffs + baseline_offs + lineheight_offs + ystep

            if DEBUG:
                _ctx.save()
                _ctx.nofill()
                _ctx.stroke(node.fontcolor)
                _ctx.rect(x, y - h, w, h)
                _ctx.stroke(1, 0, 0)
                _ctx.rect(tx, ty, node.textwidth, node.textheight)
                _ctx.restore()

            words = l.split()
            numspaces = float(l.count(' '))
            x_spacing = spacewidth
            if numspaces:
                charswidth = (node._textlinewidths[i]
                              - numspaces * spacewidth)
                x_spacing = (w - charswidth) / numspaces

            # TODO remove 7 magic constant
            if ((i == 0 or i == len(node._textlines) - 1)
                and (x_spacing &gt; spacewidth * 7 or len(words) == 1)):

                x_spacing = spacewidth
                x += (w - node._textlinewidths[i]) / 2.

            for w in words:
                _ctx.text(w, x, y)
                x += x_spacing + textwidth(_ctx, w,
                                           node.fontname, node.fontsize)
    else:
        for i, l in enumerate(node._textlines):
            x, y, w, h = node._textrects[i].params()
            x += xoffs
            y += yoffs + ystep

            if DEBUG:
                _ctx.save()
                _ctx.nofill()
                _ctx.stroke(node.fontcolor)
                _ctx.rect(x, y - h, w, h)
                _ctx.stroke(1, 0, 0)
                _ctx.rect(tx, ty, node.textwidth, node.textheight)
                _ctx.restore()

            y += baseline_offs + lineheight_offs

            if alignment == RIGHT:
                x += w - node._textlinewidths[i]
            elif alignment == CENTER:
                x += (w - node._textlinewidths[i]) / 2.

            _ctx.text(l, x, y)

</t>
<t tx="karstenw.20170725110927.13">def _center_text_vertically(self, node):
    """
    Shift rects so that the text will appear vertically centered
    within a containing rectangle of the specified height, taking blank
    lines into account as well.

    lines    -- list of strings containing the text in each line
    rects    -- list of equi-height rectangles in [x, y, w, h] format
    height   -- height of the containing rectangle
    """

    if not node._textrects:
        return

    preblanks = 0
    for l in node._textlines:
        if not l:
            preblanks += 1
        else:
            break

    postblanks = 0
    for l in reversed(node._textlines):
        if not l:
            postblanks += 1
        else:
            break

    lineheight = node._textrects[0].h

    numnonblanks = len(node._textlines) - preblanks - postblanks
    textheight = numnonblanks * lineheight
    ystart = (node.textheight - textheight) / 2.
    ystart -= preblanks * lineheight

    yoffs = ystart - node._textrects[0].y

    for r in node._textrects:
        r.y += yoffs


</t>
<t tx="karstenw.20170725110927.14">class RectNodeDrawer(NodeDrawer):

    @others
</t>
<t tx="karstenw.20170725110927.15">def __init__(self, config={}):
    properties = {
        'roundness':     (NumberProperty, {'min': 0.0, 'max': 1.0}),
        'cornerRadius':  (NumberProperty, {'min': 0.0}),
        'roundingStyle': (EnumProperty,   {'values': ('screen', 'arc')})
    }

    super(RectNodeDrawer, self).__init__(properties, 'rect', config)

</t>
<t tx="karstenw.20170725110927.16">def _calc_shape_path(self, node):
    E = self._eval_func(node)

    style = E('roundingStyle')

    if style == 'screen':
        r =  E('roundness')
        r = min(max(0, r / 2.), 1)

        return _ctx.rect(0, 0, node.width, node.height,
                         roundness=r, draw=False)

    elif style == 'arc':
        r = E('cornerRadius')
        r = min(r, node.height / 2.)
        r = min(r, node.width / 2.)

        points = geom.rounded_rect(0, 0, node.width, node.height, r)
        return createpath(_ctx, points, close=False)


</t>
<t tx="karstenw.20170725110927.17">class BoxNodeDrawer(NodeDrawer):

    @others
</t>
<t tx="karstenw.20170725110927.18">def __init__(self, config={}):
    orientation = ('topleft', 'topright', 'bottomleft', 'bottomright')

    properties = {
        'boxOrientation':      (EnumProperty,   {'values': orientation}),
        'boxDepth':            (NumberProperty, {'min': 0.0}),
        'horizSideColor':      (ColorProperty,  {}),
        'vertSideColor':       (ColorProperty,  {}),
        'strokeColor':         (ColorProperty,  {})
    }

    super(BoxNodeDrawer, self).__init__(properties, 'box', config)

    # Determine 3D depth orientation
    E = self._eval_func(None)

    orientation = E('boxOrientation')
    self._horiz_dir = 0
    self._vert_dir = 0

    if orientation.find('top') &gt; -1:
        self._vert_dir = 1
    elif orientation.find('bottom') &gt; -1:
        self._vert_dir = -1

    if orientation.find('left') &gt; -1:
        self._horiz_dir = -1
    elif orientation.find('right') &gt; -1:
        self._horiz_dir = 1

    if self._horiz_dir == 0:
        self._horiz_dir = 1

    if self._vert_dir == 0:
        self._vert_dir = 1

</t>
<t tx="karstenw.20170725110927.19">def precalc_node(self, node):
    super(BoxNodeDrawer, self).precalc_node(node)

    E = self._eval_func(node)

    node._boxdepth = E('boxDepth')

    # Make the bounding box big enough so that the shadow can fit in
    # too -- the actual coordinate calculations will happen later
    node.bboxwidth += node._boxdepth
    node.bboxheight += node._boxdepth

    y = node.bboxheight / 2
    node._conn_point_left = Vector2(0, y)
    node._conn_point_right = Vector2(node.bboxwidth, y)

</t>
<t tx="karstenw.20170725110927.2">class NodeDrawer(object):

    @others
</t>
<t tx="karstenw.20170725110927.20">def draw(self, node):
    """
    Draw the node at its (x,y) anchor point.

    Relies on internal properties precalculated by precalc_node.
    """

    E = self._eval_func(node)
    strokewidth = E('strokeWidth')
    drawstroke = strokewidth &gt; 0

    d = node._boxdepth

    _ctx.push()
    _ctx.translate(node.x, node.y)

    if drawstroke:
        # Set up clip path
        cx1 = cx6 = 0
        cy2 = 0
        cx3 = cx4 = cx1 + node.width + d
        cy5 = cy2 + node.height + d

        if self._vert_dir == self._horiz_dir:
            cy1 = d
            cx2 = d
            cy3 = 0
            cy4 = cy3 + node.height
            cx5 = node.width
            cy6 = cy4 + d

        elif self._vert_dir != self._horiz_dir:
            cy1 = 0
            cx2 = node.width
            cy3 = d
            cy4 = cy3 + node.height
            cx5 = d
            cy6 = cy4 - d

        outline = [
            Vector2(cx1, cy1),
            Vector2(cx2, cy2),
            Vector2(cx3, cy3),
            Vector2(cx4, cy4),
            Vector2(cx5, cy5),
            Vector2(cx6, cy6)
        ]

        offs = geom.offset_poly(outline, strokewidth * .5)
        clippath = createpath(_ctx, offs)

        _ctx.beginclip(clippath)

    # Box drawing stuff
    if drawstroke:
        _ctx.stroke(E('strokeColor'))
        _ctx.strokewidth(strokewidth)
    else:
        _ctx.nostroke()

    if self._vert_dir == 1:
        y1 = d
        y2 = y1 - d
        dv = -d
        oy = y1
    else:
        y1 = node.height
        y2 = y1 + d
        dv = d
        oy = 0

    if self._horiz_dir == 1:
        x1 = node.width
        x2 = x1 + d
        dh = d
        ox = 0
    else:
        x1 = d
        x2 = x1 - d
        dh = -d
        ox = x1

    # Draw box
    path = _ctx.rect(ox, oy, node.width, node.height, draw=False)
    self._draw_gradient_shape(node, path, node.fillcolor)

    # Draw horizontal 3D side
    _ctx.beginpath(ox, y1)
    _ctx.lineto(ox + node.width, y1)
    _ctx.lineto(ox + node.width + dh, y2)
    _ctx.lineto(ox + dh, y2)
    _ctx.lineto(ox, y1)

    path = _ctx.endpath(draw=False)
    col = E('horizSideColor')
    self._draw_gradient_shape(node, path, col)

    # Draw vertical 3D side
    _ctx.beginpath(x1, oy)
    _ctx.lineto(x1, oy + node.height)
    _ctx.lineto(x2, oy + node.height + dv)
    _ctx.lineto(x2, oy + dv)
    _ctx.lineto(x1, oy)

    path = _ctx.endpath(draw=False)
    col = E('vertSideColor')
    self._draw_gradient_shape(node, path, col)

    tx = node._textxoffs + ox
    ty = node._textyoffs + oy

    _ctx.fill(node.fontcolor)
    self._drawtext(node, tx, ty)

    if drawstroke:
        _ctx.endclip()

    _ctx.pop()


</t>
<t tx="karstenw.20170725110927.21">class LineNodeDrawer(NodeDrawer):

    @others
</t>
<t tx="karstenw.20170725110927.22">def __init__(self, config={}):
    properties = {
        'maxTextWidth': (NumberProperty, {'min': 0.0})
    }

    super(LineNodeDrawer, self).__init__(properties, 'line', config)

</t>
<t tx="karstenw.20170725110927.23">def precalc_node(self, node):
    """
    Precalculate node properties that are needed by the layout and
    colorizer algorithms.
    """
    super(LineNodeDrawer, self).precalc_node(node)

    node.text_has_background = False

    y = node.height
    node._conn_point_left = Vector2(0, y)
    node._conn_point_right = Vector2(node.width, y)

</t>
<t tx="karstenw.20170725110927.24">def draw(self, node):
    E = self._eval_func(node)

    _ctx.push()
    _ctx.translate(node.x, node.y)

    y = node.height

    _ctx.stroke(node.strokecolor)
    _ctx.strokewidth(E('strokeWidth'))
    _ctx.line(0, y, node.width, y)

    _ctx.fill(node.fontcolor)
    self._drawtext(node, node._textxoffs, node._textyoffs)

    _ctx.pop()


</t>
<t tx="karstenw.20170725110927.25">class PolyNodeDrawer(NodeDrawer):

    @others
</t>
<t tx="karstenw.20170725110927.26">def __init__(self, config={}):
    properties = {
        'numSides': (NumberProperty, {'min': 0}),
        'rotation': (NumberProperty, {})
    }

    super(PolyNodeDrawer, self).__init__(properties, 'poly', config)

    E = self._eval_func(None)

    self._wraprect = False
    self._shapefunc = geom.calc_regular_polygon_intersections
    self._shapefunc_args = {'numSides': int(round(E('numSides'))),
                            'rotation': E('rotation')}

</t>
<t tx="karstenw.20170725110927.27">def precalc_node(self, node):
    super(PolyNodeDrawer, self).precalc_node(node)

    E = self._eval_func(node)

    r = node.width / 2
    cx = r
    cy = node.height / 2

    node._shape_points = geom.calc_regular_polygon_points(
                               cx, cy, r, int(round(E('numSides'))),
                               E('rotation'))

    # Slice with a single horizontal line vertically centered to the
    # shape
    connection_points = geom.slice_shape(node._shape_points, cy,
                                         node.height, node.height)

    node._conn_point_left = connection_points[0][0]
    node._conn_point_right = connection_points[0][1]

</t>
<t tx="karstenw.20170725110927.28">def _calc_shape_path(self, node):
    return createpath(_ctx, node._shape_points)


</t>
<t tx="karstenw.20170725110927.29">class OvalNodeDrawer(NodeDrawer):

    @others
# TODO
</t>
<t tx="karstenw.20170725110927.3">def __init__(self, childproperties, defaults, config):
    align = ('auto', 'left', 'right', 'center', 'justify')
    anchor = ('auto', 'center')

    properties = {
        'fontName':               (StringProperty,  {}),
        'fontSize':               (NumberProperty,  {'min': 0.0}),
        'lineHeight':             (NumberProperty,  {'min': 0.0}),
        'textAlign':              (EnumProperty,    {'values': align}),
        'justifyMinLines':        (NumberProperty,  {'min': 0.0}),
        'textBaselineCorrection': (NumberProperty,  {}),
        'maxTextWidth':           (NumberProperty,  {'min': 0.0}),
        'hyphenate':              (BooleanProperty, {}),
        'textPadX':               (NumberProperty,  {'min': 0.0}),
        'textPadY':               (NumberProperty,  {'min': 0.0}),

        'strokeWidth':            (NumberProperty,  {'min': 0.0}),

        'nodeDrawShadow':         (BooleanProperty, {}),
        'nodeShadowColor':        (ColorProperty,   {}),
        'nodeShadowBlur':         (NumberProperty,  {'min': 0.0}),
        'nodeShadowOffsX':        (NumberProperty,  {}),
        'nodeShadowOffsY':        (NumberProperty,  {}),

        'textDrawShadow':         (BooleanProperty, {}),
        'textShadowColor':        (ColorProperty,   {}),
        'textShadowOffsX':        (NumberProperty,  {}),
        'textShadowOffsY':        (NumberProperty,  {}),

        'drawGradient':           (BooleanProperty, {}),
        'gradientTopColor':       (ColorProperty,   {}),
        'gradientBottomColor':    (ColorProperty,   {}),

        'connectionAnchorPoint':  (EnumProperty,    {'values': anchor})
    }
    properties.update(childproperties)
    self._props = Properties(properties, self._defaults_path(defaults),
                             config)
    self._wraprect = True

# TODO util function in common?
</t>
<t tx="karstenw.20170725110927.30">def __init__(self, config={}):
    properties = {
        'aspectRatio': (NumberProperty, {'min': 0.0}),
        'maxWidth':    (NumberProperty, {'min': 0.0})
    }

    super(OvalNodeDrawer, self).__init__(properties, 'oval', config)

    E = self._eval_func(None)

    self._wraprect = False
    self._shapefunc = geom.calc_ellipse_intersections
    self._shapefunc_args = {'aspectRatio': E('aspectRatio'),
                            'maxWidth':    E('maxWidth')}

</t>
<t tx="karstenw.20170725110927.31">def _calc_shape_path(self, node):
    return _ctx.oval(0, 0, node.width, node.height, draw=False)


</t>
<t tx="karstenw.20170725110927.32">class CapsuleNodeDrawer(NodeDrawer):

    @others
_nodedrawer_map = {
    'rect':    RectNodeDrawer,
    'box':     BoxNodeDrawer,
    'line':    LineNodeDrawer,
    'poly':    PolyNodeDrawer,
    'oval':    OvalNodeDrawer,
    'capsule': CapsuleNodeDrawer
}


</t>
<t tx="karstenw.20170725110927.33">def __init__(self, config={}):
    super(CapsuleNodeDrawer, self).__init__({}, 'capsule', config)

</t>
<t tx="karstenw.20170725110927.34">def draw(self, node):
    # TODO
    pass


</t>
<t tx="karstenw.20170725110927.35">def nodedrawer_by_name(name):
    if name in _nodedrawer_map:
        return _nodedrawer_map[name]
    else:
        raise ValueError, 'Unrecognized node drawer name: %s' % name

</t>
<t tx="karstenw.20170725110927.4">def _defaults_path(self, conf):
    return os.path.join('node', conf)

</t>
<t tx="karstenw.20170725110927.5">def _eval_func(self, node):
    if node:
        vars = {
            'depth':       node.depth(),
            'numChildren': len(node.getchildren())
        }
    else:
        vars = {}
    return lambda name: self._props.eval(name, node, vars)

</t>
<t tx="karstenw.20170725110927.6">def precalc_node(self, node):
    """
    Precalculate node properties that are needed by the layout algorithms.
    """

    E = self._eval_func(node)

    node.fontsize = E('fontSize')
    self._precalc_text(node)

    padx = E('textPadX')
    pady = E('textPadY')

    node.width  = node.textwidth  + padx * 2
    node.height = node.textheight + pady * 2
    node.bboxwidth = node.width
    node.bboxheight = node.height

    node._textxoffs = padx
    node._textyoffs = pady

    node.text_has_background = True

    y = node.bboxheight / 2
    node._conn_point_left = Vector2(0, y)
    node._conn_point_right = Vector2(node.bboxwidth, y)


</t>
<t tx="karstenw.20170725110927.7">def connection_point(self, node, direction):
    E = self._eval_func(node)

    anchor = E('connectionAnchorPoint')

    if anchor == 'auto':
        if direction == Direction.Left:
            p = node._conn_point_left
        else:
            p = node._conn_point_right

        x, y = p.x, p.y

    elif anchor == 'center':
        x = node.bboxwidth / 2
        y = node.bboxheight / 2

    return node.x + x, node.y + y

</t>
<t tx="karstenw.20170725110927.8">def draw(self, node):
    """
    Draw the node at its (x,y) anchor point. Relies on internal
    properties precalculated by precalc_node.
    """

    E = self._eval_func(node)

    path = self._calc_shape_path(node)

    _ctx.push()
    _ctx.translate(node.x, node.y)
    _ctx.fill(node.fillcolor)
    _ctx.stroke(node.strokecolor)
    _ctx.strokewidth(E('strokeWidth'))

    if E('nodeDrawShadow'):
        _ctx.shadow(dx=E('nodeShadowOffsX'), dy=E('nodeShadowOffsY'),
                    blur=E('nodeShadowBlur'), clr=E('nodeShadowColor'))

    self._draw_gradient_shape(node, path, node.fillcolor)
    _ctx.noshadow()

    # Draw text shadow
    if E('textDrawShadow'):
        shadowcolor = E('textShadowColor');
        _ctx.fill(shadowcolor)

        self._drawtext(node, node._textxoffs - E('textShadowOffsX'),
                             node._textyoffs - E('textShadowOffsY'))

    _ctx.fill(node.fontcolor)
    self._drawtext(node, node._textxoffs, node._textyoffs)

    _ctx.pop()

</t>
<t tx="karstenw.20170725110927.9">def _draw_gradient_shape(self, node, path, basecolor):
    E = self._eval_func(node)

    if E('drawGradient'):
        _ctx.gradientfill(path,
                          E('gradientBottomColor'), E('gradientTopColor'),
                          type='linear')
    else:
        _ctx.fill(basecolor)
        _ctx.drawpath(path)

</t>
<t tx="karstenw.20170725110929.1">try:
    from thread import get_ident as _get_ident
except ImportError:
    from dummy_thread import get_ident as _get_ident

try:
    from _abcoll import KeysView, ValuesView, ItemsView
except ImportError:
    pass


</t>
<t tx="karstenw.20170725110929.10">def keys(self):
    'od.keys() -&gt; list of keys in od'
    return list(self)

</t>
<t tx="karstenw.20170725110929.11">def values(self):
    'od.values() -&gt; list of values in od'
    return [self[key] for key in self]

</t>
<t tx="karstenw.20170725110929.12">def items(self):
    'od.items() -&gt; list of (key, value) pairs in od'
    return [(key, self[key]) for key in self]

</t>
<t tx="karstenw.20170725110929.13">def iterkeys(self):
    'od.iterkeys() -&gt; an iterator over the keys in od'
    return iter(self)

</t>
<t tx="karstenw.20170725110929.14">def itervalues(self):
    'od.itervalues -&gt; an iterator over the values in od'
    for k in self:
        yield self[k]

</t>
<t tx="karstenw.20170725110929.15">def iteritems(self):
    'od.iteritems -&gt; an iterator over the (key, value) items in od'
    for k in self:
        yield (k, self[k])

</t>
<t tx="karstenw.20170725110929.16">def update(*args, **kwds):
    '''od.update(E, **F) -&gt; None.  Update od from dict/iterable E and F.

    If E is a dict instance, does:           for k in E: od[k] = E[k]
    If E has a .keys() method, does:         for k in E.keys(): od[k] = E[k]
    Or if E is an iterable of items, does:   for k, v in E: od[k] = v
    In either case, this is followed by:     for k, v in F.items(): od[k] = v

    '''
    if len(args) &gt; 2:
        raise TypeError('update() takes at most 2 positional '
                        'arguments (%d given)' % (len(args),))
    elif not args:
        raise TypeError('update() takes at least 1 argument (0 given)')
    self = args[0]
    # Make progressively weaker assumptions about "other"
    other = ()
    if len(args) == 2:
        other = args[1]
    if isinstance(other, dict):
        for key in other:
            self[key] = other[key]
    elif hasattr(other, 'keys'):
        for key in other.keys():
            self[key] = other[key]
    else:
        for key, value in other:
            self[key] = value
    for key, value in kwds.items():
        self[key] = value

__update = update  # let subclasses override update without breaking __init__

__marker = object()

</t>
<t tx="karstenw.20170725110929.17">def pop(self, key, default=__marker):
    '''od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.
    If key is not found, d is returned if given, otherwise KeyError is raised.

    '''
    if key in self:
        result = self[key]
        del self[key]
        return result
    if default is self.__marker:
        raise KeyError(key)
    return default

</t>
<t tx="karstenw.20170725110929.18">def setdefault(self, key, default=None):
    'od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od'
    if key in self:
        return self[key]
    self[key] = default
    return default

</t>
<t tx="karstenw.20170725110929.19">def __repr__(self, _repr_running={}):
    'od.__repr__() &lt;==&gt; repr(od)'
    call_key = id(self), _get_ident()
    if call_key in _repr_running:
        return '...'
    _repr_running[call_key] = 1
    try:
        if not self:
            return '%s()' % (self.__class__.__name__,)
        return '%s(%r)' % (self.__class__.__name__, self.items())
    finally:
        del _repr_running[call_key]

</t>
<t tx="karstenw.20170725110929.2">class OrderedDict(dict):
    'Dictionary that remembers insertion order'
    # An inherited dict maps keys to values.
    # The inherited dict provides __getitem__, __len__, __contains__, and get.
    # The remaining methods are order-aware.
    # Big-O running times for all methods are the same as for regular dictionaries.

    # The internal self.__map dictionary maps keys to links in a doubly linked list.
    # The circular doubly linked list starts and ends with a sentinel element.
    # The sentinel element never gets deleted (this simplifies the algorithm).
    # Each link is stored as a list of length three:  [PREV, NEXT, KEY].

    @others
## end of http://code.activestate.com/recipes/576693/ }}}

</t>
<t tx="karstenw.20170725110929.20">def __reduce__(self):
    'Return state information for pickling'
    items = [[k, self[k]] for k in self]
    inst_dict = vars(self).copy()
    for k in vars(OrderedDict()):
        inst_dict.pop(k, None)
    if inst_dict:
        return (self.__class__, (items,), inst_dict)
    return self.__class__, (items,)

</t>
<t tx="karstenw.20170725110929.21">def copy(self):
    'od.copy() -&gt; a shallow copy of od'
    return self.__class__(self)

</t>
<t tx="karstenw.20170725110929.22">@classmethod
def fromkeys(cls, iterable, value=None):
    '''OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S
    and values equal to v (which defaults to None).

    '''
    d = cls()
    for key in iterable:
        d[key] = value
    return d

</t>
<t tx="karstenw.20170725110929.23">def __eq__(self, other):
    '''od.__eq__(y) &lt;==&gt; od==y.  Comparison to another OD is order-sensitive
    while comparison to a regular mapping is order-insensitive.

    '''
    if isinstance(other, OrderedDict):
        return len(self)==len(other) and self.items() == other.items()
    return dict.__eq__(self, other)

</t>
<t tx="karstenw.20170725110929.24">def __ne__(self, other):
    return not self == other

# -- the following methods are only used in Python 2.7 --

</t>
<t tx="karstenw.20170725110929.25">def viewkeys(self):
    "od.viewkeys() -&gt; a set-like object providing a view on od's keys"
    return KeysView(self)

</t>
<t tx="karstenw.20170725110929.26">def viewvalues(self):
    "od.viewvalues() -&gt; an object providing a view on od's values"
    return ValuesView(self)

</t>
<t tx="karstenw.20170725110929.27">def viewitems(self):
    "od.viewitems() -&gt; a set-like object providing a view on od's items"
    return ItemsView(self)

</t>
<t tx="karstenw.20170725110929.3">def __init__(self, *args, **kwds):
    '''Initialize an ordered dictionary.  Signature is the same as for
    regular dictionaries, but keyword arguments are not recommended
    because their insertion order is arbitrary.

    '''
    if len(args) &gt; 1:
        raise TypeError('expected at most 1 arguments, got %d' % len(args))
    try:
        self.__root
    except AttributeError:
        self.__root = root = []                     # sentinel node
        root[:] = [root, root, None]
        self.__map = {}
    self.__update(*args, **kwds)

</t>
<t tx="karstenw.20170725110929.4">def __setitem__(self, key, value, dict_setitem=dict.__setitem__):
    'od.__setitem__(i, y) &lt;==&gt; od[i]=y'
    # Setting a new item creates a new link which goes at the end of the linked
    # list, and the inherited dictionary is updated with the new key/value pair.
    if key not in self:
        root = self.__root
        last = root[0]
        last[1] = root[0] = self.__map[key] = [last, root, key]
    dict_setitem(self, key, value)

</t>
<t tx="karstenw.20170725110929.5">def __delitem__(self, key, dict_delitem=dict.__delitem__):
    'od.__delitem__(y) &lt;==&gt; del od[y]'
    # Deleting an existing item uses self.__map to find the link which is
    # then removed by updating the links in the predecessor and successor nodes.
    dict_delitem(self, key)
    link_prev, link_next, key = self.__map.pop(key)
    link_prev[1] = link_next
    link_next[0] = link_prev

</t>
<t tx="karstenw.20170725110929.6">def __iter__(self):
    'od.__iter__() &lt;==&gt; iter(od)'
    root = self.__root
    curr = root[1]
    while curr is not root:
        yield curr[2]
        curr = curr[1]

</t>
<t tx="karstenw.20170725110929.7">def __reversed__(self):
    'od.__reversed__() &lt;==&gt; reversed(od)'
    root = self.__root
    curr = root[0]
    while curr is not root:
        yield curr[2]
        curr = curr[0]

</t>
<t tx="karstenw.20170725110929.8">def clear(self):
    'od.clear() -&gt; None.  Remove all items from od.'
    try:
        for node in self.__map.itervalues():
            del node[:]
        root = self.__root
        root[:] = [root, root, None]
        self.__map.clear()
    except AttributeError:
        pass
    dict.clear(self)

</t>
<t tx="karstenw.20170725110929.9">def popitem(self, last=True):
    '''od.popitem() -&gt; (k, v), return and remove a (key, value) pair.
    Pairs are returned in LIFO order if last is true or FIFO order if false.

    '''
    if not self:
        raise KeyError('dictionary is empty')
    root = self.__root
    if last:
        link = root[0]
        link_prev = link[0]
        link_prev[1] = root
        root[0] = link_prev
    else:
        link = root[1]
        link_next = link[1]
        root[1] = link_next
        link_next[0] = root
    key = link[2]
    del self.__map[key]
    value = dict.pop(self, key)
    return key, value

# -- the following methods do not depend on the internal structure --

</t>
<t tx="karstenw.20170725110932.1">from twyg.hyphenator import hyphenate_word
from twyg.geom import Rectangle


_hyphenate_word_cache = {}


</t>
<t tx="karstenw.20170725110932.2">def _calc_inside_rects(points):
    """
    Calculate a list of horizontal rectangles fitting into a convex
    shape.

    ``points``
        A list of intersection point-pairs of a set of equidistant
        horizontal lines intersecting the segments defining shape
        (should be calculated by ``slice_shape``).

    Rectangles are returned as a list of ``[x, y, width, height]``
    arrays.
    """
    rects = []
    for i in range(len(points) - 1):
        p11, p12 = points[i]
        p21, p22 = points[i + 1]

        x = max(p11.x, p21.x)
        y = p11.y
        w = min(p12.x, p22.x) - x
        h = p21.y - p11.y

        rects.append(Rectangle(x, y, w, h))

    return rects


</t>
<t tx="karstenw.20170725110932.3">def _hyphenate_word(word):
    """ Memoized hyphenate_word() function. """
    cache = _hyphenate_word_cache
    if word not in cache:
        cache[word] = hyphenate_word(word)
    return cache[word][:]


</t>
<t tx="karstenw.20170725110932.4">def _splittext(txt, textwidth_func):
    words = txt.split()
    wordwidths = [textwidth_func(w) for w in words]
    spacewidth = textwidth_func(' ')
    return words, wordwidths, spacewidth


</t>
<t tx="karstenw.20170725110932.5">def _wraptext(words, wordwidths, spacewidth, textwidth_func, rects=None,
              maxwidth=0, hyphenate=False, max_spacewidth_factor=5):
    """
    Wrap text in a list of variable-width or fixed-width lines.

    ``words`` should contain the text as a list of words, ``wordwidths``
    the width of each word from the words list and ``spacewidth`` the
    width of a single space character. The function returns a list of
    strings containing the text in each line and a list of line widths.

    TODO max_spacewidth_factor, hyphenate

    In variable-width mode, ``rects`` holds a list of Rectangle objects
    that represent the blank lines the text should be wrapped into. The
    value of ``maxwidth`` is disregarded in this case. The following
    three outcomes are possible:

        len(lines) = len(rects)   -- optimal wrap
        len(lines) &gt; len(rects)   -- can't fit text into the available
                                     rects
        len(lines) &lt; len(rects)   -- suboptimal wrap

    In fixed-width mode, ``rects`` is None and ``maxwidth`` holds the
    fixed line length (must be greater than zero).
    """

    if not rects and maxwidth &lt;= 0:
        raise (ValueError,
               'maxwidth must be greater than 0 if no rects are provided')

    maxwidth = max(maxwidth, max(wordwidths))

    lines = ['']         # wrapped text per each line
    linewidths = [0]     # linewidth of each line (including spaces)

    currline = currword = linewidth = 0
    maxlinewidth = rects[currline].w if rects else maxwidth

    if hyphenate:
        words = words[:]
        wordwidths = wordwidths[:]

    while currword &lt; len(words):
        word = words[currword]

        # Start a new line if word doesn't fit into the current line
        if (linewidth
            + (spacewidth if linewidth &gt; 0 else 0)
            + wordwidths[currword] &gt; maxlinewidth):

            # Special path if hyphenation is enabled and there's enough
            # white space in the line
            if (hyphenate and maxlinewidth - linewidth
                &gt; spacewidth * max_spacewidth_factor):

                parts = _hyphenate_word(word)
                parts[0] = ' ' + parts[0]
                partial_word = ''

                # Try to jam in as many syllables from the word at the
                # end of the line as possible
                for i, p in enumerate(parts):
                    partwidth = textwidth_func(p + '-')
                    if linewidth + partwidth &lt;= maxlinewidth:
                        partial_word += p
                        linewidth += partwidth
                    else:
                        break

                if partial_word:
                    # Remove initial space if we're at the start of a
                    # line
                    if not lines[currline]:
                        partial_word = partial_word[1:]
                        linewidth -= spacewidth

                    # Add partial word to the end of the line
                    lines[currline] += partial_word + '-'
                    linewidths[currline] = linewidth
                    currword += 1

                    # Insert remaining parts before the next word as a
                    # "new word"
                    remaining_parts = ''.join(parts[i:])
                    words.insert(currword, remaining_parts)
                    wordwidths.insert(currword,
                                      textwidth_func(words[currword]))

            # Move to the next line
            currline += 1
            lines.append('')
            linewidths.append(0)

            # Stop if all the words don't fit into the number of
            # available rects (note: there's an extra blank line now at
            # the end of lines that ensures that len(lines) &gt; len(rects))
            if rects and currline &gt;= len(rects):
                break

            maxlinewidth = rects[currline].w if rects else maxwidth
            linewidth = 0

            # The widths need to be checked again because it's not
            # guaranteed that the word will fit into the next blank line
            continue

        # Append spaces between words after the first word on the line
        if lines[currline]:
            lines[currline] += ' '
            linewidth += spacewidth

        # Append word and update state variables
        lines[currline] += words[currword]
        linewidth += wordwidths[currword]
        linewidths[currline] = linewidth
        currword += 1

    return lines, linewidths


</t>
<t tx="karstenw.20170725110932.6">def wrap_rect(txt, lineheight, textwidth_func, maxwidth,
              hyphenate=False, hyphen_min_words=10):

    # Calculate word widths &amp; space width
    words, wordwidths, spacewidth = _splittext(txt, textwidth_func)

    hyphenate &amp;= len(words) &gt; hyphen_min_words

    lines, linewidths = _wraptext(words, wordwidths, spacewidth,
                                  textwidth_func, maxwidth=maxwidth,
                                  hyphenate=hyphenate)
    numlines = len(lines)
    if numlines == 1:
        w = linewidths[0]
        h = lineheight
        rects = [Rectangle(0, 0, w, lineheight)]
    else:
        w = maxwidth
        h = lineheight * numlines
        rects = ([Rectangle(0, i * lineheight, w, lineheight)
                 for i in range(numlines)])

    return lines, linewidths, rects, w, h


</t>
<t tx="karstenw.20170725110932.7">def wrap_shape(txt, lineheight, textwidth_func, shapefunc,
               hyphenate=False, hyphen_min_words=10, **kwargs):

    # Initial shape width &amp; height

    # Must be &gt;= lineheight
    base_width = lineheight * 4
    scalefactor = 0.5
    currscale = 1.0
    params = []
    lastiteration = False
    null_result = [[], [], [], 0.0, 0.0]

    # Calculate word widths &amp; space width
    words, wordwidths, spacewidth = _splittext(txt, textwidth_func)
    hyphenate &amp;= len(words) &gt; hyphen_min_words

    while 1:
        w = base_width * currscale

        points, w, h = shapefunc(w, lineheight, **kwargs)
        if not points:
            return null_result

        rects = _calc_inside_rects(points)

        lines, linewidths = _wraptext(words, wordwidths, spacewidth,
                                      textwidth_func, rects=rects,
                                      hyphenate=hyphenate)
        if lastiteration:
            break

        numlines = len(lines)
        numrects = len(rects)

        params.append({
            'numlines': numlines,
            'numrects': numrects,
            'currscale': currscale
        });

        # Optimal solution found: all rects are filled with text.
        if numlines == numrects:
            break

        # Otherwise try to iteratively "zoom-in" on the optimal
        # solution: halve step size and change scale direction in case
        # of over or undershoot.
        if (numlines &lt; numrects and scalefactor &gt; 0 or
            numlines &gt; numrects and scalefactor &lt; 0):

            scalefactor *= -.5

        # If no optimal solution was found in 20 iterations, simply pick
        # the best solution or return empty values if no solution was
        # found
        if len(params) &gt;= 20:
            params = [p for p in params if p['numrects'] &gt; p['numlines']]
            if not params:
                return null_result

            params = sorted(params,
                            key=lambda p: p['numrects'] - p['numlines'])

            currscale = params[0]['currscale']
            lastiteration = True
            continue

        currscale *= 1 + scalefactor

    return lines, linewidths, rects, w, h

</t>
<t tx="karstenw.20170725110934.1">import sys

from twyg.geom import Vector2, Rectangle


</t>
<t tx="karstenw.20170725110934.10">def direction(self):
    """ Get the position of the node in relation to its parent. """
    if self.isroot():
        return None
    if self.x - self.parent.x &lt; 0:
        return Direction.Left
    else:
        return Direction.Right

</t>
<t tx="karstenw.20170725110934.11">def getchildren(self, direction=None):
    if direction:
        return [c for c in self.children
                if c.direction() == direction]
    else:
        return self.children

</t>
<t tx="karstenw.20170725110934.12">def connection_point(self, direction):
    return self.nodedrawer.drawer.connection_point(self, direction)

</t>
<t tx="karstenw.20170725110934.13">def shiftbranch(self, dx, dy):
    self.x += dx
    self.y += dy
    for child in self.children:
        child.shiftbranch(dx, dy)


</t>
<t tx="karstenw.20170725110934.14">class TreeBuilder(object):

    @others
</t>
<t tx="karstenw.20170725110934.15">def build_tree(self, tree):
    #TODO proper error handling
    if type(tree) != dict:
        raise ValueError('Invalid JSON structure: Root element must be a dict')

    root = tree.iteritems().next()
    root_label = root[0]
    children = root[1]
    root_node = Node(root_label)
    self._build_tree(root_node, children)
    return root_node

</t>
<t tx="karstenw.20170725110934.16">def _build_tree(self, node, children):
    if type(children) in (str, unicode):
        Node(children, parent=node)
    else:
        for c in children:
            if type(c) == dict:
                child = Node(c.keys()[0], parent=node)
                self._build_tree(child, c.values()[0])
            elif type(c) in (list, tuple):
                #TODO proper error handling
                raise ValueError('Invalid JSON structure: Dicts cannot have List siblings')
            else:
                Node(c, parent=node)


</t>
<t tx="karstenw.20170725110934.17">class Tree(object):

    @others
</t>
<t tx="karstenw.20170725110934.18">def __init__(self, layout, nodedrawers, conndrawers, colorizers, data):
    builder = TreeBuilder()
    self.root = builder.build_tree(data)

    self._nodelist = []
    self._collect_nodes(self.root, self._nodelist)

    self._layout = layout

    self._nodedrawers = nodedrawers
    self._conndrawers = conndrawers
    self._colorizers = colorizers

    # Precalculate the orientation of the nodes before assigning the
    # drawer objects to them. It is important to do this before the
    # assignment would occur, because the section level rules take
    # the nodes' orientation into consideration when determining the
    # correct drawer for them.
    self._layout.precalc_layout(self.root)
    self._assign_drawers()

</t>
<t tx="karstenw.20170725110934.19">def print_tree(self):
    self._print_tree(self.root)

</t>
<t tx="karstenw.20170725110934.2">class Direction(object):
    Top, Right, Bottom, Left = range(4)


</t>
<t tx="karstenw.20170725110934.20">def calclayout(self):
    for node in self._nodelist:
        node.nodedrawer.drawer.precalc_node(node)

    self._layout.calclayout(self.root)
    self._colorize_nodes(self.root)

    self.bbox = self._calcbbox()
    self.shiftnodes(-self.bbox.x, -self.bbox.y)

    return self.bbox.w, self.bbox.h

</t>
<t tx="karstenw.20170725110934.21">def shiftnodes(self, dx, dy):
    self.root.shiftbranch(dx, dy)

</t>
<t tx="karstenw.20170725110934.22">def draw(self):
    self._draw_connections(self.root)
    self._draw_nodes()

</t>
<t tx="karstenw.20170725110934.23">def background_color(self):
    # The background color for the canvas is always taken from the first
    # colorizer instance.
    return  self._colorizers[0].drawer.background_color()

</t>
<t tx="karstenw.20170725110934.24">def _assign_drawers(self):
    """ Assign the correct drawer objects for each node as specified
    by the section level configurations."""

    for node in self._nodelist:
        for nd in self._nodedrawers:
            if nd.level.selects(node, self._layout):
                node.nodedrawer = nd

        for cd in self._conndrawers:
            if cd.level.selects(node, self._layout):
                node.conndrawer = cd

        for c in self._colorizers:
            if c.level.selects(node, self._layout):
                node.colorizer = c

</t>
<t tx="karstenw.20170725110934.25">def _print_tree(self, node):
    print (" " * node.depth() * 2) + node.label
    for child in node.children:
        self._print_tree(child)

</t>
<t tx="karstenw.20170725110934.26">def _collect_nodes(self, node, nodelist):
    for child in node.children:
        self._collect_nodes(child, nodelist)
    nodelist.append(node)

</t>
<t tx="karstenw.20170725110934.27">def _draw_nodes(self):
    self._nodelist.sort(key=lambda x: x.y, reverse=False)
    for node in self._nodelist:
        node.nodedrawer.drawer.draw(node)
    pass

</t>
<t tx="karstenw.20170725110934.28">def _draw_connections(self, node):
    for node in self._nodelist:
        node.conndrawer.drawer.draw(node)

</t>
<t tx="karstenw.20170725110934.29">def _colorize_nodes(self, node):
    node.colorizer.drawer.colorize(node)
    for child in node.children:
        self._colorize_nodes(child)

</t>
<t tx="karstenw.20170725110934.3">def opposite_dir(d):
    if d == Direction.Bottom:
        return Direction.Top
    if d == Direction.Right:
        return Direction.Left
    if d == Direction.Top:
        return Direction.Bottom
    if d == Direction.Left:
        return Direction.Right
    else:
        raise ValueError, 'Invalid direction: %s' % d


</t>
<t tx="karstenw.20170725110934.30">def _calcbbox(self):
    m = sys.maxint
    topleft = Vector2(m, m)
    bottomright = Vector2(-m, -m)
    self._calcbbox_recurse(self.root, topleft, bottomright)
    return Rectangle(topleft.x, topleft.y,
                     bottomright.x - topleft.x, bottomright.y - topleft.y)

</t>
<t tx="karstenw.20170725110934.31">def _calcbbox_recurse(self, node, topleft, bottomright):
    if node.x &lt; topleft.x:
        topleft.x = node.x
    if node.y &lt; topleft.y:
        topleft.y = node.y

    x2 = node.x + node.bboxwidth
    y2 = node.y + node.bboxheight

    if x2 &gt; bottomright.x:
        bottomright.x = x2
    if y2 &gt; bottomright.y:
        bottomright.y = y2

    for child in node.children:
        self._calcbbox_recurse(child, topleft, bottomright)

</t>
<t tx="karstenw.20170725110934.4">class Node(object):

    @others
</t>
<t tx="karstenw.20170725110934.5">def __init__(self, label, parent=None):
    """
    Create a new node and associate it with a parent node. If
    ``parent`` is ``None``, a root node will be created.
    """
    self.label = label
    self.parent = parent
    if parent:
        parent.children.append(self)

    self.children = []
    self.x = 0
    self.y = 0

    # Property name (Python classes) to variable name (config expressions)
    # mappings
    self.property_mappings = {
        'x':               'x',
        'y':               'y',
        'fontsize':        'fontSize',
        'width':           'width',
        'height':          'height',
        'bboxwidth':       'bboxWidth',
        'bboxheight':      'bboxHeight',
        'textwidth':       'textWidth',
        'textheight':      'textHeight',
        'max_text_width':  'maxTextWidth',
        'bgcolor':         'bgColor',
        'basecolor':       'baseColor',
        'fillcolor':       'fillColor',
        'strokecolor':     'strokeColor',
        'connectioncolor': 'connectionColor',
        'fontcolor':       'fontColor',
        'lineheight':      'lineHeight'
    }

</t>
<t tx="karstenw.20170725110934.6">def isleaf(self):
    return len(self.children) == 0

</t>
<t tx="karstenw.20170725110934.7">def isroot(self):
    return self.parent == None

</t>
<t tx="karstenw.20170725110934.8">def depth(self):
    depth = 0
    curr = self
    while curr.parent:
        curr = curr.parent
        depth += 1
    return depth

</t>
<t tx="karstenw.20170725110934.9">def ancestor(self, n):
    """ Get the n-th ancestor of this node.

    If ``n`` is negative, the ancestor is counted from the root node.
    If ``n`` is 0, the root node is returned.
    """

    # If n is positive, get n-th ancestor from the node towards the root
    if n &gt; 0:
        depth = 0
        curr = self
        while curr.parent:
            curr = curr.parent
            depth += 1
            if depth == n:
                return curr
        raise ValueError, 'Node ancestor argument out of range: ' + n

    # If n is negative or zero, get n-th ancestor from the root
    # towards the node
    if n &lt;= 0:
        curr = self
        ancestors = [curr]
        while curr.parent:
            curr = curr.parent
            ancestors.append(curr)

        if n == 0:
            return ancestors[-1]
        else:
            n -= 1
            if -n &gt; len(ancestors):
                raise (ValueError,
                      'Node ancestor argument out of range: ' + n)
            return ancestors[n]

</t>
<t tx="karstenw.20170725115953.1">### SHAPE #################################################################

</t>
<t tx="karstenw.20170725120016.1">### PATH ##################################################################

</t>
<t tx="karstenw.20170725120058.1">### TRANSFORM #############################################################

</t>
<t tx="karstenw.20170725120123.1">### COLOR #################################################################

</t>
<t tx="karstenw.20170725120152.1">### TYPOGRAPHY ############################################################

</t>
<t tx="karstenw.20170725120215.1">### IMAGE #################################################################

</t>
<t tx="karstenw.20170725120232.1">### UTILITY ###############################################################

</t>
<t tx="karstenw.20170725120250.1">#=========================================================================#
#=  COLORS LIBRARY                                                       =#
#=========================================================================#

</t>
<t tx="karstenw.20170725120312.1">#=========================================================================#
#=  HELPER FUNCTIONS                                                     =#
#=========================================================================#

</t>
</tnodes>
</leo_file>
