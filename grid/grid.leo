<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="karstenw.20260127160246.2" a="E"><vh>Library</vh>
<v t="karstenw.20260127160303.1"><vh>@clean __init__.py</vh>
<v t="karstenw.20260127160317.1"><vh>Declarations</vh></v>
<v t="karstenw.20260127160317.2"><vh>_unique_id</vh></v>
<v t="karstenw.20260127160317.3"><vh>class format</vh>
<v t="karstenw.20260127160317.4"><vh>__init__</vh></v>
<v t="karstenw.20260127160317.5"><vh>__call__</vh></v>
</v>
<v t="karstenw.20260127160317.6"><vh>_update_text_ctx</vh></v>
<v t="karstenw.20260127160317.7"><vh>keep_together</vh></v>
<v t="karstenw.20260127160317.8"><vh>split</vh></v>
<v t="karstenw.20260127160317.9"><vh>divide</vh></v>
<v t="karstenw.20260127160317.10"><vh>legible_width</vh></v>
<v t="karstenw.20260127160317.11"><vh>fit_fontsize</vh></v>
<v t="karstenw.20260127160317.12"><vh>content</vh></v>
<v t="karstenw.20260127160317.13"><vh>proportion</vh></v>
<v t="karstenw.20260127160317.14"><vh>class splitter</vh>
<v t="karstenw.20260127160317.15"><vh>_jump</vh></v>
<v t="karstenw.20260127160317.16"><vh>_first</vh></v>
<v t="karstenw.20260127160317.17"><vh>_second</vh></v>
<v t="karstenw.20260127160317.18"><vh>_third</vh></v>
<v t="karstenw.20260127160317.19"><vh>_fourth</vh></v>
<v t="karstenw.20260127160317.20"><vh>_fifth</vh></v>
<v t="karstenw.20260127160317.21"><vh>_sixth</vh></v>
<v t="karstenw.20260127160317.22"><vh>_top</vh></v>
<v t="karstenw.20260127160317.23"><vh>_left</vh></v>
<v t="karstenw.20260127160317.24"><vh>_bottom</vh></v>
<v t="karstenw.20260127160317.25"><vh>_right</vh></v>
</v>
<v t="karstenw.20260127160317.26"><vh>class statistics</vh>
<v t="karstenw.20260127160317.27"><vh>_count</vh></v>
<v t="karstenw.20260127160317.28"><vh>_used</vh></v>
<v t="karstenw.20260127160317.29"><vh>_empty</vh></v>
<v t="karstenw.20260127160317.30"><vh>_numeric</vh></v>
<v t="karstenw.20260127160317.31"><vh>_numbers</vh></v>
<v t="karstenw.20260127160317.32"><vh>_sum</vh></v>
<v t="karstenw.20260127160317.33"><vh>_avg</vh></v>
<v t="karstenw.20260127160317.34"><vh>_min</vh></v>
<v t="karstenw.20260127160317.35"><vh>_max</vh></v>
<v t="karstenw.20260127160317.36"><vh>_variance</vh></v>
<v t="karstenw.20260127160317.37"><vh>_stdev</vh></v>
</v>
<v t="karstenw.20260127160317.38"><vh>class rows</vh>
<v t="karstenw.20260127160317.39"><vh>row</vh></v>
</v>
<v t="karstenw.20260127160317.40"><vh>class columns</vh>
<v t="karstenw.20260127160317.41"><vh>column</vh></v>
</v>
<v t="karstenw.20260127160317.42"><vh>class cells</vh>
<v t="karstenw.20260127160317.43"><vh>__init__</vh></v>
<v t="karstenw.20260127160317.44"><vh>__eq__</vh></v>
<v t="karstenw.20260127160317.45"><vh>__add__</vh></v>
<v t="karstenw.20260127160317.46"><vh>__getslice__</vh></v>
<v t="karstenw.20260127160317.47"><vh>_get_property</vh></v>
<v t="karstenw.20260127160317.48"><vh>_set_property</vh></v>
<v t="karstenw.20260127160317.49"><vh>_get_root</vh></v>
<v t="karstenw.20260127160317.50"><vh>_get_styles</vh></v>
<v t="karstenw.20260127160317.51"><vh>_get_style</vh></v>
<v t="karstenw.20260127160317.52"><vh>_set_style</vh></v>
<v t="karstenw.20260127160317.53"><vh>_get_content</vh></v>
<v t="karstenw.20260127160317.54"><vh>_set_content</vh></v>
<v t="karstenw.20260127160317.55"><vh>_get_content_width</vh></v>
<v t="karstenw.20260127160317.56"><vh>_get_content_height</vh></v>
<v t="karstenw.20260127160317.57"><vh>_get_width</vh></v>
<v t="karstenw.20260127160317.58"><vh>_set_width</vh></v>
<v t="karstenw.20260127160317.59"><vh>_get_height</vh></v>
<v t="karstenw.20260127160317.60"><vh>_set_height</vh></v>
<v t="karstenw.20260127160317.61"><vh>_get_fixed</vh></v>
<v t="karstenw.20260127160317.62"><vh>_set_fixed</vh></v>
<v t="karstenw.20260127160317.63"><vh>_get_x</vh></v>
<v t="karstenw.20260127160317.64"><vh>_get_y</vh></v>
<v t="karstenw.20260127160317.65"><vh>flow_horizontal</vh></v>
<v t="karstenw.20260127160317.66"><vh>flow_vertical</vh></v>
</v>
<v t="karstenw.20260127160317.67"><vh>class row</vh>
<v t="karstenw.20260127160317.68"><vh>column</vh></v>
<v t="karstenw.20260127160317.69"><vh>_get_relative_width</vh></v>
<v t="karstenw.20260127160317.70"><vh>_set_relative_width</vh></v>
<v t="karstenw.20260127160317.71"><vh>_get_relative_height</vh></v>
<v t="karstenw.20260127160317.72"><vh>_set_relative_height</vh></v>
</v>
<v t="karstenw.20260127160317.73"><vh>class column</vh>
<v t="karstenw.20260127160317.74"><vh>row</vh></v>
<v t="karstenw.20260127160317.75"><vh>_get_relative_height</vh></v>
<v t="karstenw.20260127160317.76"><vh>_set_relative_height</vh></v>
<v t="karstenw.20260127160317.77"><vh>_get_relative_width</vh></v>
<v t="karstenw.20260127160317.78"><vh>_set_relative_width</vh></v>
</v>
<v t="karstenw.20260127160317.79"><vh>class grid</vh>
<v t="karstenw.20260127160317.80"><vh>__init__</vh></v>
<v t="karstenw.20260127160317.81"><vh>_get_proportion</vh></v>
<v t="karstenw.20260127160317.82"><vh>_set_proportion</vh></v>
<v t="karstenw.20260127160317.83"><vh>arrange</vh></v>
<v t="karstenw.20260127160317.84"><vh>clear</vh></v>
<v t="karstenw.20260127160317.85"><vh>split</vh></v>
<v t="karstenw.20260127160317.86"><vh>update</vh></v>
<v t="karstenw.20260127160317.87"><vh>_get_root</vh></v>
<v t="karstenw.20260127160317.88"><vh>flatten</vh></v>
<v t="karstenw.20260127160317.89"><vh>copy</vh></v>
<v t="karstenw.20260127160317.90"><vh>__repr__</vh></v>
<v t="karstenw.20260127160317.91"><vh>__eq__</vh></v>
<v t="karstenw.20260127160317.92"><vh>__ne__</vh></v>
<v t="karstenw.20260127160317.93"><vh>find</vh></v>
<v t="karstenw.20260127160317.94"><vh>__getattr__</vh></v>
<v t="karstenw.20260127160317.95"><vh>cell</vh></v>
<v t="karstenw.20260127160317.96"><vh>__call__</vh></v>
<v t="karstenw.20260127160317.97"><vh>row</vh></v>
<v t="karstenw.20260127160317.98"><vh>column</vh></v>
<v t="karstenw.20260127160317.99"><vh>_get_cols</vh></v>
<v t="karstenw.20260127160317.100"><vh>_set_cols</vh></v>
<v t="karstenw.20260127160317.101"><vh>_get_relative_width</vh></v>
<v t="karstenw.20260127160317.102"><vh>_get_relative_height</vh></v>
<v t="karstenw.20260127160317.103"><vh>_set_relative_width</vh></v>
<v t="karstenw.20260127160317.104"><vh>_set_relative_height</vh></v>
<v t="karstenw.20260127160317.105"><vh>_get_width</vh></v>
<v t="karstenw.20260127160317.106"><vh>_get_height</vh></v>
<v t="karstenw.20260127160317.107"><vh>_set_width</vh></v>
<v t="karstenw.20260127160317.108"><vh>_set_height</vh></v>
<v t="karstenw.20260127160317.109"><vh>size</vh></v>
<v t="karstenw.20260127160317.110"><vh>_get_x</vh></v>
<v t="karstenw.20260127160317.111"><vh>_get_y</vh></v>
<v t="karstenw.20260127160317.112"><vh>_get_styles</vh></v>
<v t="karstenw.20260127160317.113"><vh>_set_styles</vh></v>
<v t="karstenw.20260127160317.114"><vh>has_style</vh></v>
<v t="karstenw.20260127160317.115"><vh>_set_style</vh></v>
<v t="karstenw.20260127160317.116"><vh>_get_style</vh></v>
<v t="karstenw.20260127160317.117"><vh>has_content</vh></v>
<v t="karstenw.20260127160317.118"><vh>_set_content</vh></v>
<v t="karstenw.20260127160317.119"><vh>_get_content</vh></v>
<v t="karstenw.20260127160317.120"><vh>_content_width</vh></v>
<v t="karstenw.20260127160317.121"><vh>_content_height</vh></v>
<v t="karstenw.20260127160317.122"><vh>flow_vertical</vh></v>
<v t="karstenw.20260127160317.123"><vh>flow_horizontal</vh></v>
<v t="karstenw.20260127160317.124"><vh>_reset</vh></v>
<v t="karstenw.20260127160317.125"><vh>_traverse</vh></v>
<v t="karstenw.20260127160317.126"><vh>traverse</vh></v>
<v t="karstenw.20260127160317.127"><vh>draw</vh></v>
<v t="karstenw.20260127160317.128"><vh>distribute</vh></v>
</v>
<v t="karstenw.20260127160520.1"><vh>#--------------------------</vh></v>
<v t="karstenw.20260127160317.129"><vh>create</vh></v>
<v t="karstenw.20260127160317.130"><vh>save</vh></v>
<v t="karstenw.20260127160317.131"><vh>load</vh></v>
<v t="karstenw.20260127160317.132"><vh>highlight</vh></v>
<v t="karstenw.20260127160617.1"><vh>epilogue</vh></v>
</v>
<v t="karstenw.20260127160707.1"><vh>@clean content.py</vh>
<v t="karstenw.20260127160722.1"><vh>Declarations</vh></v>
<v t="karstenw.20260127160722.2"><vh>class content</vh>
<v t="karstenw.20260127160722.3"><vh>__init__</vh></v>
<v t="karstenw.20260127160722.4"><vh>_get_remainder</vh></v>
<v t="karstenw.20260127160722.5"><vh>copy</vh></v>
<v t="karstenw.20260127160722.6"><vh>is_image_path</vh></v>
<v t="karstenw.20260127160722.7"><vh>is_text</vh></v>
<v t="karstenw.20260127160722.8"><vh>is_number</vh></v>
<v t="karstenw.20260127160722.9"><vh>is_image</vh></v>
<v t="karstenw.20260127160722.10"><vh>is_command</vh></v>
<v t="karstenw.20260127160722.11"><vh>has_text</vh></v>
<v t="karstenw.20260127160722.12"><vh>has_number</vh></v>
<v t="karstenw.20260127160722.13"><vh>has_image</vh></v>
<v t="karstenw.20260127160722.14"><vh>text</vh></v>
<v t="karstenw.20260127160722.15"><vh>number</vh></v>
<v t="karstenw.20260127160722.16"><vh>image</vh></v>
<v t="karstenw.20260127160722.17"><vh>next</vh></v>
<v t="karstenw.20260127160722.18"><vh>default_draw</vh></v>
<v t="karstenw.20260127160722.19"><vh>_unpack</vh></v>
<v t="karstenw.20260127160722.20"><vh>__eq__</vh></v>
<v t="karstenw.20260127160722.21"><vh>__ne__</vh></v>
<v t="karstenw.20260127160722.22"><vh>__lt__</vh></v>
<v t="karstenw.20260127160722.23"><vh>__gt__</vh></v>
<v t="karstenw.20260127160722.24"><vh>__str__</vh></v>
<v t="karstenw.20260127160722.25"><vh>__unicode__</vh></v>
<v t="karstenw.20260127160722.26"><vh>__iter__</vh></v>
<v t="karstenw.20260127160722.27"><vh>__float__</vh></v>
<v t="karstenw.20260127160722.28"><vh>__int__</vh></v>
<v t="karstenw.20260127160722.29"><vh>__add__</vh></v>
<v t="karstenw.20260127160722.30"><vh>__sub__</vh></v>
<v t="karstenw.20260127160722.31"><vh>__mul__</vh></v>
<v t="karstenw.20260127160722.32"><vh>__div__</vh></v>
<v t="karstenw.20260127160722.33"><vh>__abs__</vh></v>
<v t="karstenw.20260127160722.34"><vh>__len__</vh></v>
<v t="karstenw.20260127160722.35"><vh>__contains__</vh></v>
<v t="karstenw.20260127160722.36"><vh>__getitem__</vh></v>
<v t="karstenw.20260127160722.37"><vh>__setitem__</vh></v>
<v t="karstenw.20260127160722.38"><vh>__call__</vh></v>
</v>
</v>
<v t="karstenw.20260127160731.1"><vh>@clean proportion.py</vh>
<v t="karstenw.20260127160739.1"><vh>Declarations</vh></v>
<v t="karstenw.20260127160739.2"><vh>class proportion</vh>
<v t="karstenw.20260127160739.3"><vh>__init__</vh></v>
<v t="karstenw.20260127160739.4"><vh>__getitem__</vh></v>
<v t="karstenw.20260127160739.5"><vh>copy</vh></v>
<v t="karstenw.20260127160739.6"><vh>generate</vh></v>
<v t="karstenw.20260127160739.7"><vh>relativize</vh></v>
<v t="karstenw.20260127160739.8"><vh>mirror</vh></v>
<v t="karstenw.20260127160739.9"><vh>fib</vh></v>
<v t="karstenw.20260127160739.10"><vh>draw</vh></v>
</v>
</v>
<v t="karstenw.20260127160808.1"><vh>@clean style.py</vh>
<v t="karstenw.20260127160816.1"><vh>Declarations</vh></v>
<v t="karstenw.20260127160816.2"><vh>class attributes_with_attributes</vh>
<v t="karstenw.20260127160816.3"><vh>__setattr__</vh></v>
</v>
<v t="karstenw.20260127160816.4"><vh>class styles</vh>
<v t="karstenw.20260127160816.5"><vh>__init__</vh></v>
<v t="karstenw.20260127160816.6"><vh>apply</vh></v>
<v t="karstenw.20260127160816.7"><vh>create</vh></v>
<v t="karstenw.20260127160816.8"><vh>append</vh></v>
<v t="karstenw.20260127160816.9"><vh>__getattr__</vh></v>
<v t="karstenw.20260127160816.10"><vh>__setattr__</vh></v>
<v t="karstenw.20260127160816.11"><vh>copy</vh></v>
</v>
<v t="karstenw.20260127160816.12"><vh>class styleguide</vh>
<v t="karstenw.20260127160816.13"><vh>__init__</vh></v>
<v t="karstenw.20260127160816.14"><vh>append</vh></v>
<v t="karstenw.20260127160816.15"><vh>clear</vh></v>
<v t="karstenw.20260127160816.16"><vh>apply</vh></v>
<v t="karstenw.20260127160816.17"><vh>copy</vh></v>
</v>
<v t="karstenw.20260127160816.18"><vh>class spacing</vh>
<v t="karstenw.20260127160816.19"><vh>__init__</vh></v>
<v t="karstenw.20260127160816.20"><vh>copy</vh></v>
<v t="karstenw.20260127160816.21"><vh>_get_l</vh></v>
<v t="karstenw.20260127160816.22"><vh>_get_t</vh></v>
<v t="karstenw.20260127160816.23"><vh>_get_r</vh></v>
<v t="karstenw.20260127160816.24"><vh>_get_b</vh></v>
<v t="karstenw.20260127160816.25"><vh>_set_l</vh></v>
<v t="karstenw.20260127160816.26"><vh>_set_t</vh></v>
<v t="karstenw.20260127160816.27"><vh>_set_r</vh></v>
<v t="karstenw.20260127160816.28"><vh>_set_b</vh></v>
</v>
<v t="karstenw.20260127160816.29"><vh>class background</vh>
<v t="karstenw.20260127160816.30"><vh>__init__</vh></v>
<v t="karstenw.20260127160816.31"><vh>copy</vh></v>
<v t="karstenw.20260127160816.32"><vh>_get_align</vh></v>
<v t="karstenw.20260127160816.33"><vh>_set_align</vh></v>
<v t="karstenw.20260127160816.34"><vh>gradientfill</vh></v>
<v t="karstenw.20260127160816.35"><vh>draw</vh></v>
</v>
<v t="karstenw.20260127160816.36"><vh>class style</vh>
<v t="karstenw.20260127160816.37"><vh>__init__</vh></v>
<v t="karstenw.20260127160816.38"><vh>copy</vh></v>
<v t="karstenw.20260127160816.39"><vh>_get_background</vh></v>
<v t="karstenw.20260127160816.40"><vh>_set_background</vh></v>
<v t="karstenw.20260127160816.41"><vh>_get_strokewidth</vh></v>
<v t="karstenw.20260127160816.42"><vh>_set_strokewidth</vh></v>
<v t="karstenw.20260127160816.43"><vh>_get_margin</vh></v>
<v t="karstenw.20260127160816.44"><vh>_set_margin</vh></v>
<v t="karstenw.20260127160816.45"><vh>_get_padding</vh></v>
<v t="karstenw.20260127160816.46"><vh>_set_padding</vh></v>
<v t="karstenw.20260127160816.47"><vh>_get_align</vh></v>
<v t="karstenw.20260127160816.48"><vh>_set_align</vh></v>
</v>
<v t="karstenw.20260127160816.49"><vh>alignment</vh></v>
<v t="karstenw.20260127160816.50"><vh>rect</vh></v>
<v t="karstenw.20260127160816.51"><vh>begin_grob</vh></v>
<v t="karstenw.20260127160816.52"><vh>end_grob</vh></v>
<v t="karstenw.20260127160816.53"><vh>draw_background</vh></v>
<v t="karstenw.20260127160816.54"><vh>draw_content</vh></v>
<v t="karstenw.20260127160816.55"><vh>draw_stroke</vh></v>
<v t="karstenw.20260127160816.56"><vh>draw_text</vh></v>
<v t="karstenw.20260127160816.57"><vh>draw_image</vh></v>
</v>
<v t="karstenw.20260127161628.1"><vh>@clean text.py</vh>
<v t="karstenw.20260127161638.1"><vh>Declarations</vh></v>
<v t="karstenw.20260127161814.1"><vh>symbols</vh></v>
<v t="karstenw.20260127161638.2"><vh>superscript</vh></v>
<v t="karstenw.20260127161638.3"><vh>class _placeholder</vh>
<v t="karstenw.20260127161638.4"><vh>__init__</vh></v>
<v t="karstenw.20260127161638.5"><vh>sentence</vh></v>
<v t="karstenw.20260127161638.6"><vh>paragraph</vh></v>
<v t="karstenw.20260127161638.7"><vh>text</vh></v>
<v t="karstenw.20260127161638.8"><vh>kant</vh></v>
</v>
<v t="karstenw.20260127161638.9"><vh>keep_together</vh></v>
<v t="karstenw.20260127161638.10"><vh>split</vh></v>
<v t="karstenw.20260127161638.11"><vh>divide</vh></v>
<v t="karstenw.20260127161638.12"><vh>legible_width</vh></v>
<v t="karstenw.20260127161638.13"><vh>fit_fontsize</vh></v>
<v t="karstenw.20260127161638.14"><vh>fit_lineheight</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="karstenw.20260127160246.2"></t>
<t tx="karstenw.20260127160303.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20260127160317.1">### CREDITS ###################################################################

# Copyright (c) 2008 Tom De Smedt.
# See LICENSE.txt for details.

__author__    = "Tom De Smedt"
__version__   = "1.9.4.2"
__copyright__ = "Copyright (c) 2008 Tom De Smedt"
__license__   = "GPL"

### NODEBOX GRID ###############################################################

# The NodeBox Grid library offers a number of tools to work with rows and
# columns in a page layout.
#
# It's like having a combination of InDesign and Excel available in NodeBox.
# You can use the library to generate flowing columns of text and image grids,
# automatically apply aesthetic proportions between cells in the grid, create
# spreadsheet tables with (simple) statistics, define reusable visual styles
# in a CSS-like way.
#
# Numerous of text commands help you for example determine good, legible column
# widths, apply widow/orphan control to paragraphs, generate lorem ipsum
# placeholder text.
#
# Central concepts in this library are:
#
# * Grid: rows and columns containing cells. Each cell can be a new grid.
# * Content: a text or a list of images that is divided among the rows and
# *          columns in a grid.
# * Proportion: aesthetic relations between the cells in a grid.
# * Style: a description of colors, typography, whitespace that can be
# *        attached to cells.
#
# The library has a caching mechanism that allows you to create multi-page
# documents (e.g. a book), keeping track of the text and images that have
# already been drawn along the way.

###############################################################################

from importlib import reload

from . import proportion as _proportion
from . import content as _content
from . import style
from . import text

from random import random, shuffle
from types import MethodType, FunctionType
from math import sqrt

</t>
<t tx="karstenw.20260127160317.10">def legible_width(txt, chars=70):
    _update_text_ctx()
    return text._legible_width(txt, width, height, keep)

</t>
<t tx="karstenw.20260127160317.100">def _set_cols(self, v) : self.columns = v
cols = property(_get_cols, _set_cols)

</t>
<t tx="karstenw.20260127160317.101">def _get_relative_width(self):
    if self.parent == None:
        return 1.0
    else:
        return self._width
</t>
<t tx="karstenw.20260127160317.102">def _get_relative_height(self):
    if self.parent == None:
        return 1.0
    else:
        return self._height

</t>
<t tx="karstenw.20260127160317.103">def _set_relative_width(self, v):
    if self.parent == None:
        self._width *= v
    else:
        self.parent.column(self).relative_width = v

</t>
<t tx="karstenw.20260127160317.104">def _set_relative_height(self, v):
    if self.parent == None:
        self._height *= v
    else:
        self.parent.row(self).relative_height = v

relative_width = property(_get_relative_width, _set_relative_width)
relative_height = property(_get_relative_height, _set_relative_height)

</t>
<t tx="karstenw.20260127160317.105">def _get_width(self):
    """ The absolute width of a cell nested in a grid.
    Multiply the relative widths of all parent grids up to the root container.
    """
    if self.parent == None:
        return self._width
    else:
        return self._width * self.parent.width

</t>
<t tx="karstenw.20260127160317.106">def _get_height(self):
    if self.parent == None:
        return self._height
    else:
        return self._height * self.parent.height

</t>
<t tx="karstenw.20260127160317.107">def _set_width(self, v):
    """ The top-level grid's width can be adjusted directly.
    Otherwise, adjust the width of the entire column this grid cell is in.
    """
    if self.parent == None:
        self._width = v
    else:
        if self._width == 0:
            v = float(v) / self.parent.width
        else:
            v *= self._width / self.width
        self.parent.column(self).relative_width = v

</t>
<t tx="karstenw.20260127160317.108">def _set_height(self, v):
    if self.parent == None:
        self._height = v
    else:
        if self._width == 0:
            v = float(v) / self.parent.width
        else:
            v *= self._height / self.height
        self.parent.row(self).relative_height = v

width  = property(_get_width, _set_width)
height = property(_get_height, _set_height)

</t>
<t tx="karstenw.20260127160317.109">def size(self, w, h, fixed=False, relative=False):
    """ Sets the width and height of the cell, adjusting the width and
    height of the other cells in the grid.
    Fixed cells are not adjusted (i.e. they always retain the size you
    gave them).
    """
    self.fixed = fixed
    if relative:
        self.relative_width = w
        self.relative_height = h
    else:
        self.width = w
        self.height = h

</t>
<t tx="karstenw.20260127160317.11">def fit_fontsize(str, width, height):
    _update_text_ctx()
    return text._fit_fontsize(str, width, height)

text.keep_together = keep_together
text.split = split
text.divide = divide
text.legible_width = legible_width
text.fit_fontsize = fit_fontsize

</t>
<t tx="karstenw.20260127160317.110">def _get_x(self):
    """ Returns the absolute horizontal position of the column a cell is in.
    """
    x = 0
    if self.parent != None:
        x += self.parent.x
        for cell in self.parent.row(self):
            if cell == self: break
            x += cell.width
    return x

</t>
<t tx="karstenw.20260127160317.111">def _get_y(self):
    """ Returns the absolute vertical position of the row a cell is in.
    """
    y = 0
    if self.parent != None:
        y += self.parent.y
        for cell in self.parent.column(self):
            if cell == self: break
            y += cell.height
    return y

x = property(_get_x)
y = property(_get_y)

</t>
<t tx="karstenw.20260127160317.112">def _get_styles(self):
    """ All grid cells refer to the styles object in the root grid.
    """
    if self.parent != None:
        return self.parent.styles
    else:
        return self._styles

</t>
<t tx="karstenw.20260127160317.113">def _set_styles(self, v):
    if self.parent != None:
        self.parent.styles = v
    else:
        self._styles = v

styles = property(_get_styles, _set_styles)

</t>
<t tx="karstenw.20260127160317.114">def  has_style(self) : return (self._style != None)
</t>
<t tx="karstenw.20260127160317.115">def _set_style(self, v): self._style = v
</t>
<t tx="karstenw.20260127160317.116">def _get_style(self):
    """
    Grid cells with no style defined inherit the style of the parent grid.
    When the parent's style is not delegated to child cells, assume the
    "default" style.
    """
    if self._style == None and self.parent != None:
        if not self.styles[self.parent.style].delegate:
            return "default"
        return self.parent.style
    else:
        return self._style

style = property(_get_style, _set_style)

</t>
<t tx="karstenw.20260127160317.117">def  has_content(self):
    return isinstance(self._content, _content.content)

</t>
<t tx="karstenw.20260127160317.118">def _set_content(self, v) :
    self._content = content(v)
    self._content.parent = self

</t>
<t tx="karstenw.20260127160317.119">def _get_content(self):
    """
    Grid cells with no content defined inherit the content of the parent grid.
    """
    if not self.has_content() and self.parent != None:
        return self.parent.content
    else:
        return self._content

content = value = property(_get_content, _set_content)

# The size of the content is the size of the grid,
# minus margin and padding.

</t>
<t tx="karstenw.20260127160317.12">### CONTENT ###################################################################
# This content() wrapper makes more sense than calling
# content.content(_ctx, data) directly.

def content(data):
    if isinstance(data, _content.content):
        return data
    return _content.content(_ctx, data)

</t>
<t tx="karstenw.20260127160317.120">def _content_width(self):
    s  = self.styles[self.style]
    w  = self.width
    w -= s.margin.left
    w -= s.margin.right
    w -= s.padding.left
    w -= s.padding.right
    return w
content_width = property(_content_width)

</t>
<t tx="karstenw.20260127160317.121">def _content_height(self):
    s  = self.styles[self.style]
    h  = self.height
    h -= s.margin.top
    h -= s.margin.bottom
    h -= s.padding.top
    h -= s.padding.bottom
    return h
content_height = property(_content_height)

</t>
<t tx="karstenw.20260127160317.122">def flow_vertical(self, recursive=True):
    """
    Sets the flow so that the grid is filled with content columns-first.
    """
    for column in self.columns:
        for cell in column:
            self.flow.append(cell)
            if recursive:
                cell.flow_vertical(recursive)

</t>
<t tx="karstenw.20260127160317.123">def flow_horizontal(self, recursive=True):
    """ Sets the flow so that the grid is filled with content rows-first.
    """
    for row in self.rows:
        for cell in row:
            self.flow.append(cell)
            if recursive:
                cell.flow_horizontal(recursive)

</t>
<t tx="karstenw.20260127160317.124">def _reset(self):
    """ Resets the visited flag on this grid.
    """
    self._visited = False
    for cell in self:
        cell._reset()

</t>
<t tx="karstenw.20260127160317.125">def _traverse(self, visit, leave):
    """
    Visits cell, traverses the contained cells, leaves and sets visited flag.
    """
    visit(self)
    # If a flow has been defined, visit those cells first.
    # (i.e. they are filled with content before the others).
    for cell in self.flow:
        if isinstance(cell, grid) and not cell._visited:
            cell._traverse(visit, leave)
        if isinstance(cell, (row, column)):
            for cell in cell:
                if not cell._visited:
                    cell._traverse(visit, leave)
    # By default, visit cells columns-first.
    for column_ in self.columns:
        for cell in column_:
            if not cell._visited:
                cell._traverse(visit, leave)
    leave(self)
    self._visited = True

</t>
<t tx="karstenw.20260127160317.126">def traverse(self, visit=lambda cell: None, leave=lambda cell: None):
    """ Resets visited flags and recurses cells.
    """
    self._reset()
    self._traverse(visit, leave)

</t>
<t tx="karstenw.20260127160317.127">def draw(self, x=0, y=0):
    """ Traverses the grid and draws each cell in the right style.
    """
    def visit(self):
        # Use this cell's style to draw it.
        # Some things get drawn when we leave the cell (clipping mask, border).
        # We store "the things" in self._state so we can reuse them in leave().
        try: s = self.styles[self.style]
        except KeyError:
            raise KeyError( "no style with name '"+self.style+"'" )
        self._state = style.begin_grob(s, self, 0, 0)
    def leave(self):
        s = self.styles[self.style]
        style.end_grob(s, self, *self._state)
    _ctx.push()
    _ctx.translate(x, y)
    self._drawn = (x, y) # used in grid.highlight()
    self.traverse(visit, leave)
    _ctx.pop()

# Content gets distributed to child cells when the grid is drawn.
# This should happen at the moment when content is added.
</t>
<t tx="karstenw.20260127160317.128">def distribute(self, explicit=True):
    """ Distributes content to cells than can be drawn (i.e. have no child cells).
    In explicit mode, container grids will no longer contain content.
    """
    def visit(self):
        # Am I a cell which inherits its content from a parent grid?
        if len(self) == 0 and not self.has_content() and self.content != None:
            try: s = self.styles[self.style]
            except KeyError:
                raise( KeyError, "no style with name '"+self.style+"'" )
            _ctx.font(s.font, s.fontsize)
            _ctx.lineheight(s.lineheight)
            _ctx.align(style.alignment(s.horizontal))
            c = self.content.next(self.content_width, self.content_height)
            self.content = content(c)
            self.content._distributed = True
    self.traverse(leave=visit)
    # All content has now been distributed to drawable cells.
    # In explicit mode, container grids may no longer contain content.
    def commit(self):
        if len(self) &gt; 0:
            self._content = content(None)
    def rebuild(self):
        if self.content.is_text() and self.parent:
            if self.parent.content == None:
                self.parent.content = self.content.copy()
            else:
                self.parent.content += " "
                self.parent.content += self.content

    if explicit:
        self.traverse(commit, rebuild)

</t>
<t tx="karstenw.20260127160317.129">def create(rows=1, columns=1, width=None, height=None, parent=None, name=""):
    return grid(rows, columns, width, height, parent, name)

</t>
<t tx="karstenw.20260127160317.13">### PROPORTION ################################################################

def proportion(distribution=_proportion.PROPORTION_EVEN,
               sorted=False,
               reversed=False,
               shuffled=False,
               mirrored=False,
               repetition=1,
               n=None):
    p = _proportion.proportion(n,
                               distribution,
                               sorted,
                               reversed,
                               shuffled,
                               mirrored,
                               repetition)
    p._ctx = _ctx
    return p

</t>
<t tx="karstenw.20260127160317.130">#### CACHE ####################################################################
# A hack to facilitate exporting multiple pages of grids.
# A grid can temporarily be saved, as long as the grid library is not reloaded.
# You can then reload it for the next export, with the next content being drawn.
# This only works in the same NodeBox window:
# you cannot juggle grids between different drawing contexts.

def save(grid):
    _content._saved_grid = grid

</t>
<t tx="karstenw.20260127160317.131">def load():
    try: g = _content._saved_grid
    except:
        return None
    if g.styles._ctx != _ctx:
        return None
    return g

</t>
<t tx="karstenw.20260127160317.132">#### HIGHLIGHT ################################################################

def highlight(grid, clr=None, recursive=False, _label="", _group=False):

    """ Highlights nested cells in the given grid, row or column.
    Displays the index to append to the given grid to get that cell.
    """

    def _draw_label(label, x, y):
        _ctx.font("Verdana", 9)
        w = _ctx.textwidth(label)
        _ctx.nostroke()
        _ctx.fill(0, 0.3)
        _ctx.rect(x+2, y+2, w+10, _ctx.fontsize()+10) #dropshadow
        _ctx.fill(clr)
        _ctx.rect(x, y, w+10, _ctx.fontsize()+10)
        _ctx.fill(0)
        _ctx.text(label, x+5, y+_ctx.fontsize()+5)

    # When a column or row is supplied,
    # traverse all the grid objects in it and highlight them.
    if isinstance(grid, (column, row)):
        for i in range(len(grid)):
            highlight(grid[i],
                      clr,
                      recursive,
                      _label="[" + str(i) + "]",
                      _group=True)
        return

    if clr == None:
        clr = _ctx.color(1, 0, 0)

    _ctx.push()
    try:
        # The grid.draw() has parameters x and y,
        # which define an offset for the grid.
        # Retrieve it so the highlight appears neatly on top.
        dx, dy = grid.root._drawn
    except:
        dx, dy = 0, 0

    # 1) The root grid is highlighted with a thick edge.
    # 2) Each root grid in a column or row is highlighted with a thick edge.
    # 3) Recursively nested grids get a thin edge.
    if _label == "":
        _ctx.translate(dx, dy)
        _ctx.strokewidth(5)
    elif _group:
        _ctx.translate(dx, dy)
        _ctx.strokewidth(5)
        _draw_label(_label, grid.x, grid.y)
    else:
        _ctx.strokewidth(1)
        _draw_label(_label, grid.x, grid.y)
    _ctx.stroke(clr)
    _ctx.nofill()
    _ctx.rect(grid.x, grid.y, grid.width, grid.height)

    # Label each nested cell.
    # When recursive, call highlight() on each cell.
    for i in range(len(grid.rows)):
        for j in reversed(range(len(grid.rows[i]))):
            cell = grid.rows[i][j]
            label = _label+"("+str(i)+","+str(j)+")"
            if not recursive:
                _draw_label(label, cell.x, cell.y)
            _ctx.strokewidth(1)
            _ctx.stroke(clr)
            _ctx.nofill()
            _ctx.rect(cell.x, cell.y, cell.width, cell.height)
            if recursive:
                highlight(cell, clr, recursive, label)

    _ctx.pop()

</t>
<t tx="karstenw.20260127160317.14">#### SPLITTER MIXIN ###########################################################
# Offers a verbose way of retrieving nested grids.

class splitter:

    @others
</t>
<t tx="karstenw.20260127160317.15">def _jump(self, list):
    # If the row or column has only one cell, reference this cell directly.
    if len(list) == 1: return list[0]
    return list

</t>
<t tx="karstenw.20260127160317.16">def _first(self)  : return self._jump(self[0])
</t>
<t tx="karstenw.20260127160317.17">def _second(self) : return self._jump(self[1])
</t>
<t tx="karstenw.20260127160317.18">def _third(self)  : return self._jump(self[2])
</t>
<t tx="karstenw.20260127160317.19">def _fourth(self) : return self._jump(self[3])
</t>
<t tx="karstenw.20260127160317.2">### UNIQUE ID #################################################################

__unique_id = 0
def _unique_id():
    """ Never returns the same integer.
    """
    global __unique_id
    __unique_id += 1
    return __unique_id

</t>
<t tx="karstenw.20260127160317.20">def _fifth(self)  : return self._jump(self[4])
</t>
<t tx="karstenw.20260127160317.21">def _sixth(self)  : return self._jump(self[5])

</t>
<t tx="karstenw.20260127160317.22">def _top(self)    : return self._jump(self.row(0))
</t>
<t tx="karstenw.20260127160317.23">def _left(self)   : return self._jump(self.col(0))
</t>
<t tx="karstenw.20260127160317.24">def _bottom(self) : return self._jump(self.row(-1))
</t>
<t tx="karstenw.20260127160317.25">def _right(self)  : return self._jump(self.col(-1))

first  = property(_first)
second = property(_second)
third  = property(_third)
fourth = property(_fourth)
fifth  = property(_fifth)
sixth  = property(_sixth)

top    = property(_top)
left   = property(_left)
bottom = property(_bottom)
right  = property(_right)

</t>
<t tx="karstenw.20260127160317.26">#### STATISTICS MIXIN #########################################################
# Offers simple math statistics on rows and columns.

class statistics(object):

    @others

</t>
<t tx="karstenw.20260127160317.27">def _count(self):
    """ Counts the number of cells.
    """
    return len(self)
count = property(_count)

</t>
<t tx="karstenw.20260127160317.28">def _used(self):
    """ Counts the cells that have content.
    """
    return len( list(filter(lambda cell: cell.has_content(), self)) )
used = property(_used)

</t>
<t tx="karstenw.20260127160317.29">def _empty(self):
    return len(self) - self.used
empty = property(_empty)

</t>
<t tx="karstenw.20260127160317.3">### FORMAT ####################################################################
# Useful paper formats.

class format:

    @others
format = format()

</t>
<t tx="karstenw.20260127160317.30">def _numeric(self):
    """ Counts the cells that have numeric content.
    """
    return filter(lambda cell: cell.has_content()
                               and cell.content.is_numeric(), self)
numeric = property(_numeric)

</t>
<t tx="karstenw.20260127160317.31">def _numbers(self):
    """ Returns a list of numerical content found in the cells.
    """
    return [float(cell.content) for cell in self.numeric]
numbers = property(_numbers)

</t>
<t tx="karstenw.20260127160317.32">def _sum(self):
    return sum(self.numbers)
sum = property(_sum)

</t>
<t tx="karstenw.20260127160317.33">def _avg(self):
    return self.sum / len(self.numeric)
mean = average = avg = property(_avg)

</t>
<t tx="karstenw.20260127160317.34">def _min(self):
    return min(self.numbers)
min = property(_min)

</t>
<t tx="karstenw.20260127160317.35">def _max(self):
    return max(self.numbers)
max = property(_max)

</t>
<t tx="karstenw.20260127160317.36">def _variance(self):
    avg = self.avg
    return sum([(x-avg)**2 for x in self.numbers]) / (len(self.numeric)-1)
variance = property(_variance)

</t>
<t tx="karstenw.20260127160317.37">def _stdev(self):
    return sqrt(self.variance)
stdev = property(_stdev)

</t>
<t tx="karstenw.20260127160317.38">#### ROWS AND COLUMNS #########################################################
class rows(list, splitter):
    @others
</t>
<t tx="karstenw.20260127160317.39">def row(self, i):
    return self[i]

</t>
<t tx="karstenw.20260127160317.4">def __init__(self):
    self.A4 = (595.2765,     841.89105)
    self.A3 = (self.A4[0]*2, self.A4[1])
    self.A2 = (self.A3[0],   self.A3[1]*2)
    self.A1 = (self.A2[0]*2, self.A2[1])
    self.A0 = (self.A1[0],   self.A1[1]*2)
    self.A5 = (self.A4[0],   self.A4[1]/2)
    self.A6 = (self.A5[0]/2, self.A5[1])
    self.A7 = (self.A6[0],   self.A6[1]/2)
    self.A8 = (self.A7[0]/2, self.A7[1])
    self.C5 = (self.A6[1],   self.A6[0])
    self.page     = self.A4
    self.poster   = self.A2
    self.envelope = self.C5
    self.letter   = (612.2736, 790.8534)
    self.legal    = (612.2736, 1009.1176)

</t>
<t tx="karstenw.20260127160317.40">class columns(list, splitter):
    @others
cols = columns

</t>
<t tx="karstenw.20260127160317.41">def column(self, i):
    return self[i]
col = column
</t>
<t tx="karstenw.20260127160317.42">#--- CELLS --------------------------------------------------------------------
# Parent class for row and column.

class cells(list, splitter, statistics):

    @others

</t>
<t tx="karstenw.20260127160317.43">def __init__(self, data=[], parent=None):
    list.__init__(self, data)
    self._id = _unique_id()
    self.parent = parent
    self.name = ""

</t>
<t tx="karstenw.20260127160317.44">def __eq__(self, other):
    return self._id == other._id

</t>
<t tx="karstenw.20260127160317.45">def __add__(self, other):
    return cells(list.__add__(self, other))

</t>
<t tx="karstenw.20260127160317.46">def __getslice__(self, i, j):
    """ A slice is a cells object too: you can do statistics and splitting on it.
    """
    slice = list(self)[i:j]
    return cells(slice)

</t>
<t tx="karstenw.20260127160317.47">def _get_property(self, k):
    """ Returns the property of this row
    if all the cells have the same property, None otherwise.
    """
    p = getattr(self[0], k)
    for cell in self:
        if getattr(cell, k) != p: return None
    return p

</t>
<t tx="karstenw.20260127160317.48">def _set_property(self, k, v):
    for cell in self: setattr(cell, k, v)

</t>
<t tx="karstenw.20260127160317.49">def _get_root(self): return self._get_property("root")
root = property(_get_root)

</t>
<t tx="karstenw.20260127160317.5">def __call__(self, format):
    if hasattr(self, format):
        return getattr(self, format)

</t>
<t tx="karstenw.20260127160317.50">def _get_styles(self): return self._get_property("styles")
style = property(_get_styles)

</t>
<t tx="karstenw.20260127160317.51">def _get_style(self)    : return self._get_property("style")
</t>
<t tx="karstenw.20260127160317.52">def _set_style(self, v) : self._set_property("style", v)
style = property(_get_style, _set_style)

</t>
<t tx="karstenw.20260127160317.53">def _get_content(self)    : return self._get_property("content")
</t>
<t tx="karstenw.20260127160317.54">def _set_content(self, v) : self._set_property("content", content(v))
content = value = property(_get_content, _set_content)

</t>
<t tx="karstenw.20260127160317.55">def _get_content_width(self)  : return self._get_property("content_width")
</t>
<t tx="karstenw.20260127160317.56">def _get_content_height(self) : return self._get_property("content_height")
content_width  = property(_get_content_width)
content_height = property(_get_content_height)

</t>
<t tx="karstenw.20260127160317.57">def _get_width(self)    : return self._get_property("width")
</t>
<t tx="karstenw.20260127160317.58">def _set_width(self, v) : self._set_property("width", v)
width = property(_get_width, _set_width)

</t>
<t tx="karstenw.20260127160317.59">def _get_height(self)    : return self._get_property("height")
</t>
<t tx="karstenw.20260127160317.6">### TEXT ######################################################################
# Rewire the functions in the text module that need a drawing context.


reload(text)
text._keep_together = text.keep_together
text._split = text.split
text._divide = text.divide
text._legible_width = text.legible_width
text._fit_fontsize = text.fit_fontsize

def _update_text_ctx():
    text._ctx = _ctx

</t>
<t tx="karstenw.20260127160317.60">def _set_height(self, v) : self._set_property("height", v)
height = property(_get_height, _set_height)

</t>
<t tx="karstenw.20260127160317.61">def _get_fixed(self)    : return self._get_property("fixed")
</t>
<t tx="karstenw.20260127160317.62">def _set_fixed(self, v) : self._set_property("fixed", v)
fixed = property(_get_fixed, _set_fixed)

</t>
<t tx="karstenw.20260127160317.63">def _get_x(self): return 0
</t>
<t tx="karstenw.20260127160317.64">def _get_y(self): return self._get_property("y")
x = property(_get_x)
y = property(_get_y)

</t>
<t tx="karstenw.20260127160317.65">def flow_horizontal(self, recursive=True):
    for cell in self:
        cell.flow_horizontal(recursive)

</t>
<t tx="karstenw.20260127160317.66">def flow_vertical(self, recursive=True):
    for cell in self:
        cell.flow_vertical(recursive)

</t>
<t tx="karstenw.20260127160317.67">#--- ROW ----------------------------------------------------------------------
class row(cells):

    @others

</t>
<t tx="karstenw.20260127160317.68">def column(self, i):
    if i &lt; 0: i = len(self) + i
    return self[i]

cell = col = column

</t>
<t tx="karstenw.20260127160317.69">def _get_relative_width(self)    : return self.parent.relative_width
</t>
<t tx="karstenw.20260127160317.7">def keep_together(str1, str2, width, widows=1, orphans=1, forward=False):
    _update_text_ctx()
    return text._keep_together(str1, str2, width, widows, orphans, forward)

</t>
<t tx="karstenw.20260127160317.70">def _set_relative_width(self, v) : self.parent.relative_width = v
relative_width = property(_get_relative_width, _set_relative_width)

</t>
<t tx="karstenw.20260127160317.71">def _get_relative_height(self):
    return self._get_property("_height")

</t>
<t tx="karstenw.20260127160317.72">def _set_relative_height(self, v):
    """ Adjusts the height (0.0-1.0) of the cells in the row.
    The height of other rows is evenly adjusted,
    except that rows containing fixed cells are left untouched.
    """
    p = self[0].parent
    fluid = [row for row in p.rows if not row.fixed and row != self]
    if len(fluid) &gt; 0:
        d = (v-self._height) / len(fluid)
    for row in fluid:
        for cell in row:
            cell._height -= d
    for cell in self:
        cell._height = v

relative_height = _height = property(_get_relative_height,
                                     _set_relative_height)

</t>
<t tx="karstenw.20260127160317.73">#--- COLUMN -------------------------------------------------------------------
class column(cells):

    @others

</t>
<t tx="karstenw.20260127160317.74">def row(self, i):
    if i &lt; 0: i = len(self) + i
    return self[i]

cell = row

</t>
<t tx="karstenw.20260127160317.75">def _get_relative_height(self)    : return self.parent.relative_height
</t>
<t tx="karstenw.20260127160317.76">def _set_relative_height(self, v) : self.parent.relative_height = v
relative_height = property(_get_relative_height, _set_relative_height)

</t>
<t tx="karstenw.20260127160317.77">def _get_relative_width(self):
    return self._get_property("_width")

</t>
<t tx="karstenw.20260127160317.78">def _set_relative_width(self, v):
    """ Adjusts the width (0.0-1.0) of the cells in the column.
    The width of other columns is evenly adjusted,
    except that columns containing fixed cells are left untouched.
    """
    p = self[0].parent
    fluid = [col for col in p.cols if not col.fixed and col != self]
    if len(fluid) &gt; 0:
        d = (v-self._width) / len(fluid)
    for col in fluid:
        for cell in col:
            cell._width -= d
    for cell in self:
        cell._width = v

relative_width = _width = property(_get_relative_width, _set_relative_width)

</t>
<t tx="karstenw.20260127160317.79">#### GRID #####################################################################
class grid(list, splitter, statistics):

    @others

</t>
<t tx="karstenw.20260127160317.8">def split(txt, width, height, widows=1, orphans=1, forward=True):
    _update_text_ctx()
    return text._split(txt, width, height, widows, orphans, forward)

</t>
<t tx="karstenw.20260127160317.80">def __init__(self, rows=1, columns=1,
                   width=None, height=None,
                   parent=None, name=""):

    """ A grid of rows and columns of cells, which are grids themselves.
    """

    self._id = _unique_id()
    self.parent = parent
    self.name = name

    # By default, a grid has the width and height of its parent,
    # or the canvas width and height if there is no parent.
    if width == None:
        if self.parent == None:
            width = _ctx.WIDTH
        else:
            width = 1.0
    if height == None:
        if self.parent == None:
            height = _ctx.HEIGHT
        else:
            height = 1.0
    self._width = width
    self._height = height
    self.fixed = False

    # Styling and content.
    if parent == None:
        self._styles = style.styles(_ctx, self)
        self._style = "default"
    else:
        self._styles = None
        self._style = None
    self._content = None

    # The proportion between the cells in the grid.
    self._proportion = proportion()
    self.clear()
    self.split(rows, columns)

    # The order in which cells are drawn.
    self.flow = []
    self._done = False

</t>
<t tx="karstenw.20260127160317.81">def _get_proportion(self):
    return self._proportion
</t>
<t tx="karstenw.20260127160317.82">def _set_proportion(self, v):
    """ Sets the proportions of row height and column width in the grid.
    You can supply a single proportion object or a tuple (one for rows
    and one for columns).
    """
    if isinstance(v, str): v = proportion(distribution=v)
    if isinstance(v, tuple):
        h, v = v
        if isinstance(h, str): h = proportion(distribution=h)
        if isinstance(v, str): v = proportion(distribution=v)
        v = (h, v)
    self._proportion = v
    self.split(len(self.rows), len(self.columns))

proportion = property(_get_proportion, _set_proportion)

</t>
<t tx="karstenw.20260127160317.83">def arrange(self, horizontal, vertical=None):
    h, v = horizontal, vertical
    if v == None: v = h
    self.proportion = (h, v)

</t>
<t tx="karstenw.20260127160317.84">def clear(self):
    """ Clear cell data whilst retaining style and proportion.
    """
    list.__init__(self, [])
    self.rows = rows()
    self.columns = columns()
    self.flow = []

</t>
<t tx="karstenw.20260127160317.85">def split(self, y, x, proportion=None, style=None):

    """ Splits the grid into different cells, each of which is a new grid.
    Existing rows and columns of cells are retained if possible.
    """

    # y =&gt; the number of rows
    # x =&gt; the number of columns

    if proportion != None:
        self.proportion = proportion

    y, x = max(1, y), max(1, x)
    if y * x &lt;= 1:
        self.clear()
        return

    # Append new rows of cells to the bottom of the grid.
    # Append new columns of cells to the right of the grid.
    n, m = len(self.rows), len(self.columns)
    if m == 0:
        m = x
    for i in range(y-n):
        for j in range(m):
            g = grid(parent=self, name="cell_"+str(n+i)+str(j))
            list.append(self, g)
    for j in range(x-m):
        for i in range(y):
            g = grid(parent=self, name="cell_"+str(y-i-1)+str(m+j))
            list.insert(self, (y-i)*(m+j), g)

    # Delete excess rows of cells from the bottom of the grid.
    # Delete excess columns of cells from the right of the grid.
    n, m = len(self.rows), len(self.columns)
    for i in range(n-y):
        for j in range(m):
            del self[-1]
    for i in range(y):
        for j in range(m-x):
            del self[(y-i)*m-j-1]

    # Organize the cells into row and column objects.
    self.rows, self.columns = rows(), columns()
    for i in range(y):
        self.rows.append(
            row([self[i*x+j] for j in range(x)], parent=self))
    for i in range(x):
        self.columns.append(
            column([self[i+j*x] for j in range(y)], parent=self))

    # Based on the grid's proportion object,
    # which is for example a list of logarithmic numbers whose sum is 1.0,
    # assign a width to each column, and a height to each row.
    # Three columns would be sized 17%, 33% and 50% of the parent's width.
    if isinstance(self._proportion, tuple):
        h, v = self._proportion
    else:
        h = self._proportion
        v = self._proportion.copy()
    h.repetition = min(x, h.repetition)
    v.repetition = min(y, v.repetition)
    h.generate(x)
    v.generate(y)
    for i in range(y):
        for j in range(x):
            self[i*x+j]._width = h[j]
            self[i*x+j]._height = v[i]

    # Set the style of all the cells in the grid,
    # but not that of this parent grid.
    if style != None:
        for cell in self:
            cell.style = style

    # The flow is always reset.
    self.flow = []
    return self

</t>
<t tx="karstenw.20260127160317.86">def update(self):
    self.split(len(self.rows), len(self.columns))

</t>
<t tx="karstenw.20260127160317.87">def _get_root(self):
    if self.parent == None:
        return self
    return self.parent.root

root = property(_get_root)

</t>
<t tx="karstenw.20260127160317.88">def flatten(self, containers=False):
    """ Returns a flat list of all cells in the grid.
    If containers is False, grids with further child cells are not included
    themselves.
    """
    if containers or len(self) &lt;= 1:
        all = [self]
    else:
        all = []
    for cell in self:
        all += cell.flatten(containers)
    return all

all = flatten

</t>
<t tx="karstenw.20260127160317.89">def copy(self, parent=None):

    """ Returns a deep copy of the grid.
    """

    # Copy content, proportion, styles, current style.
    g = grid(1, 1, self._width, self._height, parent, self.name)
    if self._content:
        g._content = self._content.copy(parent=g)
    if self._proportion:
        g._proportion = self._proportion.copy()
    if self._styles:
        g._styles = self._styles.copy(g)
    g.style = self.style

    # A map of cell/column/row id's linking to their copy.
    # This is used to easily copy a grid's flow.
    map = {}

    # Copy rows and columns.
    for x in self.rows:
        g.rows.append(row(parent=g))
        map[x._id] = g.rows[-1]
    for x in self.cols:
        g.cols.append(column(parent=g))
        map[x._id] = g.cols[-1]

    # Copy all the cells in this grid.
    # Put each of the cells in the right row/column.
    for cell1 in self:
        cell2 = cell1.copy(parent=g)
        g.append(cell2)
        map[cell1._id] = cell2
        for i in range(len(self.rows)):
            if cell1 in self.rows[i]:
                g.rows[i].append(cell2)
        for i in range(len(self.cols)):
            if cell1 in self.cols[i]:
                g.cols[i].append(cell2)

    for x in self.flow:
        g.flow.append(map[x._id])

    return g

</t>
<t tx="karstenw.20260127160317.9">def divide(txt, width, height, keep=1):
    _update_text_ctx()
    return text._divide(txt, width, height, keep)

</t>
<t tx="karstenw.20260127160317.90">def __repr__(self):
    """ Represent as a list when it has rows and columns, with its name otherwise.
    """
    if len(self) &gt; 1:
        return list.__repr__(self)
    else:
        return self.name

</t>
<t tx="karstenw.20260127160317.91">def __eq__(self, other):
    """ Compares two grids based on their unique id's.
    This happens when retrieving a cell's index in a parent grid for example.
    """
    if not isinstance(other, grid): return False
    return self._id == other._id

</t>
<t tx="karstenw.20260127160317.92">def __ne__(self, other):
    return not self.__eq__(other)

</t>
<t tx="karstenw.20260127160317.93">def find(self, name):
    """ Returns a cell, row or column by name.
    """
    for cell in self.flatten(containers=True):
        if cell.name == name:
            return cell
    for row in self.rows:
        if row.name == name:
            return row
    for col in self.cols:
        if col.name == name:
            return col

</t>
<t tx="karstenw.20260127160317.94">def __getattr__(self, name):
    x = self.find(name)
    if x != None: return x
    raise AttributeError( "grid instance has no attribute '%s'" % name )

</t>
<t tx="karstenw.20260127160317.95">def cell(self, i, j):
    """ Returns the cell in row i, column j.
    """
    return self.rows[i][j]

</t>
<t tx="karstenw.20260127160317.96">def __call__(self, i, j):
    return self.cell(i, j)

</t>
<t tx="karstenw.20260127160317.97">def row(self, i):
    """ Returns row i in the grid.
    If a grid is supplied, returns the row in which that grid is a cell.
    """
    if isinstance(i, grid):
        for row in self.rows:
            if i in row: return row
    return self.rows[i]

</t>
<t tx="karstenw.20260127160317.98">def column(self, i):
    if isinstance(i, grid):
        for column in self.columns:
            if i in column: return column
    return self.columns[i]

col = column

</t>
<t tx="karstenw.20260127160317.99">def _get_cols(self)    : return self.columns
</t>
<t tx="karstenw.20260127160520.1">#------------------------------------------------------------------------------
</t>
<t tx="karstenw.20260127160617.1"># 1.9.4.2
# Bug fix for grid._traverse()

# 1.9.4.1
# Added text.fit_lineheight() companion for text.fit_fontsize().
# Content: txt = txt.rstrip(\n") in default_draw instead of in __init__().
</t>
<t tx="karstenw.20260127160707.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20260127160722.1"># Copyright (c) 2008 Tom De Smedt.
# See LICENSE.txt for details.

from __future__ import print_function

import os
from . import text
from .style import draw_text, draw_image
from types import MethodType, FunctionType

</t>
<t tx="karstenw.20260127160722.10">def is_command(self) : return self._type == CONTENT_FUNCTION
is_numeric = is_number

</t>
<t tx="karstenw.20260127160722.11">def has_text(self)   : return self.is_text()   and self._remainder != ""
</t>
<t tx="karstenw.20260127160722.12">def has_number(self) : return self.is_number() and self._remainder != None
</t>
<t tx="karstenw.20260127160722.13">def has_image(self)  : return self.is_image()  and len(self._remainder) &gt; 0

</t>
<t tx="karstenw.20260127160722.14">def text(self, width, height):
    """ Yields the next portion of text that fits width and height.
    """
    if self.has_text():
        block1, block2 = text.split(self._remainder,
                                    width, height,
                                    self.widows,
                                    self.orphans,
                                    self.forward )
        self._remainder = block2
        return block1

</t>
<t tx="karstenw.20260127160722.15">def number(self, width, height):
    """ Yields the number as a string if it fits the given width and height.
    """
    if self.has_number():
        block1, block2 = text.split(str(self._remainder), width, height)
        if block2 == "":
            self._remainder = None
            return block1
        return ""

</t>
<t tx="karstenw.20260127160722.16">def image(self):
    """ Yields the next image.
    """
    if self.has_image():
        img = self._remainder.pop(0)
        if self.repeat:
            self._remainder.append(img)
        return img

</t>
<t tx="karstenw.20260127160722.17">def next(self, width, height):
    """ Yields the next portion of whatever content is defined.
    """
    width += 10 # XXX fixes a bug in _ctx.text()
    if self.is_text()    :
        if self.parent.style and self.parent.styles[self.parent.style].fit:
            return self.remainder
        return self.text(width, height)
    if self.is_number()  : return self.number(width, height)
    if self.is_image()   : return self.image()
    if self.is_command() : return self.draw

</t>
<t tx="karstenw.20260127160722.18">def default_draw(self, x, y, width, height, style=None):

    """ Fills the given box with text, number or image.
    This method will be called from style.draw().
    This method is here and not in the style module so that
    a custom drawing function can be added to a content object.
    """

    if (self.has_text()
     or self.has_number()):

        if style and style.fit:
            # Take all of the content and scale the fontsize
            # so it fits in the given box.
            if self.is_text():
                txt, self._remainder = self._remainder, ""
            if self.is_number():
                txt, self._remainder = str(self._remainder), None
        else:
            # Take a portion of the content that fits the box.
            width += 10 # XXX fixes a bug in _ctx.text()
            if self.is_text():
                txt = self.text(width, height)
            if self.is_number():
                txt = self.number(width, height)
        txt = txt.rstrip("\n") # XXX fixes a bug in _ctx.text()
        if style == None:
            draw_text(self._ctx, txt, x, y, width, height)
        else:
            draw_text(
                self._ctx,
                txt,
                x,
                y,
                width,
                height,
                style.horizontal,
                style.fit
            )

    elif self.has_image():
        if style == None:
            draw_image(self._ctx, self.image(), x, y, width, height)
        else:
            draw_image(
                self._ctx,
                self.image(),
                x,
                y,
                width,
                height,
                style.horizontal,
                style.vertical,
                1.0,
                style.fit,
                style.opacity
            )

draw = default_draw

</t>
<t tx="karstenw.20260127160722.19">def _unpack(self, v):
    if isinstance(v, content): return v._data
    return v

# Comparison.
</t>
<t tx="karstenw.20260127160722.2">#### CONTENT #########################################################################################
# Grid content, either text, number, image(s) or command.
# This is a "depletion object":
# each time a cell calls for content, a bit of content is chipped away.
# This way, flowing text or consecutive images can be shared between different cells.

CONTENT_NONE     = "none"
CONTENT_TEXT     = "text"
CONTENT_NUMBER   = "number"
CONTENT_IMAGE    = "image"
CONTENT_FUNCTION = "function"

class content(object):

    @others
</t>
<t tx="karstenw.20260127160722.20">def __eq__(self, v)   : return self._data == self._unpack(v)
</t>
<t tx="karstenw.20260127160722.21">def __ne__(self, v)   : return not self.__eq__(v)
</t>
<t tx="karstenw.20260127160722.22">def __lt__(self, v)   : return self._data &lt; self._unpack(v)
</t>
<t tx="karstenw.20260127160722.23">def __gt__(self, v)   : return self._data &gt; self._unpack(v)

# Content representations as a string, number and list.
</t>
<t tx="karstenw.20260127160722.24">def __str__(self)     :
    try: return self._data.encode("utf-8")
    except:
        return self._data
</t>
<t tx="karstenw.20260127160722.25">def __unicode__(self) : return self._data
</t>
<t tx="karstenw.20260127160722.26">def __iter__(self)    : return self._data.__iter__()
</t>
<t tx="karstenw.20260127160722.27">def __float__(self)   : return float(self._data)
</t>
<t tx="karstenw.20260127160722.28">def __int__(self)     : return int(self._data)

# Mathematical operators.
</t>
<t tx="karstenw.20260127160722.29">def __add__(self, v)  : return self._data + self._unpack(v)
</t>
<t tx="karstenw.20260127160722.3">def __init__(self, _ctx, data):

    """ Stores a text or a list of images to spread around a grid.
    If it contains both, uses only the text and not the images.
    """

    text._ctx    = _ctx # text module needs the drawing context
    self._ctx    = _ctx
    self.parent  = None # the container grid

    # Disambiguate between custom draw() command,
    # list of images, single image, number text string.
    self._type = None
    self._data = None
    
    # print( "data", repr(type(data)) )

    if type(data) in (MethodType, FunctionType):
        self._type = CONTENT_FUNCTION
        self._data = data
        self.draw  = data

    elif isinstance(data, (int, float)):
        self._type = CONTENT_NUMBER
        self._data = data

    elif isinstance(data, (list, tuple)):
        self._type = CONTENT_IMAGE
        self._data = list(data)

    elif self.is_image_path(data):
        self._type = CONTENT_IMAGE
        self._data = [data]

    elif data == None:
        self._type = CONTENT_NONE
        self._data = data

    else:
        self._type = CONTENT_TEXT
        try: data = data.decode("utf-8")
        except:
            pass
        self._data = data

    # The remainder is what content has not been drawn.
    if self._type == CONTENT_IMAGE:
        self._remainder = list(self._data)
    else:
        self._remainder = self._data

    self.widows  = 1
    self.orphans = 1
    self.forward = True
    self.repeat  = False

    # If a grid has child cells, content is distributed to the cells.
    # This occurs when the grid is drawn - or when grid.distribute() is called.
    # If that happens, the child cells get a new content object with a portion
    # of the parent content. This object will have content._distributed = True.
    self._distributed = False

</t>
<t tx="karstenw.20260127160722.30">def __sub__(self, v)  : return self._data - self._unpack(v)
</t>
<t tx="karstenw.20260127160722.31">def __mul__(self, v)  : return self._data * self._unpack(v)
</t>
<t tx="karstenw.20260127160722.32">def __div__(self, v)  : return self._data / self._unpack(v)
</t>
<t tx="karstenw.20260127160722.33">def __abs__(self)     : return abs(self._data)
# Note: when you do 'grid.content += value',
# __add__() will first be called and a new content object assigned to the grid,
# since 'grid.content = something' is defined as grid._set_content().

# Sequence operators.
</t>
<t tx="karstenw.20260127160722.34">def __len__(self)         : return len(self._data)
</t>
<t tx="karstenw.20260127160722.35">def __contains__(self, v) : return self._unpack(v) in self._data
</t>
<t tx="karstenw.20260127160722.36">def __getitem__(self, i)  : return self._data[i]
</t>
<t tx="karstenw.20260127160722.37">def __setitem__(self, i, v):
    self._data[i] = self._unpack(v)

# Call operator.
</t>
<t tx="karstenw.20260127160722.38">def __call__(self, x, y, width, height, style=None):
    self.draw(x, y, width, height, style)
</t>
<t tx="karstenw.20260127160722.4">def _get_remainder(self):
    return self._remainder
remainder = property(_get_remainder)

</t>
<t tx="karstenw.20260127160722.5">def copy(self, parent=None):
    """ Returns a copy of the content.
    Copies of a custom draw() method all refer to the same function.
    """
    c = content(self._ctx, self._data)
    c.parent  = parent
    c.widows  = self.widows
    c.orphans = self.orphans
    c.forward = self.forward
    c.repeat  = self.repeat
    return c

</t>
<t tx="karstenw.20260127160722.6">def is_image_path(self, path):
    """ Disambiguate between image path and text string.
    """
    if isinstance(path, str):
        ext = os.path.splitext(path)[1]
        if ext.lower() in (".gif",".jpg",".png",".tif",".eps",".pdf",".ai",".psd"):
            if os.path.exists(path):
                return True
    return False


</t>
<t tx="karstenw.20260127160722.7">def is_text(self)    : return self._type == CONTENT_TEXT
</t>
<t tx="karstenw.20260127160722.8">def is_number(self)  : return self._type == CONTENT_NUMBER
</t>
<t tx="karstenw.20260127160722.9">def is_image(self)   : return self._type == CONTENT_IMAGE
</t>
<t tx="karstenw.20260127160731.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20260127160739.1"># Copyright (c) 2008 Tom De Smedt.
# See LICENSE.txt for details.

from math import sqrt
from random import random, shuffle

</t>
<t tx="karstenw.20260127160739.10">def draw(self, x, y, width=100, height=300):
    for v in self:
        self._ctx.fill(random(), random(), random())
        self._ctx.rect(x, y, width, v*height)
        y += v * height        

</t>
<t tx="karstenw.20260127160739.2">#### PROPORTION ######################################################################################

PROPORTION_RANDOM      = "random"
PROPORTION_EVEN        = "even"
PROPORTION_FIBONACCI   = "fibonacci"
PROPORTION_FIB         = "fib"
PROPORTION_CONTRAST    = "contrast"

class proportion(list):

    """ A list of values distributed according to an aesthetical principle.
    """

    @others
#p = proportion(
#    8, "fib", 
#    sorted=False, reversed=True, shuffled=False, mirrored=True,
#    repetition=1)
#
#p.draw(50, 50)
</t>
<t tx="karstenw.20260127160739.3">def __init__(self, n=None, distribution=PROPORTION_EVEN, 
             sorted=False, reversed=False, shuffled=False, mirrored=False, 
             repetition=1):
    
    self.golden_ratio = self.phi = 1.61803398875
    
    self.distribution = distribution
    self.sorted       = sorted
    self.reversed     = reversed
    self.shuffled     = shuffled
    self.mirrored     = mirrored
    self.repetition   = repetition
    self._ctx         = None # needed for drawing
    
    if isinstance(n, (list, tuple)):
        # Creates a custom proportion from a list.
        list.__init__(self, n)
        self.generate = lambda n: None
    if n != None:
        self.generate(n)

</t>
<t tx="karstenw.20260127160739.4">def __getitem__(self, i):
    if i &gt;= len(self):
        return 0
    else:
        return list.__getitem__(self, i)

</t>
<t tx="karstenw.20260127160739.5">def copy(self):
    p = proportion(
        None,
        self.distribution, 
        self.sorted, 
        self.reversed,
        self.shuffled,
        self.mirrored,
        self.repetition
    )
    for x in self: p.append(x)
    return p

</t>
<t tx="karstenw.20260127160739.6">def generate(self, n):
    
    """ Generates a range of values according to a proportional distribution.
    
    By default, the distribution is even: all values are equal.
    Other possibilities are:
    random, 
    contrast (a few very large values and many small values),
    golden ratio (using the Fibonacci sequence).
    
    Values are relativized so their sum is 1.0.
    If n is a list, relativize that.
    
    """
    
    r = max(1, self.repetition)
    
    if isinstance(n, list):
        list.__init__(self, n)
    elif n &lt;= 0:
        list.__init__(self, [])
    elif n == 1:
        list.__init__(self, [1.0])
    elif self.distribution == PROPORTION_RANDOM:
        list.__init__(self, [random() for i in range(n//r)])
    elif self.distribution in (PROPORTION_EVEN):
        list.__init__(self, [1.0/n for i in range(n//r)])
    elif self.distribution in (PROPORTION_FIBONACCI, PROPORTION_FIB):
        # Values distributed according to the golden ratio.
        list.__init__(self, [self.fib(i) for i in range(2,(n//r)+2)])  
    elif self.distribution == PROPORTION_CONTRAST:
        # Split the range: 80% are 0.05-0.15 value and 20% are 0.85-1.0 values.
        i = max(1, int(round((n//r) * 0.2)))
        j = (n/r) - i
        if self.reversed: i, j = j, i
        list.__init__(self, [random()*0.15+0.85 for k in range(i)])
        for k in range(j): 
            self.append(random()*0.1+0.05)
    
    # Repeat the range and assert that the list has n elements.
    self *= r
    for i in range(n-len(self)):
        self.append(self[i])
    
    self.relativize()
    
    if self.sorted   : self.sort()
    if self.reversed : self.reverse()
    if self.shuffled : shuffle(self)
    if self.mirrored : self.mirror(self.reversed)

</t>
<t tx="karstenw.20260127160739.7">def relativize(self):
    """ Relativizes the values so they fall between 0.0 and 1.0.
    """
    s = float(sum(self))
    if s &gt; 0:
        list.__init__(self, [x/s for x in self])

</t>
<t tx="karstenw.20260127160739.8">def mirror(self, reversed=False):
    """ Puts the smallest values in the middle of the list,
    then alternates between pushing and appending larger values on the list.
    """
    self.sort()
    if reversed: self.reverse()
    rng = []
    b = True
    for v in self:
        b = not b
        if b: 
            rng.append(v)
        else:
            rng.insert(0, v)
    list.__init__(self, rng)

</t>
<t tx="karstenw.20260127160739.9">def fib(self, n):
    """ The Fibonnaci sequence relates to the golden ratio.
    """
    if n == 0: return 0
    if n == 1: return 1
    a, b = 0, 1
    for i in range(n-1): 
        a, b = b, a+b
    return b
    
</t>
<t tx="karstenw.20260127160808.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20260127160816.1"># Copyright (c) 2008 Tom De Smedt.
# See LICENSE.txt for details.

import warnings
from . import text

</t>
<t tx="karstenw.20260127160816.10">def __setattr__(self, a, v):
    """ Setting an attribute is like setting it in all of the contained styles.
    """
    values = list( self.values() )
    if   a == "_ctx"  : self.__dict__["_ctx"] = v
    elif a == "guide" : self.__dict__["guide"] = v
    elif hasattr(values[0], a):
        for style in values:
            setattr(style, a, v)
    else:
        raise AttributeError( "'style' object has no attribute '"+a+"'" )
        
</t>
<t tx="karstenw.20260127160816.11">def copy(self, grob):
    """ Returns a copy of all styles and a copy of the styleguide.
    """
    s = styles(self._ctx, grob)
    s.guide = self.guide.copy(grob)
    dict.__init__(s, [(v.name, v.copy()) for v in self.values()])
    return s

</t>
<t tx="karstenw.20260127160816.12">#### STYLE GUIDE ##############################################################
# Each graphical object gets the default colors, type and drawing functions.
# The guide defines how and when to apply other styles based on grob properties.
# It contains a set of style name keys linked to x(grob) functions.
# If such a function returns True for a grob, the style is applied to that grob.

class styleguide(dict):
    
    @others
</t>
<t tx="karstenw.20260127160816.13">def __init__(self, grob):
    self.grob = grob
    self.order = []

</t>
<t tx="karstenw.20260127160816.14">def append(self, stylename, function):
    """ The name of a style and a function that takes a grob.
    It returns True when the style should be applied to the given grob.
    """
    self[stylename] = function

</t>
<t tx="karstenw.20260127160816.15">def clear(self):
    self.order = []
    dict.__init__(self)

</t>
<t tx="karstenw.20260127160816.16">def apply(self):
    """ Check the rules for each grob and apply the style.
    We expect a grob to have an all() method that yields all grobs to check.
    """
    sorted = self.order + self.keys()
    unique = []; [unique.append(x) for x in sorted if x not in unique]
    for node in self.grob.all():
        for s in unique:
            if s in self and self[s](grob): 
                # if self.has_key(s) and self[s](grob): 
                grob.style = s

</t>
<t tx="karstenw.20260127160816.17">def copy(self, grob):
    """ Returns a copy of the styleguide for the given grob.
    """
    g = styleguide(grob)
    g.order = self.order
    dict.__init__(g, [(k, v) for k, v in self.iteritems()])
    return g

</t>
<t tx="karstenw.20260127160816.18">#### SPACING ##################################################################
# Left, top, right and bottom spacing in a container.

class spacing(list):
    
    @others

</t>
<t tx="karstenw.20260127160816.19">def __init__(self, left=0, top=0, right=0, bottom=0):
    # You can also supply values as one list parameter.
    if isinstance(left, (list, tuple)):
        list.__init__(self, [v for v in left])
    else:
        list.__init__(self, [left, top, right, bottom])

</t>
<t tx="karstenw.20260127160816.2">#### ATTRIBUTES WITH ATTRIBUTES ###############################################

class attributes_with_attributes(list):
    # On a styles object, we can set styles.fontsize = 12, which will set the
    # fontsize in all the style objects it contains.
    #
    # We can't do styles.padding.left = 2 because the styles object has no
    # padding attribute to get.
    # Therefore, we return a list of all the style objects' "padding" attributes
    # with the possibility to then set the "left" of each item in the list.

    @others
</t>
<t tx="karstenw.20260127160816.20">def copy(self):
    return spacing(self)

</t>
<t tx="karstenw.20260127160816.21">def _get_l(self): return self[0]
</t>
<t tx="karstenw.20260127160816.22">def _get_t(self): return self[1]
</t>
<t tx="karstenw.20260127160816.23">def _get_r(self): return self[2]
</t>
<t tx="karstenw.20260127160816.24">def _get_b(self): return self[3]

</t>
<t tx="karstenw.20260127160816.25">def _set_l(self, v): self[0] = v
</t>
<t tx="karstenw.20260127160816.26">def _set_t(self, v): self[1] = v
</t>
<t tx="karstenw.20260127160816.27">def _set_r(self, v): self[2] = v
</t>
<t tx="karstenw.20260127160816.28">def _set_b(self, v): self[3] = v

left   = l = property(_get_l, _set_l)
top    = t = property(_get_t, _set_t)
right  = r = property(_get_r, _set_r)
bottom = b = property(_get_b, _set_b)

</t>
<t tx="karstenw.20260127160816.29">#### BACKGROUND ###############################################################
class background():
    
    @others

</t>
<t tx="karstenw.20260127160816.3">def __setattr__(self, a, v):
    for x in self:
        setattr(x, a, v)

</t>
<t tx="karstenw.20260127160816.30">def __init__(self, clr,
             horizontal="left",
             vertical="top",
             scale=1.0, x=0, y=0):
    """
    Background color and image attached according to given alignment and offset.
    """
    if isinstance(clr, str):
        self.color    = None
        self.image    = clr
        self.gradient = None
    elif isinstance(clr, tuple):
        self.color    = None
        self.image    = None
        self.gradient = clr                
    else:
        self.color    = clr
        self.image    = None
        self.gradient = None
    self.horizontal = horizontal
    self.vertical   = vertical
    self.scale = scale
    self.x = x
    self.y = y
    self.opacity = 1.0

</t>
<t tx="karstenw.20260127160816.31">def copy(self):
    b = background(None, self.horizontal,
                   self.vertical, self.scale, self.x, self.y)
    if self.color != None:
        b.color = self.color.copy()
    b.image = self.image
    if self.gradient != None:
        g = list(self.gradient)
        g[0], g[1] = g[0].copy(), g[1].copy()
        b.gradient = tuple(g)
    return b

</t>
<t tx="karstenw.20260127160816.32">def _get_align(self):
    return self._align
</t>
<t tx="karstenw.20260127160816.33">def _set_align(self, v):
    if isinstance(v, (tuple, list)):
        h, v = v
    else:
        h, v = v, v
    self.horizontal = h
    self.vertical = v
align = property(_get_align, _set_align)
    
</t>
<t tx="karstenw.20260127160816.34">def gradientfill(self, clr1, clr2, type="radial", 
                 dx=0, dy=0, spread=1.0, angle=0, alpha=1.0):
    self.color = None
    self.image = None
    self.gradient = clr1, clr2, type, dx, dy, spread, angle, alpha

</t>
<t tx="karstenw.20260127160816.35">def draw(self, x, y, width, height, style=None):
    """ Override this method for custom background.
    """
    pass
draw = None

</t>
<t tx="karstenw.20260127160816.36">#### STYLE ####################################################################
class style(object):
    
    @others
</t>
<t tx="karstenw.20260127160816.37">def __init__(self, name, _ctx, **kwargs):

    self.name = name
    self._ctx = _ctx
    text._ctx = _ctx # text module needs the drawing context.
    
    # Defaults for colors and typography.
    self.background   = None
    self.fill         = _ctx.color(0)
    self.stroke       = None
    self.strokewidth  = 0
    self.font         = "Verdana"
    self.fontsize     = 9
    self.lineheight   = 1.2
    self.horizontal   = 0
    self.vertical     = 0
    self.roundness    = 0
    self._margin      = spacing(0, 0, 0, 0)
    self._padding     = spacing(0, 0, 0, 0)
    self._align       = ("top", "left")
    self.rotation     = 0
    self.opacity      = 1.0
    self.clipped      = True
    self.fit          = False
    self.delegate     = True
    
    # Each of the attributes is an optional named parameter in __init__().
    for attr in kwargs:
        if attr in self.__dict__: #.has_key(attr):
            self.__dict__[attr] = kwargs[attr]

</t>
<t tx="karstenw.20260127160816.38">def copy(self, name=None):
    """ Copy all attributes, link all monkey patch methods.
    """
    s = style(self.name, self._ctx)
    for attr in self.__dict__: 
        v = self.__dict__[attr]
        if isinstance(v, (background, spacing, self.fill.__class__)):
            v = v.copy()
        s.__dict__[attr] = v
    if name != None: 
        s.name = name
    
    return s

</t>
<t tx="karstenw.20260127160816.39">def _get_background(self):
    return self._background

</t>
<t tx="karstenw.20260127160816.4">#### STYLES ###################################################################

class styles(dict):
    
    @others
</t>
<t tx="karstenw.20260127160816.40">def _set_background(self, v):
    if not isinstance(v, background):
        b = background(v)
    self._background = b

background = property(_get_background, _set_background)

</t>
<t tx="karstenw.20260127160816.41">def _get_strokewidth(self): return self._strokewidth
</t>
<t tx="karstenw.20260127160816.42">def _set_strokewidth(self, v): 
    if not isinstance(v, (list, tuple)): 
        v = (v, v, v, v)
    self._strokewidth = spacing(v)

strokewidth = property(_get_strokewidth, _set_strokewidth)

</t>
<t tx="karstenw.20260127160816.43">def _get_margin(self): return self._margin
</t>
<t tx="karstenw.20260127160816.44">def _set_margin(self, v): 
    if not isinstance(v, (list, tuple)): 
        v = (v, v, v, v)
    self._margin = spacing(v)

margin = property(_get_margin, _set_margin)

</t>
<t tx="karstenw.20260127160816.45">def _get_padding(self): return self._padding
</t>
<t tx="karstenw.20260127160816.46">def _set_padding(self, v): 
    if not isinstance(v, (list, tuple)): 
        v = (v, v, v, v)
    self._padding = spacing(v)

padding = property(_get_padding, _set_padding)

</t>
<t tx="karstenw.20260127160816.47">def _get_align(self): return (self.horizontal, self.vertical)
</t>
<t tx="karstenw.20260127160816.48">def _set_align(self, v):
    if isinstance(v, (list, tuple)):
        self.horizontal, self.vertical = v
    else:
        self.horizontal, self.vertical = v, "top"
        
align = property(_get_align, _set_align)

</t>
<t tx="karstenw.20260127160816.49">#--- ALIGNMENT HELPER ---------------------------------------------------------

LEFT    = 0
RIGHT   = 1
CENTER  = 2
JUSTIFY = 3
TOP     = 4
BOTTOM  = 5

def alignment(v):
    if v == "left"    : return LEFT
    if v == "right"   : return RIGHT
    if v == "center"  : return CENTER
    if v == "justify" : return JUSTIFY
    if v == "top"     : return TOP
    if v == "bottom"  : return BOTTOM
    return v 

</t>
<t tx="karstenw.20260127160816.5">def __init__(self, _ctx, grob):
    self._ctx = _ctx
    self.guide = styleguide(grob)
    self.create("default")

</t>
<t tx="karstenw.20260127160816.50">#--- RECT WITH IMPROVED ROUNDNESS ---------------------------------------------

from nodebox.graphics import BezierPath
def rect(_ctx, x, y, width, height, roundness=0.0, draw=True, **kwargs):
    """ Roundness is either a relative float between 0.0 and 1.0,
    or the absolute radius of the corners. 
    """
    BezierPath.checkKwargs(kwargs)
    p = _ctx.BezierPath(**kwargs)
    r = max(0, roundness)
    if r == 0.0:
        p.rect(x, y, width, height)
    else:
        if r &lt;= 1.0 and isinstance(r, float):
            r = min(r*width/2, r*height/2)
        else:
            r = min(r, width/2, height/2)
        p.moveto(x, y+r)
        a, b, c, d = (x, y), (x+width, y), (x, y+height), (x+width, y+height)
        p._nsBezierPath.appendBezierPathWithArcFromPoint_toPoint_radius_(a, b, r)
        p._nsBezierPath.appendBezierPathWithArcFromPoint_toPoint_radius_(b, d, r)
        p._nsBezierPath.appendBezierPathWithArcFromPoint_toPoint_radius_(d, c, r)
        p._nsBezierPath.appendBezierPathWithArcFromPoint_toPoint_radius_(c, a, r)
        p.closepath()
    p.inheritFromContext(kwargs.keys())
    if draw:
        p.draw()
    return p       

</t>
<t tx="karstenw.20260127160816.51">#--- DRAW GROB ----------------------------------------------------------------

def begin_grob(style, grob, x, y):
    
    # Cells inherit the parent style.
    # This way you can set a style for a collection of peer cells.
    # An exception to this rule is when style.delegate is False, then the style
    # is drawn for the container and not used for the containing cells.
    # This is useful when you have a background that spans different rows
    # and columns (instead of the background being applied to each
    # individual row/column).

    style._ctx.push()
    if (style.delegate and len(grob) &gt; 0):
        style._ctx.translate(x, y)
        return (None, 0, 0)
    
    # Margin is the space around each cell.
    l, t, r, b = style.margin
    x += grob.x + l
    y += grob.y + t
    w, h = grob.width-r-l, grob.height-b-t
    if w &lt;= 0: return (None, 0, 0)
    if h &lt;= 0: return (None, 0, 0)
    
    # Padding is the space around the cell's content.
    l, t, r, b = style.padding
    
    # The cell path is a rounded rectangle.
    style._ctx.translate(x, y)
    p = rect(style._ctx, 0, 0, w, h, roundness=style.roundness, draw=False)
    
    if style.clipped:
        style._ctx.beginclip(p)
    
    draw_background(style, grob, p, 0, 0, w, h)    
    draw_content(style, grob, l, t, w-r-l, h-b-t)
        
    return (p, w, h)

</t>
<t tx="karstenw.20260127160816.52">def end_grob(style, grob, path, width, height):
    # End clipping masks and pushed transformations.
    # If defined, draw a border around this grid.
    if not style.delegate or len(grob) == 0:
        if width &gt; 0 and height &gt; 0:
            if style.clipped:
                style._ctx.endclip()
            draw_stroke(style, grob, path, width, height)
    style._ctx.pop()

</t>
<t tx="karstenw.20260127160816.53">#--- DRAW BACKGROUND ----------------------------------------------------------

def draw_background(style, grob, path, x, y, width, height):
    # If a background color is defined, draw a colored rectangle in the back.
    if style.background.color:
        style._ctx.nostroke()
        style._ctx.fill(style.background.color)
        style._ctx.drawpath(path)
    # If a background image is defined, draw it on top of the background color.
    # The image is stretched to fit or aligned at the LEFT, CENTER or RIGHT.
    if style.background.image:
        draw_image(
            style._ctx,
            style.background.image,
            style.background.x,
            style.background.y,
            width,
            height,
            style.background.horizontal,
            style.background.vertical,
            style.background.scale,
            style.fit,
            style.background.opacity
        )
    # If a background gradient is defined, attempt to import the Colors library.
    if style.background.gradient:
        try:
            colors = style._ctx.ximport("colors")
            g = style.background.gradient
            clr1   = g[0]
            clr2   = g[1]
            type   = g[2] if len(g) &gt; 2 else "linear"
            dx     = g[3] if len(g) &gt; 3 else 0
            dy     = g[4] if len(g) &gt; 4 else 0
            spread = g[5] if len(g) &gt; 5 else 1.0
            angle  = g[6] if len(g) &gt; 6 else 0
            alpha  = g[7] if len(g) &gt; 7 else 1.0

            colors.gradientfill(path,
                                clr1, clr2,
                                type,
                                dx, dy,
                                spread, angle, alpha)
        except:
            warnings.warn("the Colors library is needed to draw gradients.", Warning)
    if style.background.draw:
        style._ctx.push()
        style.background.draw(x, y, width, height, style)
        style._ctx.pop()

</t>
<t tx="karstenw.20260127160816.54">#--- DRAW CONTENT -------------------------------------------------------------

def draw_content(style, grob, x, y, width, height):
    # Draw the content in the given color and text properties.
    # Only cells that have no child cells draw content.

    style._ctx.push()
    style._ctx.fill(style.fill)
    style._ctx.font(style.font, style.fontsize)
    style._ctx.lineheight(style.lineheight)
    style._ctx.align(alignment(style.horizontal))

    # Content rotation.
    # If the content is rotated 90, -90 or 180 degrees,
    # we translate and rescale to simulate a "flip".
    style._ctx.transform(0) # corner-mode transformations
    style._ctx.translate(x, y)
    style._ctx.rotate(style.rotation)

    if style.rotation % 360 == 90:
        width, height = height, width
        style._ctx.translate(-width, 0)

    if style.rotation % 360 == 270:
        width, height = height, width
        style._ctx.translate(0, -height)

    if style.rotation % 360 == 180:
        style._ctx.translate(-width, -height)

    # Execute the grid.content.draw() callback.
    if grob.content != None and len(grob) == 0:
        grob.content.draw(0, 0, width, height, style)    
    style._ctx.pop()

</t>
<t tx="karstenw.20260127160816.55">#--- DRAW STROKE --------------------------------------------------------------

def draw_stroke(style, grob, path, width, height):
    # If a stroke is defined, draw a stroked, transparent rectangle on top.
    if style.stroke != None:
        style._ctx.stroke(style.stroke)
        l, t, r, b = style.strokewidth
        if l == t == r == b:
            style._ctx.nofill()
            style._ctx.strokewidth(l)
            style._ctx.drawpath(path.copy())
        else:
            w, h = width, height
            if l &gt; 0:
                style._ctx.strokewidth(l)
                style._ctx.line(0, 0, 0, h)
            if r &gt; 0:
                style._ctx.strokewidth(r)
                style._ctx.line(w, 0, w, h)
            if t &gt; 0:
                style._ctx.strokewidth(t)
                style._ctx.line(0, 0, w, 0)
            if b &gt; 0:
                style._ctx.strokewidth(b)
                style._ctx.line(0, h, w, h)     

</t>
<t tx="karstenw.20260127160816.56">#--- DRAW TEXT ----------------------------------------------------------------
# Used in content.draw()

def draw_text(_ctx, txt, x, y, w, h, horizontal=0, fit=False):
    # Small tweaks to get the position and size of text blocks right.
    if alignment(horizontal) == RIGHT  : x -= 10
    if alignment(horizontal) == CENTER : x -= 5
    if fit:
        _ctx.fontsize(text.fit_fontsize(txt, w, h))
        _ctx.lineheight(text.fit_lineheight(txt, w, h))
    _ctx.text(
        txt, 
        x, 
        y+_ctx.fontsize(), 
        w, 
        h
    )

</t>
<t tx="karstenw.20260127160816.57">#--- DRAW IMAGE ---------------------------------------------------------------
# Used in begin_grob() and content.draw()

def draw_image(_ctx, img,
                     x, y, w, h,
                     horizontal=0, vertical=0,
                     scale=1.0, fit=False, alpha=1.0):
    """ Draws the image at the given position.
    Horizontal and vertival (LEFT, RIGHT, CENTER, "bottom") are used to align
    the image, while fit determines if it will stretch to fill the given width
    and height.
    """
    r = _ctx.rect(x, y, w, h, draw=False)

    _ctx.beginclip(r)

    _ctx.push()

    img_w, img_h = _ctx.imagesize(img)

    if fit:
        d1 = float(w) / img_w
        d2 = float(h) / img_h
        if     ((img_w * d1 - w) &gt;= -0.00001
            and (img_h * d1 - h) &gt;= -0.00001):
            img_w *= d1
            img_h *= d1
        else:
            img_w *= d2
            img_h *= d2    
    if alignment(horizontal) == RIGHT  : x += 1.0 * (w-img_w)
    if alignment(horizontal) == CENTER : x += 0.5 * (w-img_w)
    if alignment(vertical)   == BOTTOM : y += 1.0 * (h-img_h)
    if alignment(vertical)   == CENTER : y += 0.5 * (h-img_h)
    _ctx.translate(x, y)
    _ctx.image(img, 0, 0, width=img_w, alpha=alpha)
    _ctx.pop()
    _ctx.endclip()
</t>
<t tx="karstenw.20260127160816.6">def apply(self):
    self.guide.apply()

</t>
<t tx="karstenw.20260127160816.7">def create(self, stylename, **kwargs):
    """ Creates a new style which inherits from the default style, or any
    other style which name is supplied to the optional template parameter.
    """
    if stylename == "default":    
        self[stylename] = style(stylename, self._ctx, **kwargs)
        return self[stylename]
    k = kwargs.get("template", "default")
    s = self[stylename] = self[k].copy(stylename)
    for attr in kwargs:
        if attr in s.__dict__: # .has_key(attr):
            s.__dict__[attr] = kwargs[attr]
    return s

</t>
<t tx="karstenw.20260127160816.8">def append(self, style):
    self[style.name] = style

</t>
<t tx="karstenw.20260127160816.9">def __getattr__(self, a):
    """ Keys in the dictionaries are accessible as attributes."""

    if a in self: #self.has_key(a): 
        return self[a]

    if a in ("padding", "margin", "background", "strokewidth", "align"):
        return attributes_with_attributes([getattr(style, a)
                                           for style in self.values()])
    raise AttributeError( "'styles' object has no attribute '"+a+"'" )
    
</t>
<t tx="karstenw.20260127161628.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20260127161638.1"># Copyright (c) 2008 Tom De Smedt.
# See LICENSE.txt for details.


from random import random, choice, randrange

</t>
<t tx="karstenw.20260127161638.10">#### TEXT SPLIT ###############################################################

def split(txt, width, height, widows=1, orphans=1, forward=True):

    """Splits a text with the first half fitting width and height, given the
    current font.

    Returns a 2-tuple of (block, remainder).
    """

    if width == 0 or height &lt; _ctx.textheight(" "):
        return ("", txt)
    if height &gt; _ctx.textheight(txt, width):
        return (txt.rstrip("\n"), "")

    i, j, m = len(txt), 0, 2
    txt = txt.replace("\n", " \n")

    # Splitter parameters.
    d = 1.6
    if _ctx.fontsize() &gt; 20:
        d = 1.15

    # Approximate by cutting in large chunks a few times.
    # When it gets down to chunks increasing or decreasing by 10 characters,
    # proceed from word to word.
    h = _ctx.textheight(txt[:i], width)
    while abs(h - height) &gt; _ctx.fontsize():
        if abs(i/m) &lt; 10: break # Increase or decrease becomes too small.
        if h &gt;  height: i -= i/m; m *= d
        if h &lt;= height: i += i/m
        i = int(i)
        h = _ctx.textheight(txt[:i], width)
    i = max(0, min(i, len(txt)))
    # Expand word per word.
    while i &lt; len(txt) and _ctx.textheight(txt[:i], width) &lt;= height:
        i += 1
        while i &lt; len(txt) and txt[i] != " ":
            i += 1
    # Decrease word per word.
    while i &gt; 1 and _ctx.textheight(txt[:i], width) &gt; height:
        i -= 1
        while i &gt; 1 and txt[i] != " ":
            i -= 1

    block = txt[:i].lstrip()
    remainder = txt[i:].lstrip()

    # Widow/orphan control.
    if widows &gt; 0 or orphans &gt; 0:
        block, remainder = keep_together(
            block,
            remainder,
            width,
            widows,
            orphans,
            forward
        )

    return block.rstrip("\n"), remainder.rstrip("\n")

</t>
<t tx="karstenw.20260127161638.11">#### TEXT DIVIDE ##############################################################

def divide(txt, width, height, widows=1, orphans=1, forward=True):
    """ Splits a text into blocks of equal width and height.
    """
    blocks = []
    block, remainder = split(txt, width, height, widows, orphans, forward)
    while remainder != "":
        blocks.append(block)
        block, remainder = split(remainder, width, height, widows, orphans, forward)
    blocks.append(block)
    return blocks

</t>
<t tx="karstenw.20260127161638.12">#### LEGIBLE WIDTH ############################################################

def legible_width(txt, chars=70):
    """ Calculates a legible width for the text set in the current font.
    Assumes an optimal of 70 characters per line at fontsize 10pt.
    Smaller lineheight furthermore decreases the width.
    """
    fs = _ctx.fontsize()
    _ctx.fontsize(10)
    str = ""
    for i in range(chars):
        str += choice("abcdefghijklmnopqrstuvwxyz ")
    w = _ctx.textwidth(str)
    w *= 1.0 * fs / 10
    w *= _ctx.lineheight() / 1.2
    if txt == txt.upper():
        w *= 1.5
    _ctx.fontsize(fs)
    return w

</t>
<t tx="karstenw.20260127161638.13">#### FIT FONTSIZE #############################################################

def fit_fontsize(str, width, height):
    """ Returns the fontsize at which str fits inside a block of width and height.
    """
    # Should add better support for ascenders and descenders here.
    # E.g. if a word contains no descenders (Goo vs. goo) there is more room at
    # the bottom to scale.
    def increase(str, width, height, factor):
        while _ctx.textheight(str, width) &lt; height:
            _ctx.fontsize(_ctx.fontsize()+factor)
    def decrease(str, width, height, factor):
        while _ctx.textheight(str, width) &gt; height and _ctx.fontsize() &gt; 0:
            _ctx.fontsize(_ctx.fontsize()-factor)
    if str == "" or width &lt; 1 or height &lt; 1:
        return 0.0001
    fs = _ctx.fontsize()
    increase(str, width, height, 10)
    decrease(str, width, height, 3)
    increase(str, width, height, 1)
    decrease(str, width, height, 1)
    x = _ctx.fontsize()
    _ctx.fontsize(fs)
    return max(x, 0.0001)

</t>
<t tx="karstenw.20260127161638.14">def fit_lineheight(str, width, height):
    """ Increases or decrease the line spacing to fit the text vertically in the box.
    """
    def increase(str, width, height, factor):
        while _ctx.textheight(str, width) &lt; height:
            _ctx.lineheight(_ctx.lineheight()+factor)
    def decrease(str, width, height, factor):
        while _ctx.textheight(str, width) &gt; height and _ctx.lineheight() &gt; 0.01:
            _ctx.lineheight(_ctx.lineheight()-factor)
    if _ctx.textheight(str, width) &lt;= _ctx.textheight(" ") \
    or _ctx.textheight(str, width) &lt;= 1 \
    or _ctx.fontsize() &lt; 1:
        return _ctx.lineheight()
    if str == "" or width &lt; 1 or height &lt; 1:
        return 0.0001
    lh = _ctx.lineheight()
    increase(str, width, height, 0.1)
    decrease(str, width, height, 0.05)
    increase(str, width, height, 0.01)
    decrease(str, width, height, 0.01)
    x = _ctx.lineheight()
    _ctx.lineheight(lh)
    return max(x, 0.0001)

###############################################################################

#w = 300
#h = 244
#align(LEFT)
#from time import time
#t = time()
#for i in range(1):
#    fontsize(9)
#    s = placeholder.text(n=4)
#    #s = "blah\nblah\nblah\nblah\nblah\nblah\nblah" # orphan/widow bugs.
#    b, r = split(s, w, h)
#    rect(0, 0, w, h, fill=None, stroke=0, strokewidth=1)
#text(b, 0, fontsize(), width=w, fill=0)
#print( time()-t )
#text(r, 0, h+fontsize(), w, fill=(1,0,0))

#fontsize(9)
#lineheight(1.2)
#align(JUSTIFY)
#str = placeholder.text()
#w = legible_width(str)
#blocks = blocks(str, w, 300)
#x = 20
#for block in blocks:
#    text(block, x, 20, w)
#    x += w + 20
</t>
<t tx="karstenw.20260127161638.2">def superscript(i):
    s = str(i)
    digits = [u"\u2070", u"\u00B9", u"\u00B2", u"\u00B3", u"\u2074",
              u"\u2075", u"\u2076", u"\u2077", u"\u2078", u"\u2079"]
    for i, digit in enumerate(digits):
        s = s.replace(str(i), digits[i])
    return s


</t>
<t tx="karstenw.20260127161638.3">#### PLACEHOLDER TEXT #########################################################

class _placeholder:

    @others
placeholder = _placeholder()
#fontsize(10)
#text(placeholder.text(3), 20, 20, width=500)

</t>
<t tx="karstenw.20260127161638.4">def __init__(self):

    self.words = """ lorem ipsum dolor sit amet consectetur adipisicing elit
    sed do eiusmod tempor incididunt ut labore et dolore magna aliqua ut
    enim ad minim veniam quis nostrud exercitation ullamco laboris nisi ut
    aliquip ex ea commodo consequat duis aute irure dolor in reprehenderit
    in voluptate velit esse cillum dolore eu fugiat nulla pariatur
    excepteur sint occaecat cupidatat non proident sunt in culpa qui officia
    deserunt mollit anim id est laborum""".split()

    self.str = ' '.join( self.words )


</t>
<t tx="karstenw.20260127161638.5">def sentence(self, n=6):
    """ Generates a placeholder sentence with n words.
    The first character is uppercase and the sentence ends with a point.
    """
    s = ""
    comma = False
    for i in range(n):
        # We don't want the same word twice in a sentence.
        w = choice(self.words)

        while w in s:
            w = choice(self.words)
        s += w
        # If it's not the first or the last word,
        # there's a 10% chance we add a comma for realistic purposes.
        if not comma and 0 &lt; i &lt; n-2 and random() &gt; 0.9:
            comma = True
            s += ","
        s += " "
    return s.capitalize().strip() + "."

</t>
<t tx="karstenw.20260127161638.6">def paragraph(self, n=10, first=False):
    """ Generates a placeholder paragraph with n sentences.
    """
    # Calling x() returns a random number between 2 and 12.
    x = lambda: randrange(2, 12)
    s = ""
    # The first paragraph in a text starts with the typical
    # "Lorem ipsum dolor...".
    if first:
        s = " ".join(self.words[:x()]).capitalize()+". "
    for i in range(n):
        s += self.sentence(x())
        s += " "
    return s

</t>
<t tx="karstenw.20260127161638.7">def text(self, n=10):
    """ Generates multiple paragraphs of placeholder text.
    """
    short  = lambda: randrange(2, 8)
    middle = lambda: randrange(3, 20)
    long   = lambda: randrange(6, 40)
    s = ""
    first = True
    for i in range(n):
        s += self.paragraph(choice((short, middle, long))(), first)
        s += "\n\n"
        first = False
    return s

__call__ = text

</t>
<t tx="karstenw.20260127161638.8">def kant(self):
    """ Kant Generator, readable placeholder text.
    """
    from nodebox.util import autotext
    from os.path import dirname, join
    s = autotext(join(dirname(__file__), "kant.xml"))
    s = s.replace("    ", "\n").strip()
    s = s.replace("  ", " ")
    return s

english = kant

</t>
<t tx="karstenw.20260127161638.9">#### ORPHAN/WIDOW CONTROL #####################################################

def keep_together(str1, str2, width, widows=1, orphans=1, forward=False):

    """ If text(str1) ends with a widow line, move it to str2.
    If text(str2) starts with an orphan line, move it to str1.
    If forward is True the orphan is not moved to str1, but the end of str1
    is moved to str2.
    """

    # An orphan is a string whose height is less than that of n lines.
    keep = lambda str, n: _ctx.textheight(str, width) &lt;= _ctx.textheight(" ") * n

    # Check the end of str1.
    n = str1.split("\n")
    if len(n) &gt; 0 and keep(n[-1], widows) and not str2.startswith("\n"):
        str1 = "\n".join(n[:-1])
        str2 = n[-1]+" "+str2
    # Check the start of str2.
    n = str2.split("\n")
    if not forward and len(n) &gt; 0 and keep(n[0], orphans):
        str1 = str1+" "+n[0]
        str2 = "\n".join(n[1:])

    if forward:
        while len(str1) &gt; 0 and len(n) &gt; 0 and keep(n[0], orphans):
            # Find the last sentence in str1. Push it on str2.
            i = str1.strip()[:-1].rfind(".")
            str2 = str1[i+1:]+str2
            str1 = str1[:i+1]
            n = str2.split("\n")

    return (str1.lstrip(), str2.lstrip())

</t>
<t tx="karstenw.20260127161814.1">#### SYMBOLS ##################################################################

toxic      = u"\u2620"
radiation  = u"\u2622"
biohazard  = u"\u2623"
recycling  = u"\u2672"
arrow1     = u"\u27A1"
arrow2     = u"\u27B2"
heart      = u"\u2764"
bullet     = u"\u2022"
check      = u"\u2714"
cross      = u"\u2715"
telephone  = u"\u260F"
mail       = u"\u2709"
warning    = u"\u26A0"
sad        = u"\u2639"
happy      = u"\u263A"
euro       = u"\u20AC"
pound      = u"\u00A3"
yen        = u"\u00A5"
trademark  = u"\u2122"
copyright  = u"\u00A9"
registered = u"\u00AE"


</t>
</tnodes>
</leo_file>
